# Kapitola 13: Když JavaScript nestačí

V poslední kapitole už nebudeme řešit konkrétní úlohu, ale ukážeme si další směry, kam se v rámci prozkoumávání klientských webových technologií můžeme vydávat. Jakkoliv je totiž JavaScript užitečný, samotný nám nedokáže poskytnout vše, co bychom mohli potřebovat. Podívejme se tedy na několik populárních knihoven a nadstaveb, se kterými se praxi můžeme setkat.


## Zelenáči: React

Pro mnohé frontendové vývojáře je knihovna React stejně důležitá, jako JavaScript samotný. Jedná se o nástroj původně vyvinutý pro interní potřeby projektu Facebook, který se následně rychle rozšířil po celém internetu. React je určen k tvorbě stromu stránky ze vstupních dat. Takovou úlohu jsme v této knize řešili několikrát -- použili jsme k tomu buď vestavěný HTML parser (tj. vlastnost `innerHTML`), nebo individuální metody rozhraní DOM (jako např. `document.createElement`). React volí přístup koncepčně někde mezi těmito dvěma variantami: strom stránky vytváříme deklarativně (jako kdybychom rovnou psali HTML), ale atributy a textové uzly můžeme generovat rovnou z JavaScriptových dat (jako kdybychom nastavovali atributy DOM objektům).

Důležitým aspektem knihovny React je tzv. *virtual DOM*. Při použití Reactu necháváme knihovnu vygenerovat výstup při libovolné změně ve vstupních datech, což zní jako zbytečná práce. React ale vzniklé HTML prvky negeneruje rovnou ve stránce, ale v rámci svého virtuálního dokumentu. Do stránky pak promítne jen ty úpravy, které znamenají změnu v opravdovém dokumentu.

React staví zejména na těchto konceptech:

- HTML výstup definujeme pomocí **značkovacího jazyka JSX**, který HTML připomíná. Jedná se o mix HTML a JavaScriptu; podobá se také trochu *template literals* (tyto řetězce jsme viděli v páté kapitole). React lze, striktně vzato, používat i bez JSX, ale připravujeme se tím o značné množství funkcionality.
- Jednotlivé části kódu organizujeme do tzv. **komponent**, které zodpovídají za jednotlivé části stromu dokumentu. V jazyce JSX komponenty vypadají jjako HTML značky a nápadně připomínají *Custom Elements* (devátá kapitola). Komponenty jsou typicky implementovány jako JavaScriptové funkce.
- Úkolem komponent (a Reactu jako takového) je prezentace dat. Tato jsou komponentám v jazyce JSX předávána pomocí atributů, které mohou -- v porovnání s HTML -- obsahovat libovolné datové typy.

React si můžeme vyzkoušet na úloze z šesté kapitoly, ve které implementujeme zobrazování výsledků hledání. Vystačíme si s minimálním HTML dokumentem:

```html
<body><script src="index.js"></script></body>
```

Celé HTML plánujeme vytvářet pomocí Reactu. Budeme k tomu používat jazyk JSX, takže výsledný skript `index.js` si na závěr necháme vygenerovat. Místo toho začneme vstupním bodem aplikace v souboru `index.jsx`:

```jsx
// index.jsx
import React from "react";
import { createRoot } from "react-dom/client";
import App from "./App.jsx";


createRoot(document.body).render(<App />)
```

Většina reactových aplikací vypadá obdobně: potřebujeme knihovnu React, dále modul pro jeho převod do HTML DOM a hlavní komponentu, která zastřešuje celou aplikaci. V parametru funkce `render` již vidíme jazyk JSX v akci, když voláme komponentu `<App>`. Podívejme se na její implementaci:

```jsx
// App.jsx
import React, { useState, useRef } from "react";
import Results from "./Results.jsx";


export default function App() {
	let [results, setResults] = useState([]);
	let [query, setQuery] = useState("");
	let inputRef = useRef();

	async function onSubmit(e) {
		e.preventDefault();
		let query = inputRef.current.value;
		let response = await fetch(`/search?query=${encodeURIComponent(query)}`);
		let results = await response.json();
		setQuery(query);
		setResults(results);
	}

	return <>
		<h1>Hledání</h1>
		<form onSubmit={onSubmit}>
			<label>
				Hledaný výraz: <input type="text" ref={inputRef} />
			</label>
			<label>
				<button>🔎</button>
			</label>
		</form>
		<Results data={results} query={query} />
	</>;
}
```

Nenechme se zastrašit větším množstvím nezvyklých konstrukcí a pojďme si je po částech rozebrat. Poslední část funkce `App` definuje výsledné HTML, resp. výsledné JSX. To odpovídá přístupu *komponenty jsou funkce, transformující vstup na HTML*. Každá komponenta musí vrátit jen jeden prvek, takže když chceme vykreslit více HTML (nadpis, formulář, výsledky), musíme je zabalit do společného *bezejmenného* obalu, který se v JSX zapisuje jako `<>...</>`.

Na konci HTML používáme další vlastní komponentu (`<Results>`), ke které se dostaneme za chvíli. Syntaxe se složenými závorkami odpovídá interpolaci hodnot z proměnných; zápis

```jsx
<Results data={results} query={query} />
```

tedy znamená, že zde chceme vykreslit zadanou komponentu a předat jí obsah dvou lokálních proměnných.

Samotné hledání provede funkce `onSubmit`, kterou pro jednoduchost implementujeme pomocí `fetch`. Je to posluchač události, který v JSX přidáváme atributem `onSubmit`. Uvnitř této funkce potřebujeme přistoupit k hodnotě z vyhledávacího pole. Nemůžeme použít běžné dotazování pomocí `querySelector`, neboť celou tvorbu stromu DOMu za nás řeší React. K jednotlivým vytvořeným prvkům se ovšem můžeme dostat pomocí tzv. *referencí*. Lze si je představit jako samolepky, kterými pomocí atributu `ref` označíme prvky v JSX a díky nim se pak dostaneme k vygenerovaným DOM objektům.

Poslední specialita v souboru `App.jsx` je funkce `useState`. Připomeňme, že hlavní úkol Reactu je převést naše data na HTML. Ideálně bychom rádi, aby se tato operace provedla vždy, když vstupní data změníme. Pouhá změna hodnoty v proměnné (jako např. `results`) k tomu ale nestačí, protože React se o takové změně nedozví. Zde vstupuje do hry funkce `useState`, která vytvoří navzájem provázanou dvojici proměnných: jednu pro hodnotu a jednu pro jí odpovídající funkci, určenou ke změně hodnoty. Jakmile funkci zavoláme, hodnota se změní *a React dostane pokyn k překreslení*.

Pokračujme ke komponentě `<Results>` v souboru `Results.jsx`:

```jsx
// Results.jsx
import React from "react";
import Result from "./Result.jsx";


export default function Results(props) {
	if (!props.query) {
		return;
	}

	if (!props.data.length) {
		return <p>Tomuto dotazu nevyhovují žádné písně 🙁</p>;
	}

	let items = props.data.map(item => <Result data={item} />);
	return <>
		<h2>Nalezené písně pro dotaz: {props.query}</h2>
		<ol>{items}</ol>
	</>;
}
```

Zde žádná velká překvapení nejsou. JSX atributy, které komponentě předáváme, jsou v odpovídající JS funkci dostupné jako vlastnosti objektu, předaného v prvním parametru. Bývá obvyklé jej pojmenovat *props* (z anglického *properties*). Komponenta `<Results>` zastřešuje tři různé stavy (nebylo hledáno, nejsou výsledky, jsou výsledky), čemuž odpovídají jednotlivé podmínky. V případě nalezených výsledků vidíme cyklus realizovaný funkcionální metodou `map`. To znamená, že ve výsledném JSX interpolujeme proměnnou `items`, která je pole komponent typu `<Result>`. Ty jsou definovány v posledním souboru `Result.jsx`:

```jsx
// Result.jsx
import React from "react";


export default function Result(props) {
	let html = {__html: props.data.text};
	return <li>
		<a href={props.data.url}>{props.data.title}</a>
		<br/>
		<span dangerouslySetInnerHTML={html} />
	</li>;
}
```

Vzpomeňme si na šestou kapitolu, ve které jsme narazili na koncept `innerHTML` a jeho potenciální důsledky pro bezpečnost aplikace. React se nás snaží od podobného postupu odradit, takže přímé vložení HTML kódu z proměnné je nezvykle složité:

- Nejprve musíme nachystat objekt s klíčem `__html`, jehož hodnota je náš řetězec obsahující (potenciálně rizikové) HTML.
- Poté tento objekt předáme atributu `dangerouslySetInnerHTML`, jehož výmluvné označení varuje, že jde o nebezpečnou operaci.

Co dál? Napsaný kód je docela složitý a prohlížeč mu nerozumí. Jednak nezná syntaxi JSX, jednak si neumí poradit se zápisem `import React from "react"`. Budeme muset použít nějaký nástroj, který JSX převede na použitelný JavaScript.

Z minulé kapitoly známe program `esbuild` (používali jsme jej k *bundlingu*). Teď se nám hodí, že `esbuild` dokáže mimo jiné zpracovávat soubory JSX a také používat závislosti z adresáře `node_modules`. Použijeme proto `npm` a nainstalujeme několik balíčků:

```sh
npm i -g esbuild       # zpracování JSX, bundling
npm i react react-dom  # součásti reactu
```

Nástroj `esbuild` instalujeme globálně, zatímco React a React-DOM do `node_modules`. Teď zbyvá jen vygenerovat celou aplikaci:

```sh
esbuild --bundle index.jsx --outfile=index.js
```


## Koumáci: TypeScript

Pojďme si nyní prohlédnout další jazyk, který je dnes s JavaScriptem neodmyslitelně spojen. TypeScript vznikl jako nadmnožina JavaScriptu, ve které můžeme k proměnným a funkcím volitelně přidávat informace o jejich datovém typu. Říká se jim *typové anotace* a můžeme je znát i z dalších jazyků, jako např. Python či PHP. V JavaScriptu však typové anotace neexistují, takže kód psaný v TypeScriptu nemůžeme rovnou předhodit prohlížeči. Podobně jako u JSX je nutné nejprve kód převést na JavaScript. Tentokrát je ale převod velmi snadný, protože zahrnuje pouze smazání typových anotací.

A proč to celé vlastně chceme dělat? TypeScript je odpovědí na dynamické typování JavaScriptu, které je pro mnoho vývojářů až příliš flexibilní. Kvůli němu nelze rychlým pohledem na proměnnou či funkci odhadnout, jakých hodnot může nabývat. Snadno se pak vystavujeme riziku, že budeme nějakou hodnotu mylně považovat za jiný datový typ a dopustíme se různých chyb (např. výjimek způsobujících přerušení běhu programu).

S typovými anotacemi se v TypeScriptu setkáváme dvakrát. Když převádíme kód z TypeScriptu do JavaScriptu, kompilátor anotace nejen odstraní, ale také s jejich pomocí zkontroluje, zdali neporušujeme jimi definovaná pravidla -- jesti třeba do proměnné označené jako *string* nevkládáme číslo. Zároveň ale anotace používáme již při samotném psaní kódu, pokud si správně nastavíme editor. Ten může na základě typových informací rovnou označovat bloky problematického kódu, případně napovídat typy a názvy parametrů funkcí a podobně.

Zdrojový kód v TypeScriptu píšeme do souborů s příponou `.ts`. Nejčastěji se typové anotace objevují za dvojtečkou, za názvem proměnné či parametru funkce. Můžeme si to vyzkoušet na příkladu triviální sčítací funkce:

```ts
function add(a: number, b: number): number {
	return a+b;
}
```

Typové anotace jsme přidali jak k oběma parametrům, tak k funkci jako takové -- říkáme tím, že její návratová hodnota je číslo. Na chování kódu anotace nemají žádný vliv, takže pokud bychom funkci předali dva řetězce, dojde k jejich (pravděpodobně chybnému) spojení. Proto bychom rádi, aby nás nějaká komponenta zavčasu (na základě anotací) upozornila, že funkci voláme špatně. Nejprve napíšeme problémový kód:

```ts
let a = "protřepat";
let b = "nemíchat";
let c = add(a, b);
```

Dobře nastavené vývojové prostředí by nás už nyní mělo varovat, že funkci voláme chybně. My ale stojíme o kontrolu spojenou s převodem do prostého JavaScriptu. K tomu použijeme oficiální kompilátor *tsc* (TypeScript Compiler). Nainstalujeme jej pomocí npm:

```sh
npm i -g typescript
```

Pro spuštění kompilace stačí předat jméno souboru s TypeScriptovým kódem:

```sh
tsc test.ts  # FIXME jmeno souboru

test.ts:6:13 - error TS2345: Argument of type 'string' is not assignable to parameter of type 'number'.
```

Dostali jsme vynadáno přesně dle očekávání. Zároveň s tím ale vznikl soubor `test.js` FIXME, který obsahuje náš chybný kód bez anotací. Kompilátor nám tedy nebrání v psaní pochybného kódu, ale pokud mu k tomu dáme příležitost, upozorní nás na problematická místa.

Mimochodem: v minulých kapitolách a podkapitolách jsme používali nástroj `esbuild`, který mj. provádí *bundling* a transpilaci JSX. Zvídavého čtenáře možná napadne, zdali by pomocí `esbuild` nešel kompilovat i zdrojový kód v TypeScriptu. Odpověď je *ano, ale* -- protože esbuild sice dovede odstranit typové anotace, ale neprovede při tom typovou kontrolu. Dostáváme tak jen polovinu funkcionality, kterou nám nabízí `tsc`.



## Profíci: WebAssembly

