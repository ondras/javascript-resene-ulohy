# Kapitola 13: KdyÅ¾ JavaScript nestaÄÃ­

V poslednÃ­ kapitole uÅ¾ nebudeme Å™eÅ¡it konkrÃ©tnÃ­ Ãºlohu, ale ukÃ¡Å¾eme si dalÅ¡Ã­ smÄ›ry, kam se v rÃ¡mci prozkoumÃ¡vÃ¡nÃ­ klientskÃ½ch webovÃ½ch technologiÃ­ mÅ¯Å¾eme vydÃ¡vat. Jakkoliv je totiÅ¾ JavaScript uÅ¾iteÄnÃ½, samotnÃ½ nÃ¡m nedokÃ¡Å¾e poskytnout vÅ¡e, co bychom mohli potÅ™ebovat. PodÃ­vejme se tedy na nÄ›kolik populÃ¡rnÃ­ch knihoven a nadstaveb, se kterÃ½mi se praxi mÅ¯Å¾eme setkat.


## ZelenÃ¡Äi: React

Pro mnohÃ© frontendovÃ© vÃ½vojÃ¡Å™e je knihovna React stejnÄ› dÅ¯leÅ¾itÃ¡, jako JavaScript samotnÃ½. JednÃ¡ se o nÃ¡stroj pÅ¯vodnÄ› vyvinutÃ½ pro internÃ­ potÅ™eby projektu Facebook, kterÃ½ se nÃ¡slednÄ› rychle rozÅ¡Ã­Å™il po celÃ©m internetu. React je urÄen k tvorbÄ› stromu strÃ¡nky ze vstupnÃ­ch dat. Takovou Ãºlohu jsme v tÃ©to knize Å™eÅ¡ili nÄ›kolikrÃ¡t -- pouÅ¾ili jsme k tomu buÄ vestavÄ›nÃ½ HTML parser (tj. vlastnost `innerHTML`), nebo individuÃ¡lnÃ­ metody rozhranÃ­ DOM (jako napÅ™. `document.createElement`). React volÃ­ pÅ™Ã­stup koncepÄnÄ› nÄ›kde mezi tÄ›mito dvÄ›ma variantami: strom strÃ¡nky vytvÃ¡Å™Ã­me deklarativnÄ› (jako kdybychom rovnou psali HTML), ale atributy a textovÃ© uzly mÅ¯Å¾eme generovat rovnou z JavaScriptovÃ½ch dat (jako kdybychom nastavovali atributy DOM objektÅ¯m).

DÅ¯leÅ¾itÃ½m aspektem knihovny React je tzv. *virtual DOM*. PÅ™i pouÅ¾itÃ­ Reactu nechÃ¡vÃ¡me knihovnu vygenerovat vÃ½stup pÅ™i libovolnÃ© zmÄ›nÄ› ve vstupnÃ­ch datech, coÅ¾ znÃ­ jako zbyteÄnÃ¡ prÃ¡ce. React ale vzniklÃ© HTML prvky negeneruje rovnou ve strÃ¡nce, ale v rÃ¡mci svÃ©ho virtuÃ¡lnÃ­ho dokumentu. Do strÃ¡nky pak promÃ­tne jen ty Ãºpravy, kterÃ© znamenajÃ­ zmÄ›nu v opravdovÃ©m dokumentu.

React stavÃ­ zejmÃ©na na tÄ›chto konceptech:

- HTML vÃ½stup definujeme pomocÃ­ **znaÄkovacÃ­ho jazyka JSX**, kterÃ½ HTML pÅ™ipomÃ­nÃ¡. JednÃ¡ se o mix HTML a JavaScriptu; podobÃ¡ se takÃ© trochu *template literals* (tyto Å™etÄ›zce jsme vidÄ›li v pÃ¡tÃ© kapitole). React lze, striktnÄ› vzato, pouÅ¾Ã­vat i bez JSX, ale pÅ™ipravujeme se tÃ­m o znaÄnÃ© mnoÅ¾stvÃ­ funkcionality.
- JednotlivÃ© ÄÃ¡sti kÃ³du organizujeme do tzv. **komponent**, kterÃ© zodpovÃ­dajÃ­ za jednotlivÃ© ÄÃ¡sti stromu dokumentu. V jazyce JSX komponenty vypadajÃ­ jjako HTML znaÄky a nÃ¡padnÄ› pÅ™ipomÃ­najÃ­ *Custom Elements* (devÃ¡tÃ¡ kapitola). Komponenty jsou typicky implementovÃ¡ny jako JavaScriptovÃ© funkce.
- Ãškolem komponent (a Reactu jako takovÃ©ho) je prezentace dat. Tato jsou komponentÃ¡m v jazyce JSX pÅ™edÃ¡vÃ¡na pomocÃ­ atributÅ¯, kterÃ© mohou -- v porovnÃ¡nÃ­ s HTML -- obsahovat libovolnÃ© datovÃ© typy.

React si mÅ¯Å¾eme vyzkouÅ¡et na Ãºloze z Å¡estÃ© kapitoly, ve kterÃ© implementujeme zobrazovÃ¡nÃ­ vÃ½sledkÅ¯ hledÃ¡nÃ­. VystaÄÃ­me si s minimÃ¡lnÃ­m HTML dokumentem:

```html
<body><script src="index.js"></script></body>
```

CelÃ© HTML plÃ¡nujeme vytvÃ¡Å™et pomocÃ­ Reactu. Budeme k tomu pouÅ¾Ã­vat jazyk JSX, takÅ¾e vÃ½slednÃ½ skript `index.js` si na zÃ¡vÄ›r nechÃ¡me vygenerovat. MÃ­sto toho zaÄneme vstupnÃ­m bodem aplikace v souboru `index.jsx`:

```jsx
// index.jsx
import React from "react";
import { createRoot } from "react-dom/client";
import App from "./App.jsx";


createRoot(document.body).render(<App />)
```

VÄ›tÅ¡ina reactovÃ½ch aplikacÃ­ vypadÃ¡ obdobnÄ›: potÅ™ebujeme knihovnu React, dÃ¡le modul pro jeho pÅ™evod do HTML DOM a hlavnÃ­ komponentu, kterÃ¡ zastÅ™eÅ¡uje celou aplikaci. V parametru funkce `render` jiÅ¾ vidÃ­me jazyk JSX v akci, kdyÅ¾ volÃ¡me komponentu `<App>`. PodÃ­vejme se na jejÃ­ implementaci:

```jsx
// App.jsx
import React, { useState, useRef } from "react";
import Results from "./Results.jsx";


export default function App() {
	let [results, setResults] = useState([]);
	let [query, setQuery] = useState("");
	let inputRef = useRef();

	async function onSubmit(e) {
		e.preventDefault();
		let query = inputRef.current.value;
		let response = await fetch(`/search?query=${encodeURIComponent(query)}`);
		let results = await response.json();
		setQuery(query);
		setResults(results);
	}

	return <>
		<h1>HledÃ¡nÃ­</h1>
		<form onSubmit={onSubmit}>
			<label>
				HledanÃ½ vÃ½raz: <input type="text" ref={inputRef} />
			</label>
			<label>
				<button>ğŸ”</button>
			</label>
		</form>
		<Results data={results} query={query} />
	</>;
}
```

Nenechme se zastraÅ¡it vÄ›tÅ¡Ã­m mnoÅ¾stvÃ­m nezvyklÃ½ch konstrukcÃ­ a pojÄme si je po ÄÃ¡stech rozebrat. PoslednÃ­ ÄÃ¡st funkce `App` definuje vÃ½slednÃ© HTML, resp. vÃ½slednÃ© JSX. To odpovÃ­dÃ¡ pÅ™Ã­stupu *komponenty jsou funkce, transformujÃ­cÃ­ vstup na HTML*. KaÅ¾dÃ¡ komponenta musÃ­ vrÃ¡tit jen jeden prvek, takÅ¾e kdyÅ¾ chceme vykreslit vÃ­ce HTML (nadpis, formulÃ¡Å™, vÃ½sledky), musÃ­me je zabalit do spoleÄnÃ©ho *bezejmennÃ©ho* obalu, kterÃ½ se v JSX zapisuje jako `<>...</>`.

Na konci HTML pouÅ¾Ã­vÃ¡me dalÅ¡Ã­ vlastnÃ­ komponentu (`<Results>`), ke kterÃ© se dostaneme za chvÃ­li. Syntaxe se sloÅ¾enÃ½mi zÃ¡vorkami odpovÃ­dÃ¡ interpolaci hodnot z promÄ›nnÃ½ch; zÃ¡pis

```jsx
<Results data={results} query={query} />
```

tedy znamenÃ¡, Å¾e zde chceme vykreslit zadanou komponentu a pÅ™edat jÃ­ obsah dvou lokÃ¡lnÃ­ch promÄ›nnÃ½ch.

SamotnÃ© hledÃ¡nÃ­ provede funkce `onSubmit`, kterou pro jednoduchost implementujeme pomocÃ­ `fetch`. Je to posluchaÄ udÃ¡losti, kterÃ½ v JSX pÅ™idÃ¡vÃ¡me atributem `onSubmit`. UvnitÅ™ tÃ©to funkce potÅ™ebujeme pÅ™istoupit k hodnotÄ› z vyhledÃ¡vacÃ­ho pole. NemÅ¯Å¾eme pouÅ¾Ã­t bÄ›Å¾nÃ© dotazovÃ¡nÃ­ pomocÃ­ `querySelector`, neboÅ¥ celou tvorbu stromu DOMu za nÃ¡s Å™eÅ¡Ã­ React. K jednotlivÃ½m vytvoÅ™enÃ½m prvkÅ¯m se ovÅ¡em mÅ¯Å¾eme dostat pomocÃ­ tzv. *referencÃ­*. Lze si je pÅ™edstavit jako samolepky, kterÃ½mi pomocÃ­ atributu `ref` oznaÄÃ­me prvky v JSX a dÃ­ky nim se pak dostaneme k vygenerovanÃ½m DOM objektÅ¯m.

PoslednÃ­ specialita v souboru `App.jsx` je funkce `useState`. PÅ™ipomeÅˆme, Å¾e hlavnÃ­ Ãºkol Reactu je pÅ™evÃ©st naÅ¡e data na HTML. IdeÃ¡lnÄ› bychom rÃ¡di, aby se tato operace provedla vÅ¾dy, kdyÅ¾ vstupnÃ­ data zmÄ›nÃ­me. PouhÃ¡ zmÄ›na hodnoty v promÄ›nnÃ© (jako napÅ™. `results`) k tomu ale nestaÄÃ­, protoÅ¾e React se o takovÃ© zmÄ›nÄ› nedozvÃ­. Zde vstupuje do hry funkce `useState`, kterÃ¡ vytvoÅ™Ã­ navzÃ¡jem provÃ¡zanou dvojici promÄ›nnÃ½ch: jednu pro hodnotu a jednu pro jÃ­ odpovÃ­dajÃ­cÃ­ funkci, urÄenou ke zmÄ›nÄ› hodnoty. Jakmile funkci zavolÃ¡me, hodnota se zmÄ›nÃ­ *a React dostane pokyn k pÅ™ekreslenÃ­*.

PokraÄujme ke komponentÄ› `<Results>` v souboru `Results.jsx`:

```jsx
// Results.jsx
import React from "react";
import Result from "./Result.jsx";


export default function Results(props) {
	if (!props.query) {
		return;
	}

	if (!props.data.length) {
		return <p>Tomuto dotazu nevyhovujÃ­ Å¾Ã¡dnÃ© pÃ­snÄ› ğŸ™</p>;
	}

	let items = props.data.map(item => <Result data={item} />);
	return <>
		<h2>NalezenÃ© pÃ­snÄ› pro dotaz: {props.query}</h2>
		<ol>{items}</ol>
	</>;
}
```

Zde Å¾Ã¡dnÃ¡ velkÃ¡ pÅ™ekvapenÃ­ nejsou. JSX atributy, kterÃ© komponentÄ› pÅ™edÃ¡vÃ¡me, jsou v odpovÃ­dajÃ­cÃ­ JS funkci dostupnÃ© jako vlastnosti objektu, pÅ™edanÃ©ho v prvnÃ­m parametru. BÃ½vÃ¡ obvyklÃ© jej pojmenovat *props* (z anglickÃ©ho *properties*). Komponenta `<Results>` zastÅ™eÅ¡uje tÅ™i rÅ¯znÃ© stavy (nebylo hledÃ¡no, nejsou vÃ½sledky, jsou vÃ½sledky), ÄemuÅ¾ odpovÃ­dajÃ­ jednotlivÃ© podmÃ­nky. V pÅ™Ã­padÄ› nalezenÃ½ch vÃ½sledkÅ¯ vidÃ­me cyklus realizovanÃ½ funkcionÃ¡lnÃ­ metodou `map`. To znamenÃ¡, Å¾e ve vÃ½slednÃ©m JSX interpolujeme promÄ›nnou `items`, kterÃ¡ je pole komponent typu `<Result>`. Ty jsou definovÃ¡ny v poslednÃ­m souboru `Result.jsx`:

```jsx
// Result.jsx
import React from "react";


export default function Result(props) {
	let html = {__html: props.data.text};
	return <li>
		<a href={props.data.url}>{props.data.title}</a>
		<br/>
		<span dangerouslySetInnerHTML={html} />
	</li>;
}
```

VzpomeÅˆme si na Å¡estou kapitolu, ve kterÃ© jsme narazili na koncept `innerHTML` a jeho potenciÃ¡lnÃ­ dÅ¯sledky pro bezpeÄnost aplikace. React se nÃ¡s snaÅ¾Ã­ od podobnÃ©ho postupu odradit, takÅ¾e pÅ™Ã­mÃ© vloÅ¾enÃ­ HTML kÃ³du z promÄ›nnÃ© je nezvykle sloÅ¾itÃ©:

- Nejprve musÃ­me nachystat objekt s klÃ­Äem `__html`, jehoÅ¾ hodnota je nÃ¡Å¡ Å™etÄ›zec obsahujÃ­cÃ­ (potenciÃ¡lnÄ› rizikovÃ©) HTML.
- PotÃ© tento objekt pÅ™edÃ¡me atributu `dangerouslySetInnerHTML`, jehoÅ¾ vÃ½mluvnÃ© oznaÄenÃ­ varuje, Å¾e jde o nebezpeÄnou operaci.

Co dÃ¡l? NapsanÃ½ kÃ³d je docela sloÅ¾itÃ½ a prohlÃ­Å¾eÄ mu nerozumÃ­. Jednak neznÃ¡ syntaxi JSX, jednak si neumÃ­ poradit se zÃ¡pisem `import React from "react"`. Budeme muset pouÅ¾Ã­t nÄ›jakÃ½ nÃ¡stroj, kterÃ½ JSX pÅ™evede na pouÅ¾itelnÃ½ JavaScript.

Z minulÃ© kapitoly znÃ¡me program `esbuild` (pouÅ¾Ã­vali jsme jej k *bundlingu*). TeÄ se nÃ¡m hodÃ­, Å¾e `esbuild` dokÃ¡Å¾e mimo jinÃ© zpracovÃ¡vat soubory JSX a takÃ© pouÅ¾Ã­vat zÃ¡vislosti z adresÃ¡Å™e `node_modules`. PouÅ¾ijeme proto `npm` a nainstalujeme nÄ›kolik balÃ­ÄkÅ¯:

```sh
npm i -g esbuild       # zpracovÃ¡nÃ­ JSX, bundling
npm i react react-dom  # souÄÃ¡sti reactu
```

NÃ¡stroj `esbuild` instalujeme globÃ¡lnÄ›, zatÃ­mco React a React-DOM do `node_modules`. TeÄ zbyvÃ¡ jen vygenerovat celou aplikaci:

```sh
esbuild --bundle index.jsx --outfile=index.js
```


## KoumÃ¡ci: TypeScript

PojÄme si nynÃ­ prohlÃ©dnout dalÅ¡Ã­ jazyk, kterÃ½ je dnes s JavaScriptem neodmyslitelnÄ› spojen. TypeScript vznikl jako nadmnoÅ¾ina JavaScriptu, ve kterÃ© mÅ¯Å¾eme k promÄ›nnÃ½m a funkcÃ­m volitelnÄ› pÅ™idÃ¡vat informace o jejich datovÃ©m typu. Å˜Ã­kÃ¡ se jim *typovÃ© anotace* a mÅ¯Å¾eme je znÃ¡t i z dalÅ¡Ã­ch jazykÅ¯, jako napÅ™. Python Äi PHP. V JavaScriptu vÅ¡ak typovÃ© anotace neexistujÃ­, takÅ¾e kÃ³d psanÃ½ v TypeScriptu nemÅ¯Å¾eme rovnou pÅ™edhodit prohlÃ­Å¾eÄi. PodobnÄ› jako u JSX je nutnÃ© nejprve kÃ³d pÅ™evÃ©st na JavaScript. TentokrÃ¡t je ale pÅ™evod velmi snadnÃ½, protoÅ¾e zahrnuje pouze smazÃ¡nÃ­ typovÃ½ch anotacÃ­.

A proÄ to celÃ© vlastnÄ› chceme dÄ›lat? TypeScript je odpovÄ›dÃ­ na dynamickÃ© typovÃ¡nÃ­ JavaScriptu, kterÃ© je pro mnoho vÃ½vojÃ¡Å™Å¯ aÅ¾ pÅ™Ã­liÅ¡ flexibilnÃ­. KvÅ¯li nÄ›mu nelze rychlÃ½m pohledem na promÄ›nnou Äi funkci odhadnout, jakÃ½ch hodnot mÅ¯Å¾e nabÃ½vat. Snadno se pak vystavujeme riziku, Å¾e budeme nÄ›jakou hodnotu mylnÄ› povaÅ¾ovat za jinÃ½ datovÃ½ typ a dopustÃ­me se rÅ¯znÃ½ch chyb (napÅ™. vÃ½jimek zpÅ¯sobujÃ­cÃ­ch pÅ™eruÅ¡enÃ­ bÄ›hu programu).

S typovÃ½mi anotacemi se v TypeScriptu setkÃ¡vÃ¡me dvakrÃ¡t. KdyÅ¾ pÅ™evÃ¡dÃ­me kÃ³d z TypeScriptu do JavaScriptu, kompilÃ¡tor anotace nejen odstranÃ­, ale takÃ© s jejich pomocÃ­ zkontroluje, zdali neporuÅ¡ujeme jimi definovanÃ¡ pravidla -- jesti tÅ™eba do promÄ›nnÃ© oznaÄenÃ© jako *string* nevklÃ¡dÃ¡me ÄÃ­slo. ZÃ¡roveÅˆ ale anotace pouÅ¾Ã­vÃ¡me jiÅ¾ pÅ™i samotnÃ©m psanÃ­ kÃ³du, pokud si sprÃ¡vnÄ› nastavÃ­me editor. Ten mÅ¯Å¾e na zÃ¡kladÄ› typovÃ½ch informacÃ­ rovnou oznaÄovat bloky problematickÃ©ho kÃ³du, pÅ™Ã­padnÄ› napovÃ­dat typy a nÃ¡zvy parametrÅ¯ funkcÃ­ a podobnÄ›.

ZdrojovÃ½ kÃ³d v TypeScriptu pÃ­Å¡eme do souborÅ¯ s pÅ™Ã­ponou `.ts`. NejÄastÄ›ji se typovÃ© anotace objevujÃ­ za dvojteÄkou, za nÃ¡zvem promÄ›nnÃ© Äi parametru funkce. MÅ¯Å¾eme si to vyzkouÅ¡et na pÅ™Ã­kladu triviÃ¡lnÃ­ sÄÃ­tacÃ­ funkce:

```ts
function add(a: number, b: number): number {
	return a+b;
}
```

TypovÃ© anotace jsme pÅ™idali jak k obÄ›ma parametrÅ¯m, tak k funkci jako takovÃ© -- Å™Ã­kÃ¡me tÃ­m, Å¾e jejÃ­ nÃ¡vratovÃ¡ hodnota je ÄÃ­slo. Na chovÃ¡nÃ­ kÃ³du anotace nemajÃ­ Å¾Ã¡dnÃ½ vliv, takÅ¾e pokud bychom funkci pÅ™edali dva Å™etÄ›zce, dojde k jejich (pravdÄ›podobnÄ› chybnÃ©mu) spojenÃ­. Proto bychom rÃ¡di, aby nÃ¡s nÄ›jakÃ¡ komponenta zavÄasu (na zÃ¡kladÄ› anotacÃ­) upozornila, Å¾e funkci volÃ¡me Å¡patnÄ›. Nejprve napÃ­Å¡eme problÃ©movÃ½ kÃ³d:

```ts
let a = "protÅ™epat";
let b = "nemÃ­chat";
let c = add(a, b);
```

DobÅ™e nastavenÃ© vÃ½vojovÃ© prostÅ™edÃ­ by nÃ¡s uÅ¾ nynÃ­ mÄ›lo varovat, Å¾e funkci volÃ¡me chybnÄ›. My ale stojÃ­me o kontrolu spojenou s pÅ™evodem do prostÃ©ho JavaScriptu. K tomu pouÅ¾ijeme oficiÃ¡lnÃ­ kompilÃ¡tor *tsc* (TypeScript Compiler). Nainstalujeme jej pomocÃ­ npm:

```sh
npm i -g typescript
```

Pro spuÅ¡tÄ›nÃ­ kompilace staÄÃ­ pÅ™edat jmÃ©no souboru s TypeScriptovÃ½m kÃ³dem:

```sh
tsc test.ts  # FIXME jmeno souboru

test.ts:6:13 - error TS2345: Argument of type 'string' is not assignable to parameter of type 'number'.
```

Dostali jsme vynadÃ¡no pÅ™esnÄ› dle oÄekÃ¡vÃ¡nÃ­. ZÃ¡roveÅˆ s tÃ­m ale vznikl soubor `test.js` FIXME, kterÃ½ obsahuje nÃ¡Å¡ chybnÃ½ kÃ³d bez anotacÃ­. KompilÃ¡tor nÃ¡m tedy nebrÃ¡nÃ­ v psanÃ­ pochybnÃ©ho kÃ³du, ale pokud mu k tomu dÃ¡me pÅ™Ã­leÅ¾itost, upozornÃ­ nÃ¡s na problematickÃ¡ mÃ­sta.

Mimochodem: v minulÃ½ch kapitolÃ¡ch a podkapitolÃ¡ch jsme pouÅ¾Ã­vali nÃ¡stroj `esbuild`, kterÃ½ mj. provÃ¡dÃ­ *bundling* a transpilaci JSX. ZvÃ­davÃ©ho ÄtenÃ¡Å™e moÅ¾nÃ¡ napadne, zdali by pomocÃ­ `esbuild` neÅ¡el kompilovat i zdrojovÃ½ kÃ³d v TypeScriptu. OdpovÄ›Ä je *ano, ale* -- protoÅ¾e esbuild sice dovede odstranit typovÃ© anotace, ale neprovede pÅ™i tom typovou kontrolu. DostÃ¡vÃ¡me tak jen polovinu funkcionality, kterou nÃ¡m nabÃ­zÃ­ `tsc`.



## ProfÃ­ci: WebAssembly

