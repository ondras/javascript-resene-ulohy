# Kapitola 11: HTML Canvas

## Úloha

Rádi bychom uživatelům, kteří se na našem webu zaregistrují, dovolili nahrát profilový obrázek. Tento se bude zobrazovat vedle jejich jména u diskuzních příspěvků a dalších aktivit. Protože se bude zobrazovat malý, není vhodné, aby nám uživatelé nahrávali své portréty ve velkém rozlišení. Proto obrázek před nahráním zmenšete tak, aby jeho delší strana nepřesahovala zadaný limit (např. 1000 pixelů).

### Řešení

```html
<!-- kapitola-11.html -->
<input type="file" accept="image/*" />
<script src="kapitola-11.js"></script>
```

```js
// kapitola-11.js
const MAX = 1000;

async function loadImage(file) {
	let img = new Image();
	img.src = URL.createObjectURL(file);
	await img.decode();
	return img;
}

function resizeImage(img) {
	let scale = Math.max(img.naturalWidth/MAX, img.naturalWidth/MAX, 1);
	let canvas = document.createElement("canvas");
	canvas.width = Math.round(img.width / scale);
	canvas.height = Math.round(img.height / scale);
	let ctx = canvas.getContext("2d");
	ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
	return canvas.toDataURL("image/jpeg");
}

async function onChange(e) {
	let file = e.target.files[0];
	if (!file) return;

	let sourceImage = await loadImage(file);
	let targetImage = resizeImage(sourceImage);

	fetch("/upload", {
		method: "POST",
		body: targetImage
	});
}

let input = document.querySelector("[type=file]");
input.addEventListener("change", onChange);
```

Přestože vzorové řešení má jen kolem třiceti řádků, obsahuje řadu novinek. Pro snazší pochopení si úlohu rozdělíme na tři menší části: získání obrazových dat z disku uživatele, zmenšení a následné nahrání na server.

### Načtení obrázku

V klientském JavaScriptu nelze přistupovat k libovolným souborům na disku uživatele. Představovalo by to značné bezpečnostní riziko, neboť při návštěvě webové stránky by cizí skript mohl snadno číst naše citlivá data a následně je například posílat na server útočníka. Panuje proto pravidlo, že prohlížeč zpřístupní obsah jen takových souborů, které za tímto účelem uživatel explicitně označil. Možnosti jsou dvě: buď takový soubor uživatel myší přetáhnul z plochy do okna prohlížeče, nebo nějaký soubor vybral prostřednictvím formulářového prvku `<input type=file>`.

Druhá možnost je o něco přímočařejší a také častější, takže ji využijeme pro vzorové řešení. Atributem `accept` omezíme typ použitelných souborů, takže následně nemusíme uvažovat variantu, kdy by uživatel vybral nějaký soubor, který vůbec není obrázek. Po vybrání souboru vznikne událost `change` a tím dojde ke spuštění posluchače `onChange`. Vlastnost `files` HTML prvku `<input>` v takové chvíli obsahuje pole vybraných souborů (víc by jich mohlo být, pokud bychom použili atribut `multiple`). Jedná se o proměnné typu `File` -- s takovým objektem jsem se zatím nesetkali.

Objekt `File` slouží k přístupu k souboru, ale nedovoluje nám přímo získat jeho obsah. S proměnnou tohoto typu můžeme provádět tyto hlavní operace:

1. Můžeme ji předat funkci `fetch` a tím obsah souboru nahrát. To dělat nechceme, protože bychom nahrávali originální obrázek, který může být příliš velký.

1. Můžeme použít objekt `FileReader`, prostřednictvím kterého bychom se dostali k obsahu souboru (jednotlivým bajtům). To vypadá užitečně, ale jedná se o příliš nízkoúrovňový přístup. Museli bychom v JavaScriptu implementovat dekódování obrazového formátu (JPEG, PNG, GIF, &hellip;), což je zbytečně složité a pracné.

1. Protože víme, že vybraný soubor odpovídá obrázku, můžeme jej využít k vytvoření HTML prvku `<img>`. Ten je vhodný pro následné zmenšování.

HTML značka `<img>` ovšem vyžaduje URL, které nemáme. Naštěstí existuje šikovná a nepříliš známá funkce `URL.createObjectURL`, která slouží právě k tomuto účelu. Pro předaný objekt typu `File` vytvoří *falešené* dočasné URL, které můžeme až do zavření stránky používat tam, kde je URL očekáváno. V našem případě ho předáme do atributu `src` nově vytvořeného obrázku.

Ještě než začneme tento obrázek zpracovávat, musíme počkat, než jej prohlížeč načte (teprve potom budou například známy jeho rozměry). Načtení obrázku je asynchronní proces a máme dva způsoby, jak s ním pracovat:

1. Počkáme na událost `load`. To by znamenalo přidání posluchače a zabalení následného kódu do vlastní funkce. Bude to fungovat, ale existuje snazší řešení.

1. Použijeme relativně moderní metodu `decode()`, která taktéž čeká na načtení a vrací Promise. To je pro náš případ ideální.


### Změna rozměrů

Uživatelem vybraný soubor máme nyní načtený v HTML obrázku. Jeho rozměry jsou k dispozici ve vlastnostech `naturalWidth` a `naturalHeight` (mohli bychom se také zajímat o vlastnosti `width` a `height`, ale ty mohou být ovlivněny například pomocí CSS). Můžeme tedy vypočítat správnou cílovou velikost.

K výpočtu si nejprve nachystáme *měřítko*: číselnou hodnotu, která říká, kolikrát je nutné obrázek zmenšit. Protože chceme zachovat původní poměr stran, budeme oba rozměry zmenšovat stejně. Měřítko definujeme tímto vzorcem:

```js
let scale = Math.max(img.naturalWidth/MAX, img.naturalWidth/MAX, 1);
```

První parametr funkce `max` říká, *kolikrát je šířka obrázku větší, než požadovaný limit*. Druhý parametr funguje shodně, jen pro výšku. Z těchto hodnot bereme maximum, neboť v zadání je požadováno takové zmenšení, po kterém budou obě strany menší nebo rovny limitu.

Jednička na konci je malý trik: mohlo by se stát, že by nám uživatel nahrál obrázek, jehož oba rozměry jsou menší než limit. Měřítko by pak bylo menší než jedna a při následné transformaci bychom proto obrázek *zvětšili*. To je zbytečné a nežádoucí, takže pro malé obrázky zvolíme měřítko rovno jedné a tím pádem zůstane jejich původní velikost.

Nové rozměry pak vypočítáme jako ty původní vydělené měřítkem. V tuto chvíli nám již ovšem nestačí HTML obrázky. I kdybychom jim nastavovali menší rozměry, prohlížeč provede zmenšení jen pro potřeby zobrazení. Nahraná obrazová data budou stále v původním rozlišení. Proto musíme začít pracovat s HTML značkou `<canvas>`, která představuje univerzální nástroj pro tvorbu a manipulaci s rastrovými obrazovými daty.

Prvek `<canvas>` (anglické označení pro malířské plátno) sice patří do jazyka HTML, ale pracujeme s ním výhradně pomocí JavaScriptových funkcí a vlastností. A že jich je! Zatím si ukážeme jen úplný základ práce s canvasem, ale v následujících podkapitolách prozkoumáme i další jeho možnosti.

Naše plátno potřebuje především nastavit rozměry. K tomu použijeme výše zmíněný výpočet:

```js
let canvas = document.createElement("canvas");
canvas.width = Math.round(img.width / scale);
canvas.height = Math.round(img.height / scale);
```

Canvas odpovídá obdélníku pixelů, proto je potřeba jeho rozměry nastavovat v celých čísel. Měřítko i výsledek dělení mohou být čísla desetinná, proto je na celé pixely musíme zaokrouhlit.

Funkce, které canvas nabízí, jsou v rámci jeho JS API seskupeny do tzv. *kontextů* -- JavaScriptových objektů, specializovaných pro různé vykreslovací operace. Pro naši úlohu je vhodný kontext nazvaný prostě `"2d"`. Ten dovoluje takové operace, které známe například z programu Malování: tah štětcem, vyplňování plochy, vkládání obrázků a podobně. Čistě teoretickým příkladem dalšího kontextu může být `"webgl"`, což je vysoce specializované rozhraní určené pro vykreslování pomocí akcelerované grafiky prostřednictvím jazyka OpenGL. S takto pokročilými technikami se ovšem v této knize nesetkáme.

Metoda `drawImage` patří dvourozměrnému kontextu a má řadu různých signatur. Prvním parametrem je zdrojový obrázek, další dva parametry definují cílové souřadnice (místo, na kterém v canvasu vykreslíme levý horní roh obrázku) a nejdůležitější jsou poslední dva parametry -- cílové rozměry. Právě díky nim prohlížeč vykreslí původní obrázek do canvasu zmenšený.

Celá tato zmenšovací operace nás stojí jen dva řádky kódu:

```js
let ctx = canvas.getContext("2d");
ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
```


### Nahrání obrázku

Máme skoro hotovo! Zmenšili jsme portrét, jen ho teď nemáme v HTML obrázku, ale v HTML canvasu. A ten nelze sám o sobě vzít a nahrát na server. Mimo jiné proto, že canvas představuje dvourozměrné pole pixelů, ale soubory obsahují obrazová data v nějakém formátu. Musíme proto prohlížeč nejprve požádat, aby obrazová data z canvasu vhodně zakódoval.

Canvas pro tyto účely disponuje dvěma metodami, které dělají v podstatě to samé: `toDataURL` a `toBlob`. Liší se takto:

- Metoda `toBlob` je asynchronní (vrací Promise)

```js


### Co jsme se naučili

Po vyřešení desáté úlohy by měl čtenář chápat a ovládat:


## Zelenáči:

## Koumáci:

## Profíci:

