# Kapitola 11: HTML Canvas

## Úloha

Rádi bychom uživatelům, kteří se na našem webu zaregistrují, dovolili nahrát profilový obrázek. Tento se bude zobrazovat vedle jejich jména u diskuzních příspěvků a dalších aktivit. Protože se bude zobrazovat malý, není vhodné, aby nám uživatelé nahrávali své portréty ve velkém rozlišení. Proto obrázek před nahráním zmenšete tak, aby jeho delší strana nepřesahovala zadaný limit (např. 1000 pixelů).

### Řešení

```html
<!-- kapitola-11.html -->
<input type="file" accept="image/*" />
<script src="kapitola-11.js"></script>
```

```js
// kapitola-11.js
const MAX = 1000;

async function loadImage(file) {
	let img = new Image();
	img.src = URL.createObjectURL(file);
	await img.decode();
	return img;
}

function resizeImage(img) {
	let scale = Math.max(img.naturalWidth/MAX, img.naturalWidth/MAX, 1);
	let canvas = document.createElement("canvas");
	canvas.width = Math.round(img.width / scale);
	canvas.height = Math.round(img.height / scale);
	let ctx = canvas.getContext("2d");
	ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
	return canvas.toDataURL("image/jpeg");
}

async function onChange(e) {
	let file = e.target.files[0];
	if (!file) return;

	let sourceImage = await loadImage(file);
	let targetImage = resizeImage(sourceImage);

	fetch("/upload", {
		method: "POST",
		body: targetImage
	});
}

let input = document.querySelector("[type=file]");
input.addEventListener("change", onChange);
```

Přestože vzorové řešení má jen kolem třiceti řádků, obsahuje řadu novinek. Pro snazší pochopení si úlohu rozdělíme na tři menší části: získání obrazových dat z disku uživatele, zmenšení a následné nahrání na server.

### Načtení obrázku

V klientském JavaScriptu nelze přistupovat k libovolným souborům na disku uživatele. Představovalo by to značné bezpečnostní riziko, neboť při návštěvě webové stránky by cizí skript mohl snadno číst naše citlivá data a následně je například posílat na server útočníka. Panuje proto pravidlo, že prohlížeč zpřístupní obsah jen takových souborů, které za tímto účelem uživatel explicitně označil. Možnosti jsou dvě: buď takový soubor uživatel myší přetáhnul z plochy do okna prohlížeče, nebo nějaký soubor vybral prostřednictvím formulářového prvku `<input type=file>`.

Druhá možnost je o něco přímočařejší a také častější, takže ji využijeme pro vzorové řešení. Atributem `accept` omezíme typ použitelných souborů, takže následně nemusíme uvažovat variantu, kdy by uživatel vybral nějaký soubor, který vůbec není obrázek. Po vybrání souboru vznikne událost `change` a tím dojde ke spuštění posluchače `onChange`. Vlastnost `files` HTML prvku `<input>` v takové chvíli obsahuje pole vybraných souborů (víc by jich mohlo být, pokud bychom použili atribut `multiple`). Jedná se o proměnné typu `File` -- s takovým objektem jsem se zatím nesetkali.

Objekt `File` slouží k přístupu k souboru, ale nedovoluje nám přímo získat jeho obsah. S proměnnou tohoto typu můžeme provádět tyto hlavní operace:

1. Můžeme ji předat funkci `fetch` a tím obsah souboru nahrát. To dělat nechceme, protože bychom nahrávali originální obrázek, který může být příliš velký.

1. Můžeme použít objekt `FileReader`, prostřednictvím kterého bychom se dostali k obsahu souboru (jednotlivým bajtům). To vypadá užitečně, ale jedná se o příliš nízkoúrovňový přístup. Museli bychom v JavaScriptu implementovat dekódování obrazového formátu (JPEG, PNG, GIF, &hellip;), což je zbytečně složité a pracné.

1. Protože víme, že vybraný soubor odpovídá obrázku, můžeme jej využít k vytvoření HTML prvku `<img>`. Ten je vhodný pro následné zmenšování.

HTML značka `<img>` ovšem vyžaduje URL, které nemáme. Naštěstí existuje šikovná a nepříliš známá funkce `URL.createObjectURL`, která slouží právě k tomuto účelu. Pro předaný objekt typu `File` vytvoří *falešené* dočasné URL, které můžeme až do zavření stránky používat tam, kde je URL očekáváno. V našem případě ho předáme do atributu `src` nově vytvořeného obrázku.

Ještě než začneme tento obrázek zpracovávat, musíme počkat, než jej prohlížeč načte (teprve potom budou například známy jeho rozměry). Načtení obrázku je asynchronní proces a máme dva způsoby, jak s ním pracovat:

1. Počkáme na událost `load`. To by znamenalo přidání posluchače a zabalení následného kódu do vlastní funkce. Bude to fungovat, ale existuje snazší řešení.

1. Použijeme relativně moderní metodu `decode()`, která taktéž čeká na načtení a vrací Promise. To je pro náš případ ideální.


### Změna rozměrů

Uživatelem vybraný soubor máme nyní načtený v HTML obrázku. Jeho rozměry jsou k dispozici ve vlastnostech `naturalWidth` a `naturalHeight` (mohli bychom se také zajímat o vlastnosti `width` a `height`, ale ty mohou být ovlivněny například pomocí CSS). Můžeme tedy vypočítat správnou cílovou velikost.

K výpočtu si nejprve nachystáme *měřítko*: číselnou hodnotu, která říká, kolikrát je nutné obrázek zmenšit. Protože chceme zachovat původní poměr stran, budeme oba rozměry zmenšovat stejně. Měřítko definujeme tímto vzorcem:

```js
let scale = Math.max(img.naturalWidth/MAX, img.naturalWidth/MAX, 1);
```

První parametr funkce `max` říká, *kolikrát je šířka obrázku větší, než požadovaný limit*. Druhý parametr funguje shodně, jen pro výšku. Z těchto hodnot bereme maximum, neboť v zadání je požadováno takové zmenšení, po kterém budou obě strany menší nebo rovny limitu.

Jednička na konci je malý trik: mohlo by se stát, že by nám uživatel nahrál obrázek, jehož oba rozměry jsou menší než limit. Měřítko by pak bylo menší než jedna a při následné transformaci bychom proto obrázek *zvětšili*. To je zbytečné a nežádoucí, takže pro malé obrázky zvolíme měřítko rovno jedné a tím pádem zůstane jejich původní velikost.

Nové rozměry pak vypočítáme jako ty původní vydělené měřítkem. V tuto chvíli nám již ovšem nestačí HTML obrázky. I kdybychom jim nastavovali menší rozměry, prohlížeč provede zmenšení jen pro potřeby zobrazení. Nahraná obrazová data budou stále v původním rozlišení. Proto musíme začít pracovat s HTML značkou `<canvas>`, která představuje univerzální nástroj pro tvorbu a manipulaci s rastrovými obrazovými daty.

Prvek `<canvas>` (anglické označení pro malířské plátno) sice patří do jazyka HTML, ale pracujeme s ním výhradně pomocí JavaScriptových funkcí a vlastností. A že jich je! Zatím si ukážeme jen úplný základ práce s canvasem, ale v následujících podkapitolách prozkoumáme i další jeho možnosti.

Naše plátno potřebuje především nastavit rozměry. K tomu použijeme výše zmíněný výpočet:

```js
let canvas = document.createElement("canvas");
canvas.width = Math.round(img.width / scale);
canvas.height = Math.round(img.height / scale);
```

Canvas odpovídá obdélníku pixelů, proto je potřeba jeho rozměry nastavovat v celých čísel. Měřítko i výsledek dělení mohou být čísla desetinná, proto je na celé pixely musíme zaokrouhlit.

Funkce, které canvas nabízí, jsou v rámci jeho JS API seskupeny do tzv. *kontextů* -- JavaScriptových objektů, specializovaných pro různé vykreslovací operace. Pro naši úlohu je vhodný kontext nazvaný prostě `"2d"`. Ten dovoluje takové operace, které známe například z programu Malování: tah štětcem, vyplňování plochy, vkládání obrázků a podobně. Čistě teoretickým příkladem dalšího kontextu může být `"webgl"`, což je vysoce specializované rozhraní určené pro vykreslování pomocí akcelerované grafiky prostřednictvím jazyka OpenGL. S takto pokročilými technikami se ovšem v této knize nesetkáme.

Metoda `drawImage` patří dvourozměrnému kontextu a má řadu různých signatur. Prvním parametrem je zdrojový obrázek, další dva parametry definují cílové souřadnice (místo, na kterém v canvasu vykreslíme levý horní roh obrázku) a nejdůležitější jsou poslední dva parametry -- cílové rozměry. Právě díky nim prohlížeč vykreslí původní obrázek do canvasu zmenšený.

Celá tato zmenšovací operace nás stojí jen dva řádky kódu:

```js
let ctx = canvas.getContext("2d");
ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
```


### Nahrání obrázku

Máme skoro hotovo! Zmenšili jsme portrét, jen ho teď nemáme v HTML obrázku, ale v HTML canvasu. A ten nelze sám o sobě vzít a nahrát na server. Mimo jiné proto, že canvas představuje dvourozměrné pole pixelů, ale soubory obsahují obrazová data v nějakém formátu. Musíme proto prohlížeč nejprve požádat, aby obrazová data z canvasu vhodně zakódoval.

Canvas pro tyto účely disponuje dvěma metodami, které dělají v podstatě to samé: `toDataURL` a `toBlob`. Liší se takto:

- Metoda `toBlob` je asynchronní (přijímá callback) a produkuje objekt typu `Blob`, který zastřešuje výsledná binární data. Můžeme jej předat funkci `fetch` a odeslat na server. Tato metoda představuje výkonnější řešení: je úsporná a díky asynchronnosti neblokuje hlavní vlákno.

- Metoda `toDataURL` je synchronní a její návratová hodnota je tzv. *data URI*: řetězec ve tvaru podobném URL, obsahující zakódovaná obrazová data. Můžeme jej použít všude, kde je očekáváno URL (podobně jako výsledek volání `URL.createObjectURL`). Takový řetězec můžeme samozřejmě taktéž nahrát na server. Kromě blokování hlavního vlákna je další nevýhoda metody `toDataURL` v tom, že výsledný řetězec obsahuje jednotlivé bajty zapsané pomocí *kódování Base64*, kdy se používají pouze tištitelné znaky, ale datový objem tím naroste zhruba o třetinu.

Pro jednoduchost ve vzorovém řešení použijeme `toDataURL`. Jejím parametrem je identifikace obrazového formátu, do kterého chceme obrázek zakódovat:

```js
function resizeImage(img) {
	// tvorba canvasu viz výče
	return canvas.toDataURL("image/jpeg");
}

let targetImage = resizeImage(sourceImage);
```

V porovnání s minulými kapitolami potřebujeme na server odeslat značné množství dat. Musíme proto použít HTTP metodu `POST` a data umístit do těla požadavku. V případě funkce `fetch` je to jen otázka konfiguračních parametrů `method` a `body`:

```js
fetch("/upload", {
	method: "POST",
	body: targetImage
});
```

Tím jsme na server poslali data zmenšeného zakódovaného obrázku.


### Co jsme se naučili

Po vyřešení desáté úlohy by měl čtenář chápat a ovládat:

- možnosti přístupu k datům uživatelem vybraného souboru
- využití HTML canvasu pro zmenšení obrázku
- získání obrazových dat z canvasu ve formátu vhodném k odeslání po síti

## Zelenáči: další dovedosti canvasu

HTML značka `<canvas>` je univerzální kreslicí plocha. Ukázali jsme, jak do ní přenést obrázek ze značky `<img>`; nyní přišel čas vyzkoušet další metody, které 2d-kontext nabízí. Abychom nemalovali jen tak nahodile, vyřešíme skutečnou úlohu, ke které lze canvas použít -- ukazatel načítání.

Předpokládejme, že provádíme operaci, která trvá delší dobu. Může jít třeba o nahrávání profilového obrázku, nebo čekání na nějaká data ze serveru. Když se jedná o aktivitu na pozadí, uživatel nemá žádné informace o její existenci, případně průběhu. Bývá proto obyvyklé, že síťovou komunikaci nějakým nenápadným způsobem vizualizujeme. Sestavme animaci, která představuje postupně se zvětšující kruhovou výseč (zelené barvy). Abychom nemuseli vymýšlet, kam takový obrázek umístit, zobrazíme ho v záhlaví záložky prohlížeče vedle titulku stránky -- uděláme z tohoto obrázku tzv. *favikonku*.

Favikonky jsou malé obrázky, které k HTML dokumentu připojujeme pomocí značky `<meta>` v hlavičce stránky. Typicky to vypadá takto:

```html
<meta rel="icon" href="ikonka.png" />
```

Nic nám ale nebrání takovou favikonku vyrobit pomocí JavaScriptu. Jakmile pro ni dokážeme sestavit URL, můžeme jej použít pro změnu atributu `href` u značky `<link>`.

Začneme tím, že si nachystáme malý čtvercový canvas. Pro rozměry vytvoříme konstantu:

```js
const SIZE = 32;
let canvas = document.createElement("canvas");
canvas.width = canvas.height = SIZE;
let ctx = canvas.getContext("2d");
```

Malování obstará funkce, která pomocí metod kontextu `ctx` vytvoří požadovaný útvar. Ta bude muset znát úhel (velikost výseče). Proto si nachystáme kód, který bude v čase úhel měnit a periodicky kreslicí funkci vykonávat:

```js
let angle = 0;
setInterval(() => {
	angle = (angle + 0.1) % (2 * Math.PI);
	draw(angle);
}, 100);
```

V počítačové grafice bývají úhly zpravidla specifikovány pomocí radiánů. V tomto kódu každých 100 milisekund zvětšíme úhel o 0.1 radiánu. Hodnotu ještě upravíme operátorem procenta (zbytek po dělení) tak, aby nikdy nepřesáhla 2π, tj. celý kruh. To znamená, že jakmile vykreslíme kruh, začneme znovu od začátku úzkou výsečí od nuly.

Zbývá naimplementovat kreslení ve funkci `draw`. HTML canvas je zajímavý tím, že jakmile do něj nějaká data vykreslíme, už je zpětně nemůžeme měnit. Animaci tedy realizujeme tak, že canvas nejprve zcela vyprázdníme a pak do něj vykreslíme nový snímek dle aktuálního stavu. Pro vymazání existuje metoda `clearRect`, které předáme souřadnice (a rozměry) obdélníkové oblasti, kterou chceme vymazat. V našem případě je to celý canvas:

```js
function draw(angle) {
	ctx.clearRect(0, 0, SIZE, SIZE);
}
```

Kruhovou výseč vytvoříme pomocí operace, která odpovídá tažení virtuálním štětcem po plátně. Sestává z těchto kroků:

1. posun štětce doprostřed plátna
1. čára doprava
1. kruhový oblouk o délce úměrné požadovanému úhlu
1. čára zpět do středu
1. vyplnění vzniklé oblasti barvou

Náš kontext nabízí metody přesně pro tyto kroky:

```js
ctx.beginPath();
ctx.moveTo(SIZE/2, SIZE/2);
ctx.lineTo(SIZE, SIZE/2);
ctx.arc(SIZE/2, SIZE/2, SIZE/2, 0, angle);
ctx.closePath();
ctx.fillStyle = "green";
ctx.fill();
```

Jediné komplikované místo je metoda `arc`, která vytváří kruhový oblouk. Ten vyžaduje mnoho parametrů: dvě souřadnice středu kruhu, poloměr, počáteční úhel (nula odpovídá bodu na kružnici nejvíc vpravo) a cílový úhel.

Za zmínku ještě stojí nastavení barvy výplně. Stejně jako v programu Malování, i zde provádíme nastavení barvy (vlastnost `fillStyle`) nezávisle na kreslení (metoda `fill`). Ve chvíli vykreslení se pak použije aktuálně nastavená barva. Znamená to, že změnu barvy můžeme provést kdykoliv před vykreslením, ale nikdy až poté.

V tuto chvíli máme v canvasu hotový obrázek. Zbývá z něj vytvořit URL (to umíme z první části této kapitoly) a nastavit jej prvku `<meta>`:

```js
let link = document.head.querySelector("[rel=icon]");
link.href = canvas.toDataURL("image/png");
```

Výsledný kód pak celý vypadá například takto:

```html
<!-- kapitola-11-zelenaci.html -->
<!doctype html>
<html>
	<head><link rel="icon" /></head>
	<script>

let canvas = document.createElement("canvas");
const SIZE = 32;
canvas.width = canvas.height = SIZE;
let ctx = canvas.getContext("2d");


function draw(angle) {
	ctx.clearRect(0, 0, SIZE, SIZE);
	ctx.beginPath();
	ctx.moveTo(SIZE/2, SIZE/2);
	ctx.lineTo(SIZE, SIZE/2);
	ctx.arc(SIZE/2, SIZE/2, SIZE/2, 0, angle);
	ctx.closePath();
	ctx.fillStyle = "green";
	ctx.fill();

	let link = document.head.querySelector("[rel=icon]");
	link.href = canvas.toDataURL("image/png");
}

let angle = 0;
setInterval(() => {
	angle = (angle + 0.1) % (2 * Math.PI);
	draw(angle);
}, 100);

	</script>
</html>
```


## Koumáci: obrazová data z kamery a videa

Zatím jsme ukázali, jak v canvasu vytvářet nový obsah a jak ho z canvasu získat v podobě URL. Prohlížeče nabízí ještě další způsoby, jak do canvasu dostat obrazová data -- ovšem stále prostřednictvím metody `drawImage`, kterou jsme si představili ve vzorovém řešení.

Její první parametr specifikuje zdroj dat. Nemusí jít jen o obrázek; může to být také jiný canvas nebo HTML značka `<video>`. Pokud bychom tedy měli soubor s videem, můžeme jej přehrávat prostřednictvím značky `<video>`, její obsah pravidelně přenášet do canvasu a tam jej dle potřeby zpracovávat. Je to docela snadné:

```html
<video src="video.mp4"></video>
<canvas></canvas>
```

```js
function drawToCanvas() {
	let video = document.querySelector("video");
	let canvas = document.querySelector("canvas");
	canvas.width = video.videoWidth;
	canvas.height = video.videoHeight;

	let ctx = canvas.getContext("2d");
	ctx.drawImage(video, 0, 0);

	requestAnimationFrame(drawToCanvas);
}

drawToCanvas();
```

Pro periodické vykonávání kódu jsme tentokrát zvolili jiný přístup, než `setInterval`. Pokud chceme opakovaně provádět operaci, která něco vykresluje do stránky, je lepší použít funkci `requestAnimationFrame`. U ní neříkáme časový krok (tj. *za jak dlouho má prohlížeč zadaný kód vykonat*) a namísto toho necháváme prohlížeč, aby volil časový krok sám -- s ohledem na aktuální vytížení počítače, snímkovou frekvenci monitoru a další faktory (pokud je například záložka s naším kódem neaktivní, uživatel nic nevidí a prohlížeč může snížit frekvenci vykreslování).

Funkce `requestAnimationFrame` je, podobně jako `setTimeout`, jednorázová. Musíme ji proto zavolat po každém vykreslení (a naplánovat tak zase další krok).

## Profíci: kdy s canvasem narazíme a jak z toho ven

### Tainting

### Antialiasing

### Vysoká hustota pixelů
