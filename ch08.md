# Kapitola 8: Třídy a objekty

## Úloha

Administrační systém z minulé kapitoly se rozrostl a stávající implementace nedovoluje snadné rozšiřování. Rozdělte kód do menších, samostatně funkčních celků. Použijte techniky objektově orientovaného programování.

### Řešení

```html
<!-- kapitola-8.html -->
<h2>Nové komentáře</h2>
<ul id="new"></ul>

<h2>Schválené komentáře</h2>
<ul id="approved"></ul>

<script type="module" src="kapitola-8.js"></script>
```

```js
// kapitola-8.js
import Comment from "./comment.js";

export async function loadComments() {
	let response = await fetch("/comments");
	let data = await response.json();

	let newList = document.querySelector("#new");
	let approvedList = document.querySelector("#approved");
	newList.replaceChildren();
	approvedList.replaceChildren();

	comments.forEach(c => {
		let comment = new Comment(c);
		(c.approved ? approvedList : newList).append(comment.node);
	});
}

loadComments();
```

```js
// comment.js
import { loadComments } from "./kapitola-8.js";

export default class Comment {
	constructor(data) {
		let node = document.createElement("li");
		node.textContent = `${data.author}: ${data.text}`;

		if (!comment.approved) { node.append(this.buildApproveButton()); }
		node.append(this.buildDeleteButton());

		this.id = data.id;
		this.node = node;
	}

	buildApproveButton() {
		let button = buildButton("Schválit");
		button.addEventListener("click", async e => {
			await this.approve();
			loadComments();
		});
		return button;
	}

	buildDeleteButton() {
		let button = buildButton("Smazat");
		button.addEventListener("click", async e => {
			await this.delete();
			loadComments();
		});
		return button;
	}

	delete() {
		return fetch(`/comments/${this.id}`, {method: "DELETE"});
	}

	approve(id) {
		return fetch(`/comments/${this.id}/approve`, {method: "POST"});
	}
}

function buildButton(label) {
	let button = document.createElement("button");
	button.textContent = label;
	return button;
}
```

Kód z minulé kapitoly doznal značných změn, přesto je jeho funkcionalita stejná. Provedli jsme *refactoring*: přepracování kódu za účelem přípravy na další rozšiřování.

### Třídy

O vykreslení komentáře a související interaktivitu se nově stará třída `Comment`. JavaScriptové třídy jsou klasickým mechanismem pro objektově orientované programování, tedy koncept entit, které spolu kombinují správu dat a logiku, která s těmito daty pracuje. Třída je pak jakási šablona, která popisuje, jak budou jednotlivé objekty (těm se říká *instance*) fungovat. Definice a chování tříd v JavaScriptu se blíží jiným tradičním objektově orientovaným jazykům, jako je Java nebo C++.

Syntakticky je definice třídy zabalená do složených závorek a jedná se vlastně jen o výčet jednotlivých metod, kterými budou instance této třídy disponovat. Speciálně pojmenovaná metoda `constructor` bude vykonána vždy při vzniku nové instance, tj. při použití zápisu `new Comment`. Zájemcům o detailnější pochopení toho, *co to vlastně třídy jsou*, je pak určena podkapitola pro profíky.

V metodách tříd se často objevuje důležité klíčové slovo `this`. Pomocí něj můžeme odkazovat na tu instanci třídy, jejíž metoda je právě vykonávána. Snadno tak pro konkrétní komentář zavoláme nějakou jeho metodu (`this.approve()`, `this.delete()`) nebo přistoupíme k jeho vlastnostem (`this.id`). Klíčové slovo `this` je ve skutečnosti výrazně komplikovanější, než se při pohledu na vzorové řešení zdá, a je mu proto věnována podkapitola pro koumáky.


### JS moduly

Druhá novinka je rozdělení JavaScriptu do dvou souborů. To je logický krok ve chvíli, kdy objem kódu přesáhne jistou subjektivní mez. V našem případě se jedná o hlavní soubor `kapitola-8.js` (obsahuje logiku načítání) a dále `comment.js` (obsahuje management komentářů). Aby bylo možné realizovat spolupráci mezi těmito soubory, použijeme koncept JS modulů (poprvné jsme o něm slyšeli ve druhé kapitole, v podkapitole pro profíky). To znamená tyto kroky:

1. V HTML prvku `<script>` přidáme atribut `type="module"`. Tím je soubor `kapitola-8.js` považován za JS modul a jím importované soubory taktéž.
1. Pokud chceme nějakou funcionalitu v JS modulu nabídnout k použití, přidáme před ni klíčové slovo `export`.
1. Pokud chceme v jednom souboru přistoupit k funkcionalitě z jiného, musíme ji nejprve importovat klíčovým slovem `import`.

Pozor! Při používání JS modulů přistupuje prohlížeč striktněji k atributu `src` u HTML prvku `<script>`. Toto URL nově podstupuje kontrolu *originu* (viz pátou kapitolu) a musí používat protokol HTTP, tj. zejména není možné jej načítat pseudo-protokolem `file://`. To je pro rychlý lokální vývoj komplikace, neboť se u JS modulů neobejdeme bez opravdového HTTP serveru, který bude soubory (HTML, JS a další) vydávat. Jakmile tedy začneme JS moduly používat, budeme se muset seznámit s libovolným webovým serverem. Naštěstí je takových velké množství: může to být dedikovaná aplikace (Apache, Nginx), vývojový server vestavěný do různých jazyků (PHP, Python Flask, Node.js) nebo třeba rozšíření do oblíbeného IDE.

JS moduly mohou exportovat libovolné množství *pojmenovaných věcí* (proměnných, funkcí, tříd, &hellip;) a také jeden tzv. *výchozí (default) export*. Rozdíl mezi pojmenovanou a nepojmenovanou věcí je jen v tom, jak se k nim následně přistupuje z jiného souboru. Třída `Comment` je výchozí export (při importu pak uvádíme jen jméno, pod kterým má být výchozí export dostupný v importujícím souboru), funkce `loadComments` je pojmenovaný export (při importu musíme uvést její název ve složených závorkách).

Všimněme si také, že naše dva soubory na sobě navzájem závisí. Soubor `kapitola-8.js` importuje třídu `Comment` z `comment.js` a naopak třída `Comment` volá funkci `loadComments` z `kapitola-8.js`. Takové situaci se říká *kruhová závislost* a může to být známkou nevhodně navržené aplikace. V našem případě to ničemu nevadí, ale i tak pojďme zvážit, jak bychom se mohli kruhové závislosti vyhnout.

Funkce `loadComments` potřebuje znát třídu `Comment`, protože sama o sobě neumí získaná data zpracovat (to je hlavním cílem refactoringu v této kapitole). Taková závislost je tedy v pořádku. Abychom kruhovou závislost rozbili, mohli bychom třídu `Comment` přepracovat tak, aby po změně komentáře nevolala `loadComments` (pak by nemusela importovat nic ze souboru `kapitola-8.js`). Jinými slovy, aby se v rámci posluchačů klikání na tlačítka jen *dalo vědět*, že došlo ke změně komentáře -- a nějaká jiná komponenta by pak rozhodla, že je nutné data znovu načíst.

Jedním možným přístupem by bylo vytvoření *vlastní události*, kterou by třída `Comment` vyvolala po změně komentáře. Tuto událost může zachytit kód v hlavním modulu a zavolat `loadComments`. Takové řešení dobře zapadá do ekosystému DOM událostí, ale pro naše potřeby je možná zbytečně složité. Třída `Comment` může o změně komentáře dát vědět i jednodušším způsobem:

```js
class Comment {
	commentChanged() {}

	buildApproveButton() {
		let button = buildButton("Schválit");
		button.addEventListener("click", async e => {
			await this.approve();
			this.commentChanged();
		});
		return button;
	}
}

let comment = new Comment(data);
comment.commentChanged = loadComments;
```

Proč definice třídy `Comment` vůbec obsahuje prázdnou metodu `commentChanged`? Ze dvou důvodů. Zaprvé tím čtenáři našeho kódu naznačujeme existenci této metody, dále pak prázdnou (ale existující!) metodou vyřešíme situaci, kdy by došlo ke kliknutí na tlačítko, aniž by v instanci někdo vlastnost `commentChange` přepsal na svou vlastní funkci.



### Co jsme se naučili

Po vyřešení sedmé úlohy by měl čtenář chápat a ovládat:

- definici a použití JS tříd
- dělení kódu na JS moduly
- použití klíčových slov `import` a `export`


## Zelenáči: handleEvent a AbortController

S událostmi se setkáváme téměř v každé kapitole. Ve světě objektově orientovaného programování představují jistou výzvu zejména v tom okamžiku, kdy nás *existující posluchač přestal zajímat*, tj. kdy o něj již nestojíme. Ve vzorovém řešení se objevuje třída `Comment`, která poslouchá událost kliknutí na jednotlivých tlačítkách. Během interakce s administračním systémem ovšem instance třídy `Comment` vznikají (zápisem `new Comment`) a zase zanikají (když v důsledku `loadComments` vymažeme staré položky, o paměť se postará garbage collector). Co se děje se všemi těmi posluchači událostí, které již nemohou nastat?

Především je nutné poznat a odlišit situace, kdy posluchač zmizí sám od sebe (prohlížeč jej odebere) a kdy musíme naopak sami metodou `removeEventListener` poslouchání ukončit. Vzorová třída `Comment` představuje vzájemnou provázanost HTML prvku a instance JavaScriptové třídy:

- Dokud existuje HTML prvek `<button>` s posluchačem události, musí existovat i instance `Comment`.
- Dokud existuje JS instance `Comment`, musí existovat i jí odpovídající HTML, dostupné skrz vlastnost `node`.

To znamená, že garbage collector začne pracovat teprve poté, co přestaneme používat instance třídy a zároveň z dokumentu odstraníme relevantní HTML prvky. Instance si nikam neukládáme a při nejbližím zavolání `loadComments` zaniknou i jim odpovídající HTML uzly. Obě provázané entity zmizí, včetně posluchačů událostí. Nemusíme tedy dělat nic.

Komplikovanější situace by nastala, kdyby třída `Comment` použila posluchač události mimo své vlastní HTML. Mohl by to být posluchač na objektu `window` (třeba událost `keydown` odpovídající stisku klávesy, nebo událost `popstate` z šesté kapitoly) či na objektu `document` (třeba událost `paste` při vložení ze schránky). Pak by garbage collector nemohl nikdy uvolnit paměť zabranou instancí `Comment`, přestože by její vlastní HTML ze stránky již dávno zmizelo. Mohla by totiž nastat zmiňovaná událost a v jejím důsledku by se vykonal posluchač instanci náležící. Čím víc komentářů bychom zobrazili, tím víc posluchačů by zůstávalo přidaných.




## Koumáci: klíčové slovo `this`

## Profíci: prototypová dědičnost
