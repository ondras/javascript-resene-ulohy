# Kapitola 8: Třídy a objekty

## Úloha

Administrační systém z minulé kapitoly se rozrostl a stávající implementace nedovoluje snadné rozšiřování. Rozdělte kód do menších, samostatně funkčních celků. Použijte techniky objektově orientovaného programování.

### Řešení

```html
<!-- kapitola-8.html -->
<h2>Nové komentáře</h2>
<ul id="new"></ul>

<h2>Schválené komentáře</h2>
<ul id="approved"></ul>

<script type="module" src="kapitola-8.js"></script>
```

```js
// kapitola-8.js
import Comment from "./comment.js";

export async function loadComments() {
	let response = await fetch("/comments");
	let data = await response.json();

	let newList = document.querySelector("#new");
	let approvedList = document.querySelector("#approved");
	newList.replaceChildren();
	approvedList.replaceChildren();

	comments.forEach(c => {
		let comment = new Comment(c);
		(c.approved ? approvedList : newList).append(comment.node);
	});
}

loadComments();
```

```js
// comment.js
import { loadComments } from "./kapitola-8.js";

export default class Comment {
	constructor(data) {
		let node = document.createElement("li");
		node.textContent = `${data.author}: ${data.text}`;

		if (!comment.approved) { node.append(this.buildApproveButton()); }
		node.append(this.buildDeleteButton());

		this.id = data.id;
		this.node = node;
	}

	buildApproveButton() {
		let button = buildButton("Schválit");
		button.addEventListener("click", async e => {
			await this.approve();
			loadComments();
		});
		return button;
	}

	buildDeleteButton() {
		let button = buildButton("Smazat");
		button.addEventListener("click", async e => {
			await this.delete();
			loadComments();
		});
		return button;
	}

	delete() {
		return fetch(`/comments/${this.id}`, {method: "DELETE"});
	}

	approve(id) {
		return fetch(`/comments/${this.id}/approve`, {method: "POST"});
	}
}

function buildButton(label) {
	let button = document.createElement("button");
	button.textContent = label;
	return button;
}
```

Kód z minulé kapitoly doznal značných změn, přesto je jeho funkcionalita stejná. Provedli jsme *refactoring*: přepracování kódu za účelem přípravy na další rozšiřování.

### Třídy

O vykreslení komentáře a související interaktivitu se nově stará třída `Comment`. JavaScriptové třídy jsou klasickým mechanismem pro objektově orientované programování, tedy koncept entit, které spolu kombinují správu dat a logiku, která s těmito daty pracuje. Třída je pak jakási šablona, která popisuje, jak budou jednotlivé objekty (těm se říká *instance*) fungovat. Definice a chování tříd v JavaScriptu se blíží jiným tradičním objektově orientovaným jazykům, jako je Java nebo C++.

Syntakticky je definice třídy zabalená do složených závorek a jedná se vlastně jen o výčet jednotlivých metod, kterými budou instance této třídy disponovat. Speciálně pojmenovaná metoda `constructor` bude vykonána vždy při vzniku nové instance, tj. při použití zápisu `new Comment`. Zájemcům o detailnější pochopení toho, *co to vlastně třídy jsou*, je pak určena podkapitola pro profíky.

V metodách tříd se často objevuje důležité klíčové slovo `this`. Pomocí něj můžeme odkazovat na tu instanci třídy, jejíž metoda je právě vykonávána. Snadno tak pro konkrétní komentář zavoláme nějakou jeho metodu (`this.approve()`, `this.delete()`) nebo přistoupíme k jeho vlastnostem (`this.id`). Klíčové slovo `this` je ve skutečnosti výrazně komplikovanější, než se při pohledu na vzorové řešení zdá, a je mu proto věnována podkapitola pro koumáky.


### JS moduly

Druhá novinka je rozdělení JavaScriptu do dvou souborů. To je logický krok ve chvíli, kdy objem kódu přesáhne jistou subjektivní mez. V našem případě se jedná o hlavní soubor `kapitola-8.js` (obsahuje logiku načítání) a dále `comment.js` (obsahuje management komentářů). Aby bylo možné realizovat spolupráci mezi těmito soubory, použijeme koncept JS modulů (poprvné jsme o něm slyšeli ve druhé kapitole, v podkapitole pro profíky). To znamená tyto kroky:

1. V HTML prvku `<script>` přidáme atribut `type="module"`. Tím je soubor `kapitola-8.js` považován za JS modul a jím importované soubory taktéž.
1. Pokud chceme nějakou funcionalitu v JS modulu nabídnout k použití, přidáme před ni klíčové slovo `export`.
1. Pokud chceme v jednom souboru přistoupit k funkcionalitě z jiného, musíme ji nejprve importovat klíčovým slovem `import`.

Pozor! Při používání JS modulů přistupuje prohlížeč striktněji k atributu `src` u HTML prvku `<script>`. Toto URL nově podstupuje kontrolu *originu* (viz pátou kapitolu) a musí používat protokol HTTP, tj. zejména není možné jej načítat pseudo-protokolem `file://`. To je pro rychlý lokální vývoj komplikace, neboť se u JS modulů neobejdeme bez opravdového HTTP serveru, který bude soubory (HTML, JS a další) vydávat. Jakmile tedy začneme JS moduly používat, budeme se muset seznámit s libovolným webovým serverem. Naštěstí je takových velké množství: může to být dedikovaná aplikace (Apache, Nginx), vývojový server vestavěný do různých jazyků (PHP, Python Flask, Node.js) nebo třeba rozšíření do oblíbeného IDE.

JS moduly mohou exportovat libovolné množství *pojmenovaných věcí* (proměnných, funkcí, tříd, &hellip;) a také jeden tzv. *výchozí (default) export*. Rozdíl mezi pojmenovanou a nepojmenovanou věcí je jen v tom, jak se k nim následně přistupuje z jiného souboru. Třída `Comment` je výchozí export (při importu pak uvádíme jen jméno, pod kterým má být výchozí export dostupný v importujícím souboru), funkce `loadComments` je pojmenovaný export (při importu musíme uvést její název ve složených závorkách).

Všimněme si také, že naše dva soubory na sobě navzájem závisí. Soubor `kapitola-8.js` importuje třídu `Comment` z `comment.js` a naopak třída `Comment` volá funkci `loadComments` z `kapitola-8.js`. Takové situaci se říká *kruhová závislost* a může to být známkou nevhodně navržené aplikace. V našem případě to ničemu nevadí, ale i tak pojďme zvážit, jak bychom se mohli kruhové závislosti vyhnout.

Funkce `loadComments` potřebuje znát třídu `Comment`, protože sama o sobě neumí získaná data zpracovat (to je hlavním cílem refactoringu v této kapitole). Taková závislost je tedy v pořádku. Abychom kruhovou závislost rozbili, mohli bychom třídu `Comment` přepracovat tak, aby po změně komentáře nevolala `loadComments` (pak by nemusela importovat nic ze souboru `kapitola-8.js`). Jinými slovy, aby se v rámci posluchačů klikání na tlačítka jen *dalo vědět*, že došlo ke změně komentáře -- a nějaká jiná komponenta by pak rozhodla, že je nutné data znovu načíst.

Jedním možným přístupem by bylo vytvoření *vlastní události*, kterou by třída `Comment` vyvolala po změně komentáře. Tuto událost může zachytit kód v hlavním modulu a zavolat `loadComments`. Takové řešení dobře zapadá do ekosystému DOM událostí, ale pro naše potřeby je možná zbytečně složité. Třída `Comment` může o změně komentáře dát vědět i jednodušším způsobem:

```js
class Comment {
	commentChanged() {}

	buildApproveButton() {
		let button = buildButton("Schválit");
		button.addEventListener("click", async e => {
			await this.approve();
			this.commentChanged();
		});
		return button;
	}
}

let comment = new Comment(data);
comment.commentChanged = loadComments;
```

Proč definice třídy `Comment` vůbec obsahuje prázdnou metodu `commentChanged`? Ze dvou důvodů. Zaprvé tím čtenáři našeho kódu naznačujeme existenci této metody, dále pak prázdnou (ale existující!) metodou vyřešíme situaci, kdy by došlo ke kliknutí na tlačítko, aniž by v instanci někdo vlastnost `commentChange` přepsal na svou vlastní funkci.



### Co jsme se naučili

Po vyřešení sedmé úlohy by měl čtenář chápat a ovládat:

- definici a použití JS tříd
- dělení kódu na JS moduly
- použití klíčových slov `import` a `export`


## Zelenáči: odebírání posluchačů událostí

S událostmi se setkáváme téměř v každé kapitole. Ve světě objektově orientovaného programování představují jistou výzvu zejména v tom okamžiku, kdy nás *existující posluchač přestal zajímat*, tj. kdy o něj již nestojíme. Ve vzorovém řešení se objevuje třída `Comment`, která poslouchá událost kliknutí na jednotlivých tlačítkách. Během interakce s administračním systémem ovšem instance třídy `Comment` vznikají (zápisem `new Comment`) a zase zanikají (když v důsledku `loadComments` vymažeme staré položky, o paměť se postará garbage collector). Co se děje se všemi těmi posluchači událostí, které již nemohou nastat?

Především je nutné poznat a odlišit situace, kdy posluchač zmizí sám od sebe (prohlížeč jej odebere) a kdy musíme naopak sami metodou `removeEventListener` poslouchání ukončit. Vzorová třída `Comment` představuje vzájemnou provázanost HTML prvku a instance JavaScriptové třídy:

- Dokud existuje HTML prvek `<button>` s posluchačem události, musí existovat i instance `Comment`.
- Dokud existuje JS instance `Comment`, musí existovat i jí odpovídající HTML, dostupné skrz vlastnost `node`.

To znamená, že garbage collector začne pracovat teprve poté, co přestaneme používat instance třídy a zároveň z dokumentu odstraníme relevantní HTML prvky. Instance si nikam neukládáme a při nejbližím zavolání `loadComments` zaniknou i jim odpovídající HTML uzly. Obě provázané entity zmizí, včetně posluchačů událostí. Nemusíme tedy dělat nic.

Komplikovanější situace by nastala, kdyby třída `Comment` použila posluchač události mimo své vlastní HTML. Mohl by to být posluchač na objektu `window` (třeba událost `keydown` odpovídající stisku klávesy, nebo událost `popstate` z šesté kapitoly) či na objektu `document` (třeba událost `paste` při vložení ze schránky). Pak by garbage collector nemohl nikdy uvolnit paměť zabranou instancí `Comment`, přestože by její vlastní HTML ze stránky již dávno zmizelo. Mohla by totiž nastat zmiňovaná událost a v jejím důsledku by se vykonal posluchač instanci náležící. Čím víc komentářů bychom zobrazili, tím víc posluchačů by zůstávalo přidaných.

To je samozřejmě nešikovné, hned ze dvou důvodů. Jednak proto, že při vzniku události dojde k vykonání dávno neužitečných posluchačů, a poté proto, že tím dochází k nárůstu zabrané paměti, kterou bychom rádi uvolnili pro užitečnější účely. Tomuto jevu se říká *memory leak* a chceme se mu rozhodně vyhnout. Budeme proto muset naše instance ve vhodnou chvíli upozornit, aby své posluchače odebraly.

Pokud je posluchač pojmenovaná funkce, můžeme jej odebrat metodou `removeEventListener`:

```js
function onClick(e) { ... }

document.addEventListener("click", onClick);
// a později:
document.removeEventListener("click", onClick);
```

V případě objektů ale posluchače většinou vypadají jinak -- jako malé anonymní arrow funkce, které následně volají další metody objektu. Třeba takto:

```js
class Comment {
	constructor() {
		document.addEventListener("click", e => this.remove());
		// tak to fungovat nebude:
		document.removeEventListener("click", e => this.remove());
	}
}
```

Proč výše uvedený kód nebude fungovat? Neboť pro úspěšné odebrání posluchače musíme metodě `removeEventListener` předat tu samou funkci, kterou jsme dříve použili pro `addEventListener`. Naše dvě malé arrow funkce sice *dělají to samé*, ale jsou to dvě různé funkce (nerovnají se). Pojďme se proto podívat na dvě další možnosti, jak posluchače událostí odebrat.

### Metoda `handleEvent`

Navykli jsme si, že druhý parametr pro `addEventListener` je funkce. To ovšem není jediná možnost: může to být také objekt, který má vlastnost `handleEvent`. Tato vlastnost je, pakliže se jedná o funkci, volána při vzniku události. Pokud bychom tedy třídě `Comment` takovou vlastnost přidali, stala by se třída jako taková posluchačem. Kód by mohl vypadat takto:

```js
class Comment {
	buildApproveButton() {
		let button = buildButton("Schválit");
		button.dataset.action = "approve";
		button.addEventListener("click", this);
		return button;
	}

	buildDeleteButton() {
		let button = buildButton("Smazat");
		button.dataset.action = "delete";
		button.addEventListener("click", this);
		return button;
	}

	async handleEvent(e) {
		let actionNode = e.target.closest("[data-action]");
		switch (actionNode.dataset.action) {
			case "delete":
				await this.delete();
				loadComments();
			break;

			case "approve":
				await this.approve();
				loadComments();
			break;
		}
	}
}
```

Hodí se nám zde technika delegování událostí, protože metoda `handleEvent` se nyní věnuje všem (oběma) interakcím, které mohou nastat. Potřebujeme v ní proto odlišit, na co bylo kliknuto, tj. co se má v rámci události vykonat.

V tuto chvíli je pak snadné posluchače odebrat. Druhý parametr známe (je to instance `Comment`, tj. `this`) a potřebujeme jen znát tlačítka, na které jsme posluchač přidali. Mohli bychom tedy třídě `Comment` přidat *ukončovací* metodu, která posluchače odebere:

```js
class Comment {
	destroy() {
		let buttons = this.node.querySelectorAll("button[data-action]");
		Array.from(buttons).forEach(button => button.removeEventListener("click", this));
	}
}
```

Zvídavý čtenář jistě chápe, že tuto metodu je nutné někdy zavolat. Za domácí úkol si proto může zkusit upravit funkci `loadComments` tak, aby si vytvořené instance pamatovala a při dalším volání ty předchozí nejprve *zničila* voláním metody `destroy()`.


### Objekt `AbortController`

Velmi odlišný přístup k odebírání posluchačů představuje využití relativně nového objektu `AbortController`. Můžeme si jej představit jako krabičku s velkým červeným tlačítkem: jeho stisk slouží k přerušení některých operací. Typicky jej používáme k přerušení HTTP požadavků a nebo právě posluchačů událostí.

Při práci s objektem `AbortController` pak posluchače neodebíráme metodou `removeEventListener`, ale pomyslným stiskem onoho tlačítka. Tím lze přerušit celou řadu aktivit či poslucačů -- všechny, které jsme předtím k tlačítku připojili.

V praxi to můžeme zkusit třeba takto:

```js
class Comment {
	constructor() {
		this.abortController = new AbortController();
	}

	buildApproveButton() {
		let signal = this.abortController.signal;

		let button = buildButton("Schválit");
		button.addEventListener("click", async e => {
			await this.approve();
			loadComments();
		}, {signal});
		return button;
	}

	destroy() {
		this.abortController.abort();
	}
}
```

Instance `abortController` je naše červené tlačítko; jeho vlastnost `signal` je pak ten neviditelný drát, kterým je spojeno s jedním či více posluchači. K tomu jsme metodě `addEventListener` museli přidat třetí parametr. Je jím konfigurační objekt (už jsme o něm slyšeli v minulé kapitole, v podkapitole o zachytávání událostí).

V ukázce výše jsme použili šikovnou syntaktickou zkratku, která mohla důkladné čtenáře zmást. Jedná se o zápis `{signal}`. Jde se o běžnou tvorbu objektu, ve kterém definujeme klíč se stejným názvem a hodnotou, jako je uvedená proměnná. Pokud často tvoříme takové slovníky, můžeme vhodně pojmenovanými proměnnými ušetřit místo:

```js
let age = 42;
let name = "Jiří";
let person = {age, name};
// stejné jako {age:age, name:name}
```

Použití `AbortController` je velmi výhodné tam, kde chceme naráz odebrat více posluchačů. Nemusíme si totiž nikde pamatovat ani předané posluchače (funkce či objekt s metodou `handleEvent`), ani HTML prvky, na které jsme je přidali (tlačítka). Stačí mít jen po ruce instanci `AbortController` a zavolat její metodu `abort()`.

## Koumáci: klíčové slovo `this`

## Profíci: prototypová dědičnost
