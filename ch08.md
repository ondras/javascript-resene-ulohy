# Kapitola 8: Třídy a objekty

## Úloha

Administrační systém z minulé kapitoly se rozrostl a stávající implementace nedovoluje snadné rozšiřování. Rozdělte kód do menších, samostatně funkčních celků. Použijte techniky objektově orientovaného programování.

### Řešení

```html
<!-- kapitola-8.html -->
<h2>Nové komentáře</h2>
<ul id="new"></ul>

<h2>Schválené komentáře</h2>
<ul id="approved"></ul>

<script type="module" src="kapitola-8.js"></script>
```

```js
// kapitola-8.js
import Comment from "./comment.js";

export async function loadComments() {
	let response = await fetch("/comments");
	let data = await response.json();

	let newList = document.querySelector("#new");
	let approvedList = document.querySelector("#approved");
	newList.replaceChildren();
	approvedList.replaceChildren();

	comments.forEach(c => new Comment(c, newList, approvedList));
}

loadComments();
```

```js
// comment.js
import { loadComments } from "./kapitola-8.js";

export default class Comment {
	constructor(data, newList, approvedList) {
		this.id = data.id;

		let node = document.createElement("li");
		node.textContent = `${data.author}: ${data.text}`;

		if (!comment.approved) { node.append(this.buildApproveButton()); }
		node.append(this.buildDeleteButton());

		(data.approved ? approvedList : newList).append(node);
	}

	buildApproveButton() {
		let button = buildButton("Schválit");
		button.addEventListener("click", async e => {
			await this.approve();
			loadComments();
		});
		return button;
	}

	buildDeleteButton() {
		let button = buildButton("Smazat");
		button.addEventListener("click", async e => {
			await this.delete();
			loadComments();
		});
		return button;
	}

	delete() {
		return fetch(`/comments/${this.id}`, {method: "DELETE"});
	}

	approve(id) {
		return fetch(`/comments/${this.id}/approve`, {method: "POST"});
	}
}

function buildButton(label) {
	let button = document.createElement("button");
	button.textContent = label;
	return button;
}
```

Kód z minulé kapitoly doznal značných změn, přesto je jeho funkcionalita stejná. Provedli jsme *refactoring*: přepracování kódu za účelem přípravy na další rozšiřování.

### Třídy

O vykreslení komentáře a související interaktivitu se nově stará třída `Comment`. JavaScriptové třídy jsou klasickým mechanismem pro objektově orientované programování, tedy koncept entit, které spolu kombinují správu dat a logiku, která s těmito daty pracuje. Třída je pak jakási šablona, která popisuje, jak budou jednotlivé objekty (těm se říká *instance*) fungovat. Definice a chování tříd v JavaScriptu se blíží jiným tradičním objektově orientovaným jazykům, jako je Java nebo C++.

Syntakticky je definice třídy zabalená do složených závorek a jedná se vlastně jen o výčet jednotlivých metod, kterými budou instance této třídy disponovat. Speciálně pojmenovaná metoda `constructor` bude vykonána vždy při vzniku nové instance, tj. při použití zápisu `new Comment`. Zájemcům o detailnější pochopení toho, *co to vlastně třídy jsou*, je pak určena podkapitola pro profíky.

V metodách tříd se často objevuje důležité klíčové slovo `this`. Pomocí něj můžeme odkazovat na tu instanci třídy, jejíž metoda je právě vykonávána. Snadno tak pro konkrétní komentář zavoláme nějakou jeho metodu (`this.approve()`, `this.delete()`) nebo přistoupíme k jeho vlastnostem (`this.id`). Klíčové slovo `this` je ve skutečnosti výrazně komplikovanější, než se při pohledu na vzorové řešení zdá, a je mu proto věnována podkapitola pro koumáky.


### JS moduly

Druhá novinka je rozdělení JavaScriptu do dvou souborů. To je logický krok ve chvíli, kdy objem kódu přesáhne jistou subjektivní mez. V našem případě se jedná o hlavní soubor `kapitola-8.js` (obsahuje logiku načítání) a dále `comment.js` (obsahuje management komentářů). Aby bylo možné realizovat spolupráci mezi těmito soubory, použijeme koncept JS modulů (poprvné jsme o něm slyšeli ve druhé kapitole, v podkapitole pro profíky). To znamená tyto kroky:

1. V HTML prvku `<script>` přidáme atribut `type="module"`. Tím je soubor `kapitola-8.js` považován za JS modul a jím importované soubory taktéž.
1. Pokud chceme nějakou funcionalitu v JS modulu nabídnout k použití, přidáme před ni klíčové slovo `export`.
1. Pokud chceme v jednom souboru přistoupit k funkcionalitě z jiného, musíme ji nejprve importovat klíčovým slovem `import`.

JS moduly mohou exportovat libovolné množství *pojmenovaných věcí* (proměnných, funkcí, tříd, &hellip;) a také jeden tzv. *výchozí (default) export*. Rozdíl mezi pojmenovanou a nepojmenovanou věcí je jen v tom, jak se k nim následně přistupuje z jiného souboru. Třída `Comment` je výchozí export (při importu pak uvádíme jen jméno, pod kterým má být výchozí export dostupný v importujícím souboru), funkce `loadComments` je pojmenovaný export (při importu musíme uvést její název ve složených závorkách).

Všimněme si také, že naše dva soubory na sobě navzájem závisí. Soubor `kapitola-8.js` importuje třídu `Comment` z `comment.js` a naopak třída `Comment` volá funkci `loadComments` z `kapitola-8.js`. Takové situaci se říká *kruhová závislost* a může to být známkou nevhodně navržené aplikace. V našem případě to ničemu nevadí, ale i tak pojďme zvážit, jak bychom se mohli kruhové závislosti vyhnout.

Funkce `loadComments` potřebuje znát třídu `Comment`, protože sama o sobě neumí získaná data zpracovat (to je hlavním cílem refactoringu v této kapitole). Taková závislost je tedy v pořádku. Abychom kruhovou závislost rozbili, mohli bychom třídu `Comment` přepracovat tak, aby po změně komentáře nevolala `loadComments` (pak by nemusela importovat nic ze souboru `kapitola-8.js`). Jinými slovy, aby se v rámci posluchačů klikání na tlačítka jen *dalo vědět*, že došlo ke změně komentáře -- a nějaká jiná komponenta by pak rozhodla, že je nutné data znovu načíst.

Jedním možným přístupem by bylo vytvoření *vlastní události*, kterou by třída `Comment` vyvolala po změně komentáře. Tuto událost může zachytit kód v hlavním modulu a zavolat `loadComments`. Takové řešení dobře zapadá do ekosystému DOM událostí, ale pro naše potřeby je možná zbytečně složité. Třída `Comment` může o změně komentáře dát vědět i jednodušším způsobem:

```js
class Comment {
	commentChanged() {}

	buildApproveButton() {
		let button = buildButton("Schválit");
		button.addEventListener("click", async e => {
			await this.approve();
			this.commentChanged();
		});
		return button;
	}
}

let comment = new Comment(data);
comment.commentChanged = loadComments;
```

Proč definice třídy `Comment` vůbec obsahuje prázdnou metodu `commentChanged`? Ze dvou důvodů. Zaprvé tím čtenáři našeho kódu naznačujeme existenci této metody, dále pak prázdnou (ale existující!) metodou vyřešíme situaci, kdy by došlo ke kliknutí na tlačítko, aniž by v instanci někdo vlastnost `commentChange` přepsal na svou vlastní funkci.


### Co jsme se naučili

Po vyřešení sedmé úlohy by měl čtenář chápat a ovládat:

- definici a použití JS tříd
- dělení kódu na JS moduly
- použití klíčových slov `import` a `export`


## Zelenáči: handleEvent a AbortController

## Koumáci: klíčové slovo `this`

## Profíci: prototypová dědičnost
