<!DOCTYPE html>
<html lang="cs">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="RNDr. Ondřej Žára" />
  <title>JavaScript: řešené úlohy</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
    /* CSS for syntax highlighting */
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
      }
    pre.numberSource { margin-left: 3em;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { font-weight: bold; } /* Alert */
    code span.an { font-style: italic; } /* Annotation */
    code span.cf { font-weight: bold; } /* ControlFlow */
    code span.co { font-style: italic; } /* Comment */
    code span.cv { font-style: italic; } /* CommentVar */
    code span.do { font-style: italic; } /* Documentation */
    code span.dt { } /* DataType */
    code span.er { font-weight: bold; } /* Error */
    code span.in { font-style: italic; } /* Information */
    code span.kw { font-weight: bold; } /* Keyword */
    code span.pp { font-weight: bold; } /* Preprocessor */
    code span.wa { font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="../css/style.css" />
</head>
<body>
<header id="title-block-header">
<h1 class="title">JavaScript: řešené úlohy</h1>
<p class="author">RNDr. Ondřej Žára</p>
</header>
<nav id="TOC" role="doc-toc">
<h2 id="toc-title">Obsah</h2>
<ul>
<li><a href="#úvod" id="toc-úvod">Úvod</a>
<ul>
<li><a href="#jak-pracovat-s-knihou" id="toc-jak-pracovat-s-knihou">Jak
pracovat s knihou</a></li>
<li><a href="#pět-minut-dějepisu" id="toc-pět-minut-dějepisu">Pět minut
dějepisu</a></li>
<li><a href="#co-by-měl-čtenář-vědět" id="toc-co-by-měl-čtenář-vědět">Co
by měl čtenář vědět</a></li>
<li><a href="#středníky-v-javascriptu"
id="toc-středníky-v-javascriptu">Středníky v JavaScriptu</a></li>
<li><a href="#ladění" id="toc-ladění">Ladění</a></li>
<li><a href="#další-čtení" id="toc-další-čtení">Další čtení</a></li>
<li><a href="#materiály-online" id="toc-materiály-online">Materiály
online</a></li>
</ul></li>
<li><a href="#první-setkání" id="toc-první-setkání">První setkání</a>
<ul>
<li><a href="#úloha" id="toc-úloha">Úloha</a></li>
<li><a href="#zelenáči-drobná-vylepšení"
id="toc-zelenáči-drobná-vylepšení">Zelenáči: drobná vylepšení</a></li>
<li><a href="#koumáci-průzkum-stromu-domu"
id="toc-koumáci-průzkum-stromu-domu">Koumáci: průzkum stromu
DOMu</a></li>
<li><a href="#profíci-druhy-skriptů"
id="toc-profíci-druhy-skriptů">Profíci: druhy skriptů</a></li>
</ul></li>
<li><a href="#pole-a-iterace" id="toc-pole-a-iterace">Pole a iterace</a>
<ul>
<li><a href="#úloha-1" id="toc-úloha-1">Úloha</a></li>
<li><a href="#zelenáči-anonymní-a-arrow-funkce"
id="toc-zelenáči-anonymní-a-arrow-funkce">Zelenáči: anonymní a arrow
funkce</a></li>
<li><a href="#koumáci-druhy-iterací"
id="toc-koumáci-druhy-iterací">Koumáci: druhy iterací</a></li>
<li><a href="#profíci-scope-a-closure"
id="toc-profíci-scope-a-closure">Profíci: scope a closure</a></li>
</ul></li>
<li><a href="#kontrola-formuláře" id="toc-kontrola-formuláře">Kontrola
formuláře</a>
<ul>
<li><a href="#úloha-2" id="toc-úloha-2">Úloha</a></li>
<li><a href="#zelenáči-další-druhy-událostí"
id="toc-zelenáči-další-druhy-událostí">Zelenáči: další druhy
událostí</a></li>
<li><a href="#koumáci-výjimky" id="toc-koumáci-výjimky">Koumáci:
výjimky</a></li>
<li><a href="#profíci-zpožděná-kontrola-při-psaní"
id="toc-profíci-zpožděná-kontrola-při-psaní">Profíci: zpožděná kontrola
při psaní</a></li>
</ul></li>
<li><a href="#http-na-pozadí" id="toc-http-na-pozadí">HTTP na pozadí</a>
<ul>
<li><a href="#úloha-3" id="toc-úloha-3">Úloha</a></li>
<li><a href="#zelenáči-řízení-toku-kódu-pomocí-operátorů"
id="toc-zelenáči-řízení-toku-kódu-pomocí-operátorů">Zelenáči: řízení
toku kódu pomocí operátorů</a></li>
<li><a
href="#koumáci-falsy-values-a-operátory-s-implicitním-přetypováním"
id="toc-koumáci-falsy-values-a-operátory-s-implicitním-přetypováním">Koumáci:
<em>falsy values</em> a operátory s implicitním přetypováním</a></li>
<li><a href="#profíci-same-origin-policy-a-cors"
id="toc-profíci-same-origin-policy-a-cors">Profíci: <em>same-origin
policy</em> a CORS</a></li>
</ul></li>
<li><a href="#cesta-k-spa-riziko-xss"
id="toc-cesta-k-spa-riziko-xss">Cesta k SPA, riziko XSS</a>
<ul>
<li><a href="#úloha-4" id="toc-úloha-4">Úloha</a></li>
<li><a href="#zelenáči-práce-s-adresním-řádkem"
id="toc-zelenáči-práce-s-adresním-řádkem">Zelenáči: práce s adresním
řádkem</a></li>
<li><a href="#koumáci-funkcionální-iterace"
id="toc-koumáci-funkcionální-iterace">Koumáci: funkcionální
iterace</a></li>
<li><a href="#profíci-fetch-promises-a-asyncawait"
id="toc-profíci-fetch-promises-a-asyncawait">Profíci: fetch, Promises
a async/await</a></li>
</ul></li>
<li><a href="#spa-administrační-systém"
id="toc-spa-administrační-systém">SPA administrační systém</a>
<ul>
<li><a href="#úloha-5" id="toc-úloha-5">Úloha</a></li>
<li><a href="#zelenáči-event-delegation"
id="toc-zelenáči-event-delegation">Zelenáči: event delegation</a></li>
<li><a href="#koumáci-bublání-a-zachytávání"
id="toc-koumáci-bublání-a-zachytávání">Koumáci: bublání
a zachytávání</a></li>
<li><a href="#profíci-o-řetězcích-a-číslech"
id="toc-profíci-o-řetězcích-a-číslech">Profíci: o řetězcích
a číslech</a></li>
</ul></li>
<li><a href="#třídy-a-objekty" id="toc-třídy-a-objekty">Třídy
a objekty</a>
<ul>
<li><a href="#úloha-6" id="toc-úloha-6">Úloha</a></li>
<li><a href="#zelenáči-odebírání-posluchačů-událostí"
id="toc-zelenáči-odebírání-posluchačů-událostí">Zelenáči: odebírání
posluchačů událostí</a></li>
<li><a href="#koumáci-klíčové-slovo-this"
id="toc-koumáci-klíčové-slovo-this">Koumáci: klíčové slovo this</a></li>
<li><a href="#profíci-prototypová-dědičnost"
id="toc-profíci-prototypová-dědičnost">Profíci: prototypová
dědičnost</a></li>
</ul></li>
<li><a href="#web-components" id="toc-web-components">Web Components</a>
<ul>
<li><a href="#úloha-7" id="toc-úloha-7">Úloha</a></li>
<li><a href="#zelenáči-gettery-a-settery"
id="toc-zelenáči-gettery-a-settery">Zelenáči: gettery a settery</a></li>
<li><a href="#koumáci-předávání-hodnotou-a-odkazem"
id="toc-koumáci-předávání-hodnotou-a-odkazem">Koumáci: předávání
hodnotou a odkazem</a></li>
<li><a href="#profíci-vlastní-události"
id="toc-profíci-vlastní-události">Profíci: vlastní události</a></li>
</ul></li>
<li><a href="#intl-storage-polyfilly-a-další-api"
id="toc-intl-storage-polyfilly-a-další-api">Intl, Storage, polyfilly
a další API</a>
<ul>
<li><a href="#úloha-8" id="toc-úloha-8">Úloha</a></li>
<li><a href="#zelenáči-web-storage"
id="toc-zelenáči-web-storage">Zelenáči: Web Storage</a></li>
<li><a href="#koumáci-polyfilly" id="toc-koumáci-polyfilly">Koumáci:
Polyfilly</a></li>
<li><a href="#profíci-další-api" id="toc-profíci-další-api">Profíci:
další API</a></li>
</ul></li>
<li><a href="#html-canvas" id="toc-html-canvas">HTML Canvas</a>
<ul>
<li><a href="#úloha-9" id="toc-úloha-9">Úloha</a></li>
<li><a href="#zelenáči-další-dovednosti-canvasu"
id="toc-zelenáči-další-dovednosti-canvasu">Zelenáči: další dovednosti
canvasu</a></li>
<li><a href="#koumáci-obrazová-data-z-kamery-a-videa"
id="toc-koumáci-obrazová-data-z-kamery-a-videa">Koumáci: obrazová data
z kamery a videa</a></li>
<li><a href="#profíci-kdy-s-canvasem-narazíme-a-jak-z-toho-ven"
id="toc-profíci-kdy-s-canvasem-narazíme-a-jak-z-toho-ven">Profíci: kdy
s canvasem narazíme a jak z toho ven</a></li>
</ul></li>
<li><a href="#javascript-mimo-prohlížeč"
id="toc-javascript-mimo-prohlížeč">JavaScript mimo prohlížeč</a>
<ul>
<li><a href="#úloha-10" id="toc-úloha-10">Úloha</a></li>
<li><a href="#zelenáči-npm" id="toc-zelenáči-npm">Zelenáči: npm</a></li>
<li><a href="#koumáci-tooling" id="toc-koumáci-tooling">Koumáci:
tooling</a></li>
<li><a href="#profíci-alternativy-k-node.js"
id="toc-profíci-alternativy-k-node.js">Profíci: alternativy
k Node.js</a></li>
</ul></li>
<li><a href="#když-javascript-nestačí"
id="toc-když-javascript-nestačí">Když JavaScript nestačí</a>
<ul>
<li><a href="#zelenáči-react" id="toc-zelenáči-react">Zelenáči:
React</a></li>
<li><a href="#koumáci-typescript" id="toc-koumáci-typescript">Koumáci:
TypeScript</a></li>
<li><a href="#profíci-webassembly" id="toc-profíci-webassembly">Profíci:
WebAssembly</a></li>
</ul></li>
<li><a href="#co-se-nevešlo" id="toc-co-se-nevešlo">Co se nevešlo</a>
<ul>
<li><a href="#zelenáči-svg" id="toc-zelenáči-svg">Zelenáči: SVG</a></li>
<li><a href="#koumáci-striktní-režim"
id="toc-koumáci-striktní-režim">Koumáci: striktní režim</a></li>
<li><a href="#profíci-iterační-protokol"
id="toc-profíci-iterační-protokol">Profíci: iterační protokol</a></li>
</ul></li>
</ul>
</nav>
<h1 id="úvod">Úvod</h1>
<p>Jen těžko se lze pohybovat v oblasti tvorby webu a nepovšimnout si,
jak značnému zájmu se JavaScript těší. Spolu s oblíbeností
a rozšířeností logicky roste také poptávka po kvalifikovaných
vývojářích. Najít zkušeného JavaScriptového programátora přitom vůbec
není jednoduché; základy si na Internetu najde každý, ale skutečně
hlubokého pochopení dojde jen málokdo. Je k tomu zapotřebí mnoho praxe,
zvídavosti i obecného algoritmického rozhledu.</p>
<p>Na oblíbeném programátorském webu stackoverflow.com je položeno přes
dva a půl milionu otázek na téma JavaScript. To je dobrým dokladem zájmu
i nedostatečného vzdělání mezi webovými vývojáři. Ambicí této knihy je
poskytnout podklady pro systematické pochopení JavaScriptu a jeho
praktického používání.</p>
<p>Konkrétní programátorské nástroje, postupy a knihovny přicházejí
a s různorodým odstupem zase mizí. Základní koncepty a jazyky WWW však
zůstávají a postupným vylepšováním upevňují web na předním místě
každodenních životních činností. Práce s HTML stránkami, jejich design
a postupné oživování pomocí skriptů je tak více a více považováno za
základní IT vzdělání; mnoho vývojářů se s prvními algoritmy a jazyky
potká právě v rámci tvorby webu.</p>
<p>S rostoucí nabídkou webových technologií je na místě dodávat
i užitečné studijní podklady. Zde přichází ke slovu tato kniha:
poskytuje krátký exkurz do světa pod pokličkou HTML stránek, ukazuje
principy vývoje a seznamuje s typickými postupy. Na své by si tak měli
přijít jak začátečníci, tak i zkušenější vývojáři z ostatních oborů,
kteří by rádi obhlédli, jak že se to pracuje s tím HTML a především
JavaScriptem.</p>
<h2 id="jak-pracovat-s-knihou">Jak pracovat s knihou</h2>
<p>S výjimkou této jsou všechny kapitoly v knize postaveny stejným
způsobem: každá se točí okolo jedné konkrétní úlohy, která je zmíněna
vždy v úvodu kapitoly. Následuje vzorové řešení a jeho krátký rozbor.
Úloha je volena tak, aby připomínala opravdové zadání, se kterým se
můžeme v praxi setkat. Zároveň s postupem času roste obtížnost úloh,
abychom se mohli seznamovat s dalšími vlastnostmi jazyka.</p>
<p>V každé kapitole pak následuje trojice podkapitol, které využívají
řešenou úlohu jako místo pro vysvětlení dalších konceptů JavaScriptu.
Tyto podkapitoly jsou seřazeny dle obtížnosti a obdobným způsobem
pojmenovány:</p>
<ul>
<li><p>Každá první podkapitola je určena pro <strong>zelenáče</strong>.
Pozor, nenechme se takovým označením zmást, ani urazit! Jde prostě o ty,
kteří s JavaScriptem začínají a teprve se rozkoukávají. Podkapitoly pro
zelenáče představují základní vlastnosti JavaScriptu a zpravidla se
v nich naučíme různé formy vylepšení vzorového řešení úlohy.</p></li>
<li><p>Každá druhá podkapitola je určena pro <strong>koumáky</strong>.
Je v ní prostor pro obecnější vysvětlení probíraných témat. Namísto
použití JavaScriptu (jen) pro splnění konkrétního zadání se koumáci
seznámí i s alternativami a pokročilejšími koncepty. Tyto podkapitoly
pomůžou rozšířit obzory těm, kterým přijde vzorové řešení přímočaré
a chtěli by vědět více.</p></li>
<li><p>Každá třetí podkapitola je určena pro <strong>profíky</strong>.
Probíráme v ní ty rysy jazyka, které jsou buď komplikované, nebo se
s nimi nesetkáváme moc často. Profíci se v těchto podkapitolách mohou
seznámit s tématy, o kterých mají frontendoví vývojáři často jen neúplné
znalosti, případně se jich intuitivně straní a buď je ignorují, nebo je
obchází používáním knihovního kódu.</p></li>
</ul>
<p>Cílem knihy je nabídnout užitečný obsah všem zájemcům o JavaScript.
Projděte si prvních pár kapitol a <em>nakalibrujte se</em> na jednoho ze
tří vzorových čtenářů – podle toho pak můžete dalším podkapitolám
věnovat větší pozornost, nebo je jen v rychlosti prolétnout
a přeskočit.</p>
<h2 id="pět-minut-dějepisu">Pět minut dějepisu</h2>
<p>Historie programovacího jazyka možná nepatří mezi nejzábavnější části
knihy, ale může přinést užitečný kontext k informacím, které se dozvíme
v dalších kapitolách. JavaScript navíc v průběhu života dostával různé
názvy a zkratky, se kterými se v rámci tohoto dějepisného rychlokurzu
seznámíme.</p>
<p>Archeologičtí nadšenci se mohou detailnější informace dozvědět mimo
jiné na stránce <a
href="https://en.wikipedia.org/wiki/JavaScript#History">https://en.wikipedia.org/wiki/JavaScript#History</a>
– tato podkapitola je zkrácenou kombinací textů z několika zdrojů,
zejména však toho odkazovaného. Pojďme si nyní představit klíčové body
v historii JavaScriptu.</p>
<ul>
<li><p>První verze jazyka JavaScript byla navržena a naimplementována
během pouhých deseti dní (!) Brendanem Eichem ve společnosti Netscape.
Psal se rok 1995 (mimo jiné též rok vzniku jazyka PHP) a Eich dostal za
úkol v této kruté časové lhůtě navrhnout <em>menšího a hloupějšího
sourozence Javy</em> – jako konkurenční krok v tvrdém souboji
s prohlížečem Internet Explorer. Tato verze jazyka se jmenovala Mocha
a záměrně, aby nevypadala příliš jako Java, nabízela namísto tříd
prototypy. K jejich fungování Eicha inspiroval jazyk Self; právě
prototypová dědičnost se následně stala definující vlastností, kterou se
JavaScript dodnes odlišuje od ostatních objektově-orientovaných jazyků.
Syntaxi navrhl po vzoru Javy a C; z jazyka Scheme převzal možnosti
funkcionálního programování a uzávěry (viz třetí kapitolu). Během
integrace jazyka do prohlížeče Netscape Navigator došlo ještě v roce
1995 ke dvěma změnám jména: nejprve na LiveScript, poté už na finální
JavaScript.</p></li>
<li><p>V roce 1996 se objevuje první konkurenční implementace – JScript
v Internet Exploreru 3. Zároveň dochází k formální standardizaci jazyka,
tentokrát pod názvem ECMAScript (ECMA je název standardizační organizace
<em>European Computer Manufacturers Association</em> zodpovědné mimo
jiné za specifikace formátů dat na CD či jazyka C#). Až do dnešního dne
tak žijeme v nezvyklém terminologickém guláši: striktně vzato pracujeme
s implementací respektující předpisy standardu ECMAScript, ale
implementace jako taková (nezávisle na použitém prohlížeči či serverovém
prostředí) vykonává zdrojový kód jazyka JavaScript. Tato dualita bude
patrně přetrvávat i nadále, mimo jiné proto, že označení JavaScript je
chráněnou obchodní značkou firmy Oracle.</p></li>
<li><p>Firma Microsoft v roce 2000 vydává webový e-mailový klient
Outlook Web Access; pro jeho potřeby do prohlížeče Internet Explorer 5
přidává nové proprietární rozhraní, které se následně dočká názvu
XMLHttpRequest. Tím dochází k dramatickému nárůstu možností JavaScriptu
(do té doby omezeného fakticky na kontrolu webových formulářů před
jejich odesláním) a následně k rozvoji jeho popularity mezi webovými
vývojáři. Začíná tak období boomu tzv. <em>Ajaxu</em> (více si o tom
povíme v kapitole 5).</p></li>
<li><p>Pro svůj vlastní prohlížeč Chrome se společnost Google rozhodla
vytvořit zbrusu novou a výkonnou implementaci JavaScriptu. V roce 2008
se objevuje Chrome 1.0 a implementace dostává název V8. Mimo jiné i díky
rychlosti V8 dochází k oživení myšlenky, že jazyk jako takový nemá důvod
být používán pouze jako přívěsek webového prohlížeče; není žádná
technologická překážka k použití JavaScriptu i pro programování
serverového kódu. Hned v roce 2009 se objevuje projekt Node.js (jeho
autorem je Ryan Dahl): sada rozhraní a knihoven obalující implementaci
V8 a dovolující tak jednoduše spouštět JavaScriptový kód i mimo webový
prohlížeč.</p></li>
<li><p>Rok 2015 je pro JavaScript pravděpodobně nejdůležitější milník
v moderních dějinách jazyka. Po mnoha letech vývoje <em>do šuplíku</em>
konečně dochází ke zveřejnění nové (šesté) verze jazyka. V porovnání
s minulými verzemi přináší tolik novinek, že jejich popis by vydal na
vlastní knihu. Tato verze nese označení <strong>ES6</strong> (ECMAScript
6), ale zároveň se jí podle roku vzniku říká <strong>ES2015</strong>. Od
tohoto roku organizace ECMA začíná do jazyka integrovat novinky
s pravidelnou roční kadencí. Po pár letech už přestává dvojí číslování
dávat smysl (např. skutečnost, že verze ES12 je to samé jako ES2021)
a k dnešnímu dni jednotlivé verze odlišujeme prostě jen pomocí čísla
roku.</p></li>
<li><p>V roce 2018 se objevuje první vážná konkurence pro Node.js; jedná
se o projekt <em>Deno</em> založený taktéž Ryanem Dahlem. O obou těchto
prostředích pro vykonávání JavaScriptu mimo webový prohlížeč si povíme
více v kapitole 12. Třetí člen tohoto spolku, projekt <em>Bun</em>, je
nyní v roce 2024 žhavá technologická novinka.</p></li>
</ul>
<h2 id="co-by-měl-čtenář-vědět">Co by měl čtenář vědět</h2>
<p>Přestože tato kniha nabízí celou řadu kapitol pro začátečníky, není
vhodná pro úplné amatéry v řemesle programátorském. Od čtenářů se
očekávají znalosti v tomto základním rozsahu:</p>
<ul>
<li><p>Alespoň minimální zkušenost s libovolným programovacím jazykem.
Je docela jedno s jakým; většina jazyků si je podobná jako vejce vejci.
Dobré jazyky pro úplné začátečníky jsou Python, Go, Java, Ruby, Lua,
nebo třeba VBScript, pomocí kterého lze psát makra v kancelářském
software.</p></li>
<li><p>Povědomí o tom, k čemu slouží proměnné a jejich datové typy.
Znalost řetězců, čísel a pravdivostních hodnot. Představa toho, že data
jsou uložena v operační paměti počítače.</p></li>
<li><p>Podstata hlavních logických operací, které při programování
potkáváme: podmínky, cykly, funkce. Nezáleží na jejich syntaxi (zápisu),
ale na jejich užitku při sestavování programů.</p></li>
<li><p>Fungování webových stránek, tj. jazyk HTML a znalost mechanismu
<em>World Wide Web</em>, tj. představa internetem propojené počítačové
sítě a role klientů a serverů v ní. V jazyce HTML pro nás není důležité
velké množství jednotlivých značek, ale koncept toho, že data přenášená
po síti mají tvar odlišný od výsledného vizuálu, který vidíme
v prohlížeči.</p></li>
<li><p>Ovládání počítače a softwarového vybavení. Pro práci
s JavaScriptem nám ve většině kapitol stačí libovolný moderní
(aktualizovaný) webový prohlížeč a textový editor. Samozřejmě je možné
použít specializovaná vývojová prostředí (IDE), ale rozhodně to není
nutné. Stejně tak nezáleží na použitém operačním systému.</p></li>
</ul>
<h2 id="středníky-v-javascriptu">Středníky v JavaScriptu</h2>
<p>(Ne)používání středníků na koncích řádků je jednou ze specifických
vlastností JavaScriptu. Po nějakou dobu si můžeme vystačit se
zjednodušujícím tvrzením, že <em>středníky na konec řádku psát můžeme,
ale nemusíme</em>. Snadno se pak ale stane, že narazíme na konkrétní
případ, kdy tím způsobíme nepříjemnou chybu. Proč?</p>
<p>Náš zdrojový kód je tvořen posloupností jednotlivých příkazů. Tyto
příkazy od sebe musíme oddělovat; někdy je takové oddělení poznat
z použité syntaxe, jindy jej můžeme vynutit zapsáním středníku.
Specialitou JavaScriptu je funkcionalita nazývaná <strong>ASI</strong>
(automatic semicolon insertion). Ta říká, že pokud ve zdrojovém kódu
mezi příkazy schází potřebné oddělení, interpret se pokusí tento kód
<em>opravit</em> automatickým vložením středníku. Fakticky to znamená,
že nepoužíváním středníků se sice dopouštíme mnoha syntaktických chyb,
ale během vykonávání dojde k jejich automatické nápravě.</p>
<p>Bohužel, pravidla pro ASI jsou složitá a mají řadu výjimek.
Spoléháním na ASI se vystavujeme riziku, že takovou výjimku potkáme,
středník sami neuvedeme, ale následně jej nevloží ani ASI. Abychom
nemuseli s komplikovaným algoritmem bojovat, budou v této knize všude
středníky na koncích řádků zapsány explicitně.</p>
<h2 id="ladění">Ladění</h2>
<p>Tvorba zdrojového kódu a zejména proces <em>učení se</em> jsou
neodmyslitelně svázány s chybami, kterých se – omylem a někdy i záměrně
– dopustíme. V různých programovacích jazycích dochází k chybám různými
způsoby, ale jedno mají společné: jako autoři kódu o nich chceme vědět,
pokud možno co nejdříve, a potřebujeme jim porozumět (abychom je uměli
odstranit a do budoucna se jich vyvarovat). Dlouho a záludně skrytá
chyba dokáže potrápit i zkušeného vývojáře; nováčka pak třeba od dalšího
studia i odradit. Proto je nezbytné vědět, jak se ve světě JavaScriptu
o chybách dozvíme a jaké možnosti máme pro jejich vyřešení.</p>
<p>Typicky se při práci s JavaScriptem můžeme setkat se dvěma hlavními
kategoriemi problémů:</p>
<ol type="1">
<li><p>Chyby, které se týkají jazyka jako takového. Do této množiny
spadají chyby syntaktické (zápis v rozporu s pravidly jazyka), přístup
k neexistujícím vlastnostem a funkcím, nechycené výjimky (povíme si
o nich v kapitole 4). Pokud se v našem kódu podobná chyba objeví,
zpravidla to znamená, že interpret (prohlížeč) sám od sebe nedokáže ve
vykonávání pokračovat. Při jistém úhlu pohledu je to dobrá zpráva, neboť
prohlížeč nám o tom dá jasně vědět a my jsme si existencí chyby jisti.
Stačí ji pak nalézt a opravit.</p></li>
<li><p>Chyby, které se týkají naší vlastní algoritmizace. Typicky jsou
založeny na špatné úvaze, nezahrnuté okrajové situaci (anglicky <em>edge
case</em>), chybném výpočtu a podobně. Při těchto chybách se kód
vykonává <em>jakoby nic</em>, ale produkuje špatné výsledky. Zpravidla
pak nezáleží na tom, že pracujeme v JavaScriptu, neboť obdobné chyby
bychom se pravděpodobně dopustili i v jiném jazyce. I tak nás ale
zajímá, jak nám JavaScript může pomoci v odhalení těchto
problémů.</p></li>
</ol>
<p>Protože klientský JavaScript je vykonáván webovým prohlížečem, bude
i hledání chyb pevně svázáno s tímto programem. Nedílnou součástí
každého moderního prohlížeče jsou <strong>Nástroje pro vývojáře</strong>
(anglicky <em>Developer Tools</em>), jejichž rolí je asistence zoufalým
programátorům. Seznámení s těmito nástroji je nezbytné pro vyřešení
většiny problémů, na které při práci narazíme.</p>
<p>V roce 2024 jsme svědky jisté konvergence vývojářských nástrojů
napříč prohlížeči. Vypadají sice různě, ale jejich funkcionalita je
víceméně stejná. Můžeme se k nim dostat buď pomocí různých navigačních
nabídek v prohlížeči, nebo stiskem klávesových zkratek. Zdaleka
nejrozšířenější je zde klávesa <strong>F12</strong>, která vývojářské
nástroje pouští v prohlížečích Firefox, Chrome i Edge (ve Windows
a některých variantách Linuxu). U ostatních platforem bude muset čtenář
sám ověřit, jak přesně se k nim ve svém oblíbeném prohlížeči dostane.
Sedíte teď zrovna vedle počítače? Pokud ano, zkuste si vývojářské
nástroje otevřít (a následně skrýt) hned teď! Při čtení knihy se to bude
ještě mnohokrát hodit.</p>
<p>Tyto <em>devtools</em> nabízí funkcionalitu členěnou do záložek;
můžou jich být i desítky. Pro potřeby naší knihy se budou nejčastěji
hodit záložky:</p>
<ul>
<li><p><strong>Konzole</strong> (anglicky <em>Console</em>), která je
primárním mechanismem pro interakci s JavaScriptovým interpretem.
Prohlížeč sem vypisuje všechny informace, které považuje za relevantní
pro běh programu. Zejména to jsou chyby první kategorie, které se
zobrazují červeně. Jakmile vidíme v konzoli červený řádek, velmi často
to znamená naši chybu, která zasluhuje pozornost. U chyb bývá vypsáno
i číslo řádku zdrojového kódu, na kterém problém nastal. Důležitou
součástí konzole je také vstupní pole, které nám dovoluje v omezené míře
zadávat a vykonávat vlastní povely v JavaScriptu. Jedná se o tzv. REPL
(Read-Eval-Print-Loop), který můžeme znát například z jazyka Python. Pro
rychlé vyzkoušení tím pádem nemusíme zasahovat do zdrojových souborů
a ukládat je na disk; stačí potřebný příkaz zadat do konzole. Tento kód
však samozřejmě nebude nikam uložen a nestane se součástí programů,
které vytváříme.</p></li>
<li><p><strong>Síť</strong> (anglicky <em>Network</em>) zobrazuje
veškerou komunikaci po Internetu, kterou prohlížeč provádí. Zahrnuje to
jak data přenášená v rámci přesunu mezi stránkami (tzv.
<em>navigaci</em>), tak i data získávaná prohlížečem bez explicitního
vyžádání na pozadí – obrázky, skripty, styly a další. Jakmile začneme
pomocí JavaScriptu vytvářet HTTP požadavky (kapitola 5), bude se nám
tato záložka velmi hodit.</p></li>
<li><p><strong>Zdroje</strong> (anglicky <em>Sources</em>), případně
<strong>Debugger</strong>, nabízí pokročilejší možnosti prozkoumávání
právě vykonávaného kódu. V této záložce můžeme pozastavit spuštěný
JavaScript, prozkoumávat hodnoty proměnných a podobně.</p></li>
</ul>
<p>Při hledání problémů ve zdrojovém kódu je užitečné mít přehled o tom,
které funkce a v jakém pořadí se vykonávají, jakých hodnot nabývají
proměnné a podobně. Za tímto účelem existují příslušné nástroje, které
pomohou programátora o zmiňovaných veličinách informovat. Ve světě
klientského JavaScriptu je to historicky především funkce
<code>alert</code> a dále globální objekt <code>console</code>.</p>
<p>Volání <code>alert(promenna)</code> vypíše v parametru předanou
hodnotu do tzv. <em>modálního</em> okénka. Jedná se o primitivní
mechanismus, kterým můžeme zobrazit potřebná data. Jeho hlavní výhoda je
v tom, že pozastaví vykonávání veškerého JavaScriptu (přepne prohlížeč
do ne-JavaScriptového <em>módu</em>, odtud název <em>modální</em>), a my
tak máme čas si veličinu prohlédnout bez obavy, že nám nějaká další
aktivita uteče. Za zmínku stojí, že vypisované hodnoty jsou automaticky
převáděny na řetězec, takže složitější datové struktury nám
<code>alert</code> nezobrazí. V dřevních dobách JavaScriptu se takové
uživatelské rozhraní používalo i za účelem zobrazení informací běžným
čtenářům webu, ale dnes by to byla spíš ostuda, takže si funkci
<code>alert</code> schováme výhradně pro ladicí potřeby.</p>
<p>V proměnné <code>console</code> se ukrývá řada funkcí, pomocí kterých
můžeme z vlastního kódu zapisovat rozmanitá data do konzole, o jejímž
působení v rámci devtools jsme se dozvěděli před pár odstavci.
Nejčastější a nám nejvíce užitečné jsou <code>console.log()</code>,
<code>console.warn()</code> a <code>console.error()</code>. Jejich
chování je identické, jen předaná data zapisují do konzole v různých
barevných odstínech, aby se tak odlišila závažnost. Tyto funkce jsou
<em>variadické</em>, tj. můžeme jim předat libovolný počet parametrů.
Každý z nich zapíšou do konzole a zvládnou libovolně složité datové
typy.</p>
<p>Zvídavý čtenář nyní může zkusit objekt <code>console</code>
prozkoumat (například voláním <code>console.log(console)</code>),
a najít tak spoustu dalších užitečných funkcí. O všech se následně může
dočíst třeba na webu MDN (viz dále).</p>
<h2 id="další-čtení">Další čtení</h2>
<p>Tuto knihu jsem napsal, protože mi na českém trhu schází literatura,
která by JavaScript vysvětlovala přístupnou formou a zároveň dokázala
oslovit zájemce od nováčků až po odborníky. Rozhodně to však neznamená,
že kniha pokryje potřeby každého zvídavého čtenáře! Zároveň není
v možnostech jednotlivce úplně ovládnout veškeré rysy natolik bohatého
jazyka, jakým JavaScript je. Pojďme se podívat na další (anglické)
materiály, které mohou přijít vhod.</p>
<ul>
<li><p>Především tato kniha není referenční příručkou, dokumentací ani
kompletním strukturovaným popisem gramatiky a vlastností jazyka. Zájemce
o takto formální popis můžeme odkázat na oficiální web pracovní skupiny
TC39 (<a href="https://tc39.es/">https://tc39.es/</a>), která vytváří
a koordinuje standard, na základě kterého pak vznikají jednotlivé
implementace JavaScriptu. Výrazně praktičtější je pak web s historickým
označením <strong>MDN</strong> (Mozilla Developer Network) na adrese <a
href="https://developer.mozilla.org/en-US/docs/Web/JavaScript">https://developer.mozilla.org/en-US/docs/Web/JavaScript</a>
– zde si můžeme přečíst o všech aspektech jazyka, prohlédnout
interaktivní ukázky a taktéž k tvorbě dokumentace přispět. Web totiž
stojí na otevřeném wiki-systému a je vytvářen dobrovolníky. Velikou
výhodou MDN je také propojení s HTML a CSS, neboť tento web se snaží
pokrýt úplně všechny aspekty klientského webového vývoje.</p></li>
<li><p>Sada knih <strong>Exploring JS</strong> od Axela Rauschmayera je
k dispozici zdarma online na jeho webových stránkách (<a
href="https://exploringjs.com/">https://exploringjs.com/</a>).
Dr. Rauschmayer je velmi zkušený, píše čtivě a pokrývá široké spektrum
témat. Jeho knihy se věnují JavaScriptu zevrubně, takže namísto čtení
<em>od začátku do konce</em> slouží lépe jako referenční
příručka.</p></li>
<li><p>Kniha <strong>You Don’t Know JS Yet</strong> (autor Kyle Simpson)
je populární a čtivá. Existuje v online verzi (<a
href="https://github.com/getify/You-Dont-Know-JS">https://github.com/getify/You-Dont-Know-JS</a>)
i tištěná. Věnuje se především záludným partiím JavaScriptu, tj. těm,
které bychom v této knize popisovali zejména v podkapitolách pro
profíky.</p></li>
<li><p>Poslední zmínku zaslouží kniha <strong>Eloquent
JavaScript</strong>, kterou napsal Marijn Haverbeke. Můžeme si ji
přečíst na webu <a
href="https://eloquentjavascript.net/">https://eloquentjavascript.net/</a>,
stáhnout v PDF, případně zakoupit vytištěnou. Je velmi obsáhlá a čtenář
v ní nalezne značné množství úloh, často výrazně obtížnějších, než
v této knize.</p></li>
</ul>
<h2 id="materiály-online">Materiály online</h2>
<p>Tato kniha je k dispozici v tištěné podobě a taktéž elektronicky.
Její digitální verze, společně se všemi podklady nutnými k publikaci, je
vystavena na GitHubu. V repozitáři jsou zároveň umístěny i zdrojové
kódy, které v následujících kapitolách probíráme a komentujeme. Pro
snazší experimenty tak čtenář může navštívit web <a
href="https://github.com/ondras/javascript-resene-ulohy">https://github.com/ondras/javascript-resene-ulohy</a>,
kde nalezne nejen studijní materiály, ale taktéž <em>issue tracker</em>
– nástroj na hlášení chyb a nedostatků. Jeho prostřednictvím dokážeme
udržovat text elektronické verze knihy i jednotlivých příkladů aktuální
a užitečný. Pokud při čtení narazíte na místo, které se zdá podivné,
možná jste objevili chybu. Na GitHubu ji můžete nahlásit, nebo třeba
zjistit, že již byla nahlášena a v elektronické verzi knihy
opravena.</p>
<p>Pro úplnost je na místě dodat, že zveřejnění digitální verze nastává
s drobným odstupem několika týdnů po té tištěné. Zdrojové kódy řešených
příkladů jsou ale k dispozici ihned.</p>
<h1 id="první-setkání">První setkání</h1>
<h2 id="úloha">Úloha</h2>
<p>Pro fanoušky Karla Gotta chystáme vzpomínkový web, který bude
obsahovat i texty písní. Některé jsou ale příliš dlouhé, takže je nutné
zobrazit jen prvních několik znaků a zbytek textu skrýt. Po kliknutí na
tlačítko se ukáže celý text písně.</p>
<h3 id="řešení">Řešení</h3>
<div class="sourceCode" id="cb1"><pre
class="sourceCode html"><code class="sourceCode html"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">&lt;!-- kapitola-2.html --&gt;</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="dt">&lt;</span><span class="kw">h1</span><span class="dt">&gt;</span>Mám styl Čendy<span class="dt">&lt;/</span><span class="kw">h1</span><span class="dt">&gt;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="dt">&lt;</span><span class="kw">pre</span><span class="dt">&gt;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>Mezi námi je mnoho chvil</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>A pokusů, abych se ti zavděčil</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>Jenomže od tebe se člověk moc nedoví</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>Stále básníš o ňákém svém záhadném Čendovi</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="dt">&lt;/</span><span class="kw">pre</span><span class="dt">&gt;</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="dt">&lt;</span><span class="kw">script</span><span class="dt">&gt;</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> song <span class="op">=</span> <span class="bu">document</span><span class="op">.</span><span class="fu">querySelector</span>(<span class="st">&quot;pre&quot;</span>)<span class="op">;</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> text <span class="op">=</span> song<span class="op">.</span><span class="at">textContent</span><span class="op">;</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>song<span class="op">.</span><span class="at">textContent</span> <span class="op">=</span> text<span class="op">.</span><span class="fu">substring</span>(<span class="dv">0</span><span class="op">,</span> <span class="dv">50</span>) <span class="op">+</span> <span class="st">&quot;...&quot;</span><span class="op">;</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> button <span class="op">=</span> <span class="bu">document</span><span class="op">.</span><span class="fu">createElement</span>(<span class="st">&quot;button&quot;</span>)<span class="op">;</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>button<span class="op">.</span><span class="at">textContent</span> <span class="op">=</span> <span class="st">&quot;zobrazit celý text&quot;</span><span class="op">;</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>song<span class="op">.</span><span class="fu">append</span>(button)<span class="op">;</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">showCompleteText</span>() {</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>  song<span class="op">.</span><span class="at">textContent</span> <span class="op">=</span> text<span class="op">;</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>button<span class="op">.</span><span class="fu">addEventListener</span>(<span class="st">&quot;click&quot;</span><span class="op">,</span> showCompleteText)<span class="op">;</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a><span class="dt">&lt;/</span><span class="kw">script</span><span class="dt">&gt;</span></span></code></pre></div>
<p>První setkání s JavaScriptem! Výše uvedený kód představuje řešení
naší úlohy, které z textu písně zobrazí prvních 50 znaků a zbytek
skryje. Po kliknutí na tlačítko se odhalí text celý.</p>
<p>Úvodem přiznejme, že se rozhodně nejedná o nejlepší řešení. Zkušený
programátor v něm jistě nalezne místa k vylepšení. Některá z nich si
ukážeme v první začátečnické podkapitole. Předtím se ale podíváme na
celé vzorové řešení řádek po řádku a vysvětlíme, co vše se z něj můžeme
naučit.</p>
<h3 id="krok-po-kroku">Krok po kroku</h3>
<p>Převážná většina této knihy se týká <em>klientského JavaScriptu</em>,
tedy toho scénáře, kdy jazyk používáme pro vylepšení webových stránek.
Technologicky to znamená, že:</p>
<ul>
<li><p>k vyzkoušení potřebujeme libovolný webový prohlížeč (tzv.
<em>klient</em>)</p></li>
<li><p>v prohlížeči otevíráme webovou (HTML) stránku, jejíž přímou či
nepřímou součástí je JavaScriptový kód</p></li>
<li><p>prohlížeč proto v rámci zobrazení stránky musí také stáhnout
a vykonat instrukce obsažené v tomto kódu</p></li>
</ul>
<p>Z toho plyne, že není nutné používat žádný specializovaný software,
který by JavaScript zpracovával (interpretoval, kompiloval, …). Naopak
je potřeba alespoň trochu rozumět HTML, protože výsledná stránka je
s JavaScriptem niterně provázána: kód píšeme proto, aby stránku
vylepšoval, ovlivňoval a měnil.</p>
<p>Tím se dostáváme ke skriptu samotnému. Jeho první dva řádky začínají
klíčovým slovem <code>let</code>, kterým uvozujeme definici proměnných.
Vytváříme dvě proměnné (<code>song</code> a <code>text</code>) a rovnou
je naplníme hodnotami pomocí znaku rovnítka (tzv. <em>operátor
přiřazení</em>). Protože naším cílem je manipulace se stránkou (skrytí
části textu), potřebujeme se především dostat k jednotlivým HTML prvkům
ve stránce a jejich obsahu. To je ve světě klientského JavaScriptu možné
pomocí sady funkcí a objektů souhrnně nazývaných <strong>DOM</strong> –
Document Object Model. Jedná se o velice silný nástroj, který budeme
využívat v téměř všech kapitolách. Pomocí DOM můžeme do stránky vkládat
nový obsah, upravovat existující, nebo klidně stránku celou vymazat
a sestavit znova a jinak.</p>
<p>Rozhraní DOM je pro nás přístupné především pomocí globální vestavěné
proměnné <code>document</code>. Ta odpovídá té stránce, kterou prohlížeč
právě zobrazuje (a jejíž JavaScript je právě vykonáván). V dokumentaci
lze nalézt veliké množství vlastností a funkcí, které takový
<code>document</code> nabízí – na některé z nich se podíváme
v nadcházející podkapitole pro koumáky. I zelenáč ovšem musí ovládat
funkci <code>querySelector</code>, kterou používáme k tomu, abychom
v dokumentu vyhledali konkrétní HTML prvek. Parametrem pro
<code>querySelector</code> je řetězec obsahující <em>CSS selektor</em>,
který známe ze světa CSS. Tam jej používáme pro stejný účel, když
vybíráme HTML značky, na které se mají aplikovat daná stylová
pravidla.</p>
<p>V první proměnné (<code>song</code>) proto bude uložena první značka
<code>&lt;pre&gt;</code> ve stránce – náš text písně. Druhou proměnnou
(<code>text</code>) pak naplníme samotným obsahem dané HTML značky; její
datový typ bude řetězec. Používáme k tomu vlastnost
<code>textContent</code>, která opět pochází ze světa DOM.</p>
<p>Následující řádek slouží ke skrytí většiny textu:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>song<span class="op">.</span><span class="at">textContent</span> <span class="op">=</span> text<span class="op">.</span><span class="fu">substring</span>(<span class="dv">0</span><span class="op">,</span> <span class="dv">50</span>) <span class="op">+</span> <span class="st">&quot;...&quot;</span><span class="op">;</span></span></code></pre></div>
<p>To je naše první opravdová <em>manipulace</em> s DOMem, tedy se
stránkou! Přiřazením do vlastnosti <code>textContent</code> rozkazujeme,
že je nutné HTML pozměnit nahrazením textu, který se zobrazuje uvnitř
značky <code>&lt;pre&gt;</code> (tj. uvnitř proměnné <code>song</code>).
Vypíšeme v ní prvních padesát znaků z textu (funkce
<code>substring</code> vrátí podřetězec od/do zadané pozice) a k tomu
ještě připojíme tři tečky – naznačení, že v těchto místech je cosi
skryto. Můžeme si rovnou povšimnout použitého znaménka <code>+</code>,
které v JavaScriptu funguje nejen pro aritmetiku (sčítání), ale také pro
spojování řetězců. V dalších kapitolách ovšem uvidíme, že tato forma
kombinace řetězců není jediná a často je vhodnější použít jiný
zápis.</p>
<p>Následuje vytvoření tlačítka pro odkrytí zbylého textu. Seznámíme se
tak s dalšími dvěma funkcemi rozhraní DOM – <code>createElement</code>
pro vytvoření nového HTML prvku a <code>append</code> pro jeho vložení
dovnitř stránky. V našem případě chceme tlačítko ukázat za vytečkovaným
textem, tj. na konci HTML prvku <code>&lt;pre&gt;</code> (který máme
uložený v proměnné <code>song</code>). Nově vytvořené tlačítko přiřadíme
do proměnné <code>button</code>:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> button <span class="op">=</span> <span class="bu">document</span><span class="op">.</span><span class="fu">createElement</span>(<span class="st">&quot;button&quot;</span>)<span class="op">;</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>button<span class="op">.</span><span class="at">textContent</span> <span class="op">=</span> <span class="st">&quot;zobrazit celý text&quot;</span><span class="op">;</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>song<span class="op">.</span><span class="fu">append</span>(button)<span class="op">;</span></span></code></pre></div>
<p>Poslední přísada do funkčního řešení je sice drobná, ale zásadní.
Musíme provázat kliknutí na tlačítko se zobrazením zbylého textu. Ve
světě klientského JavaScriptu (a víceméně i kdykoliv jindy, kdy
pracujeme s uživatelskými rozhraními) se k tomu používá koncept nazvaný
<em>programování řízené událostmi</em> (anglicky <em>event-based
programming</em>). V našem případě to znamená následující činnosti:</p>
<ol type="1">
<li><p>Rozmyslet, při které události či interakci chceme nějaký
JavaScript spustit.</p></li>
<li><p>Připravit si tento kód a vytvořit pro něj JS
<em>funkci</em>.</p></li>
<li><p>Propojit výše uvedené pomocí DOM funkce
<code>addEventListener</code>.</p></li>
</ol>
<p>Těmto aktivitám odpovídají poslední řádky z řešení:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">showCompleteText</span>() {</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>  song<span class="op">.</span><span class="at">textContent</span> <span class="op">=</span> text<span class="op">;</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>button<span class="op">.</span><span class="fu">addEventListener</span>(<span class="st">&quot;click&quot;</span><span class="op">,</span> showCompleteText)<span class="op">;</span></span></code></pre></div>
<p>Definice funkce je velmi jednoduchá, neboť nepotřebuje žádné
parametry ani návratovou hodnotu. Zvláštní pozornost ale věnujme volání
<code>addEventListener</code>, které prohlížeč instruuje, aby naši
funkci (předanou jako druhý parametr) vykonal, jakmile nastane kliknutí
myší (řetězec <code>"click"</code> v prvním parametru) – a to celé jen
pokud událost nastane na HTML prvku uloženém v proměnné
<code>button</code>.</p>
<p><strong>Pozor!</strong> Funkci <code>showCompleteText</code> sice
definujeme, ale nikdy ji sami nevoláme. Nevíme totiž, kdy – to ví jen
prohlížeč, který se od operačního systému dozví o kliknutí myší. Proto
ji jen <em>předáváme</em> jako druhý parametr při volání funkce
<code>addEventListener</code>. Tento zápis může být pro začátečníka
matoucí, neboť vzdáleně připomíná <em>volání</em> funkce, při kterém za
její jméno ještě píšeme kulaté závorky.</p>
<p>V JavaScriptu jsou funkce docela běžný datový typ. Pro snazší
pochopení se na ně můžeme dívat jako na obyčejné proměnné; dokonce je
tak lze i definovat. V našem případě bychom klidně mohli psát</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> showCompleteText <span class="op">=</span> <span class="kw">function</span>() {</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>  song<span class="op">.</span><span class="at">textContent</span> <span class="op">=</span> text<span class="op">;</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Při tomto zápisu je pak předání hodnoty <code>showCompleteText</code>
jako parametru do jiné funkce docela pochopitelné.</p>
<h3 id="co-jsme-se-naučili">Co jsme se naučili</h3>
<p>Po vyřešení první úlohy by měl čtenář chápat a ovládat:</p>
<ul>
<li><p>definici proměnných</p></li>
<li><p>definici funkce</p></li>
<li><p>nejdůležitější funkce a proměnné z rozhraní DOM:
<code>document</code>, <code>querySelector</code>,
<code>createElement</code>, <code>append</code>
a <code>addEventListener</code></p></li>
<li><p>základy konceptu programování řízeného událostmi</p></li>
</ul>
<h2 id="zelenáči-drobná-vylepšení">Zelenáči: drobná vylepšení</h2>
<p>Stará programátorská mantra praví, že problém bychom měli ideálně
řešit ve třech krocích. Tím prvním je rychlé sestavení jednoduchého
a hloupého řešení <em>(make it work)</em>. Po ověření, že zhruba
funguje, můžeme přistoupit k vylepšení tak, abychom pokryli všechny
vstupy <em>(make it right)</em>. A až na úplný závěr můžeme uvážit,
zdali bychom neuměli výsledný kód ještě upravit s ohledem na výkon
<em>(make it fast)</em>.</p>
<p>Výše ukázané řešení je vystavěné přesně dle prvního kroku <em>make it
work</em>. Nyní přišel čas na druhou fázi rčení, totiž <em>make it
right</em>. Zkusíme kód vylepšit nikoliv ve smyslu jeho funkcionality,
ale ve smyslu jeho praktického použití a znovupoužití.</p>
<p>Prvním nedostatkem je skutečnost, že jsme celý JavaScript napsali
přímo do HTML dokumentu, mezi značky <code>&lt;script&gt;</code>
a <code>&lt;/script&gt;</code>. To přináší dvě nevýhody: jednak tento
kód nelze znovupoužít v dalších stránkách, jednak teď náš dokument
obsahuje zdrojový kód ve dvou jazycích (HTML a JS). Šikovnější by bylo,
kdyby tyto dvě technologie mohly fungovat ve dvou různých souborech,
a každý z nich by následně mohl měnit třeba jinak zdatný programátor.
Oddělení JavaScriptu do samotného souboru je zcela běžná a přímočará
operace: v HTML zůstane jen značka <code>&lt;script&gt;</code>, u které
pomocí atributu <code>src</code> uvedeme, na které adrese se nachází
soubor s JS kódem.</p>
<p>Další drobný nedostatek je použití čísla 50 při zkracování textu.
Napříč všemi programovacími jazyky platí úmluva, že podobné veličiny
ovlivňující fungování programu patří <em>na začátek zdrojového
kódu</em>, abychom je nemuseli hledat, když vyvstane potřeba jejich
změny. Pro nás je to ideální chvíle na seznámení se
s <strong>konstantami</strong> – to jsou hodnoty, které nelze měnit.
Pracujeme s nimi podobně jako s proměnnými, jen pro jejich definici
použijeme klíčové slovo <code>const</code> (namísto <code>let</code>),
a jistě nás nepřekvapí, že případný pokus o jejich změnu by vyústil
v chybu.</p>
<p>Třetí vylepšení souvisí s tím, kolik různých změn provádíme ve
stránce. Náš současný kód mění HTML prvek <code>&lt;pre&gt;</code>,
jehož obsah nejprve nahradí (změna vlastnosti <code>textContent</code>)
a o pár řádků později ještě obohatí o tlačítko. Zde můžeme naše řešení
trochu zkrátit a ještě vylepšit jeho čitelnost, když obě změny (text
i tlačítko) provedeme naráz. Stačí jen znát správnou funkci z rozhraní
DOM, která obsah <code>&lt;pre&gt;</code> nahradí kombinací textu,
výpustky (tak se správně říká trojtečce) a tlačítka. Její jméno je
<code>replaceChildren</code> a jedná se o tzv. <em>variadickou
funkci</em>. To znamená, že ji lze volat s libovolným počtem parametrů.
Prohlížeč je vezme jeden po druhém a vystaví z nich nový obsah daného
HTML prvku.</p>
<p>Po aplikování tří výše uvedených vylepšení pak řešení první úlohy
vypadá následovně. V HTML souboru zůstalo:</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode html"><code class="sourceCode html"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="dt">&lt;</span><span class="kw">h1</span><span class="dt">&gt;</span>Mám styl Čendy<span class="dt">&lt;/</span><span class="kw">h1</span><span class="dt">&gt;</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="dt">&lt;</span><span class="kw">pre</span><span class="dt">&gt;</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>Mezi námi je mnoho chvil</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>A pokusů, abych se ti zavděčil</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>Jenomže od tebe se člověk moc nedoví</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>Stále básníš o ňákém svém záhadném Čendovi</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="dt">&lt;/</span><span class="kw">pre</span><span class="dt">&gt;</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a><span class="dt">&lt;</span><span class="kw">script</span> <span class="er">src</span><span class="ot">=</span><span class="st">&quot;kapitola-2.js&quot;</span><span class="dt">&gt;&lt;/</span><span class="kw">script</span><span class="dt">&gt;</span></span></code></pre></div>
<p>A nově vytvořený soubor <code>kapitola-2.js</code> obsahuje:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> LIMIT <span class="op">=</span> <span class="dv">50</span><span class="op">;</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> song <span class="op">=</span> <span class="bu">document</span><span class="op">.</span><span class="fu">querySelector</span>(<span class="st">&quot;pre&quot;</span>)<span class="op">;</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> text <span class="op">=</span> song<span class="op">.</span><span class="at">textContent</span><span class="op">;</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> button <span class="op">=</span> <span class="bu">document</span><span class="op">.</span><span class="fu">createElement</span>(<span class="st">&quot;button&quot;</span>)<span class="op">;</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>button<span class="op">.</span><span class="at">textContent</span> <span class="op">=</span> <span class="st">&quot;zobrazit celý text&quot;</span><span class="op">;</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>song<span class="op">.</span><span class="fu">replaceChildren</span>(text<span class="op">.</span><span class="fu">substring</span>(<span class="dv">0</span><span class="op">,</span> LIMIT)<span class="op">,</span> <span class="st">&quot;…&quot;</span><span class="op">,</span> button)<span class="op">;</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">showCompleteText</span>() {</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>  song<span class="op">.</span><span class="at">textContent</span> <span class="op">=</span> text<span class="op">;</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>button<span class="op">.</span><span class="fu">addEventListener</span>(<span class="st">&quot;click&quot;</span><span class="op">,</span> showCompleteText)<span class="op">;</span></span></code></pre></div>
<h2 id="koumáci-průzkum-stromu-domu">Koumáci: průzkum stromu DOMu</h2>
<p>Zásahy ovlivňující vzhled, obsah a fungování webové stránky jsou
hlavní náplní klientského JavaScriptu. Víme už, že hlavním prostředkem
k tomu je sada proměnných a funkcí souhrnně nazývaná DOM. Protože
takových zásahů můžeme provádět velké množství, představuje DOM pořádně
objemný balík funkcionality. Jeho rozsah může být pro nováčka
odrazující. Pojďme v té kupě na první pohled nesouvisejících funkcí
najít nějaký smysl a říci si, na jakých pravidlech je DOM vystaven.</p>
<p>Klíčovou myšlenkou pro pochopení DOMu je představa, že jednotlivé
HTML prvky tvoří tzv. <em>strom</em> – paměťovou strukturu, kterou si
možná pamatujete z kurzů programování ve škole. Při psaní HTML nám
přijde přirozené uvažovat o <em>zanoření</em> značek a to už je jen
krůček od vytvoření hierarchického vztahu rodič-potomek. Pojďme se
podívat na ukázku. Mějme takovýto HTML kód:</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode html"><code class="sourceCode html"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="dt">&lt;</span><span class="kw">html</span><span class="dt">&gt;</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&lt;</span><span class="kw">head</span><span class="dt">&gt;</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">&lt;</span><span class="kw">title</span><span class="dt">&gt;</span> Titulek <span class="dt">&lt;/</span><span class="kw">title</span><span class="dt">&gt;</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&lt;/</span><span class="kw">head</span><span class="dt">&gt;</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&lt;</span><span class="kw">body</span><span class="dt">&gt;</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">&lt;</span><span class="kw">h1</span><span class="dt">&gt;</span> Nadpis <span class="dt">&lt;/</span><span class="kw">h1</span><span class="dt">&gt;</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">&lt;</span><span class="kw">p</span><span class="dt">&gt;</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>      Odstavec s <span class="dt">&lt;</span><span class="kw">a</span><span class="dt">&gt;</span>odkazem<span class="dt">&lt;/</span><span class="kw">a</span><span class="dt">&gt;</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">&lt;/</span><span class="kw">p</span><span class="dt">&gt;</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&lt;/</span><span class="kw">body</span><span class="dt">&gt;</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a><span class="dt">&lt;/</span><span class="kw">html</span><span class="dt">&gt;</span></span></code></pre></div>
<p>Tomu odpovídá následující strom:</p>
<figure>
<img src="../img/tree.svg" alt="Paměťová reprezentace HTML dokumentu" />
<figcaption aria-hidden="true">Paměťová reprezentace HTML
dokumentu</figcaption>
</figure>
<p>A ještě trocha terminologie:</p>
<ul>
<li><p>Paměťové stromy rostou opačným směrem, než ty v přírodě. Náš
strom má jeden <strong>kořen</strong> (je jím značka
<code>&lt;html&gt;</code>) a roste dolů.</p></li>
<li><p>Každé jednotlivé součásti stromu se říká <strong>uzel</strong>
(anglicky <strong>node</strong>).</p></li>
<li><p>Každý uzel, s výjimkou kořene, má právě jednoho
<strong>rodiče</strong>. Opačný vztah označujeme slovem
<strong>potomek</strong>.</p></li>
<li><p>Všechny uzly se společným rodičem označujeme jako jeho
<strong>přímé potomky</strong> nebo <strong>děti</strong>. Slovo
<strong>potomek</strong> tedy zahrnuje jak ty přímé, tak i jejich děti,
tj. celou širokou rodinu vnoučat a pravnoučat, až k listům
stromu.</p></li>
<li><p>Uzly, které nemají potomky, se nazývají <strong>listy</strong>
stromu. V HTML to jsou především tzv. <strong>textové uzly</strong> (to,
co uživatel na stránce vidí) a potom ty HTML značky, které jsou prázdné
(například obrázky nebo značky <code>&lt;input&gt;</code>).</p></li>
<li><p>Uzly, které odpovídají HTML značkám (tedy ty, co nejsou
<strong>textové</strong>), se nazývají <strong>HTML prvky</strong>
(anglicky <em>element nodes</em>). Ty nás při práci s DOM zajímají
nejčastěji, takže většina funkcionality v DOM se věnuje právě
jim.</p></li>
</ul>
<p>V této podkapitole si zkusíme shrnout funkce, které se nám hodí při
práci s uvedenou stromovou reprezentací. Rozhraní DOM je s JavaScriptem
historicky neodmyslitelně spojeno, takže se s námi táhne už pěknou řádku
let. A protože málokdo dokáže věci vymyslet perfektně napoprvé, má za
sebou i DOM celkem kontroverzní minulost. V prvních letech JavaScriptu
bylo v rámci DOM k dispozici jen omezené množství funkcionality, často
navržené nešikovně, a navíc implementované nekonzistentně napříč různými
webovými prohlížeči. Dnes máme štěstí, že takové rozdíly už téměř
neexistují a do DOMu se časem dostaly přesně ty funkce, které nám
pomohou snadno vyřešit potřebnou úpravu stromu stránky.</p>
<p>Poslední terminologická zastávka se týká skutečnosti, že rozhraní DOM
je navrženo <em>objektově</em> (dle konceptů tzv.
<em>objektově-orientovaného programování</em>, zkráceně OOP). Funkce
a proměnné, které přísluší nějaké části stránky, jsou dostupné pomocí
operátoru tečky. Na příkladu z první řešené úlohy:</p>
<ul>
<li><p>proměnné <code>song.textContent</code> říkáme <em>vlastnost</em>,
protože někomu patří (HTML prvku <code>&lt;pre&gt;</code>),</p></li>
<li><p>funkci <code>button.addEventListener</code> říkáme
<em>metoda</em>, protože někomu patří (HTML prvku
<code>&lt;button&gt;</code>).</p></li>
</ul>
<p>V kurzech objektově-orientovaného programování bývá zvykem na tuto
terminologii striktně dbát. V JavaScriptu tak přísní nejsme, mimo jiné
proto, že – jak si ukážeme v kapitole 8 – mezi <em>funkcemi</em>
a <em>metodami</em> ve skutečnosti není téměř žádný rozdíl.</p>
<h3 id="průchod-stromem">Průchod stromem</h3>
<p>Vstupním bodem do stromu stránky je vždy proměnná
<code>document</code>. V něm se pak můžeme pohybovat různými metodami
a vlastnostmi:</p>
<ul>
<li><p>Metoda <code>document.querySelector</code> vrací první HTML prvek
vyhovující danému selektoru. Tato metoda je dostupná i pro HTML prvky,
takže můžeme psát např. <code>song.querySelector(...)</code>, a omezit
tak hledání jen na potomky proměnné <code>song</code>.</p></li>
<li><p>Metoda <code>document.querySelectorAll</code> (a její varianty
pro všechny prvky <code>prvek.querySelectorAll</code>) vrací všechny
potomky vyhovující danému selektoru.</p></li>
<li><p>Vlastnost <code>node.parentNode</code> odkazuje na rodiče
zadaného uzlu (uloženého v proměnné <code>node</code>).</p></li>
<li><p>Vlastnost <code>parent.children</code> odpovídá všem prvkům
(nikoliv textovým uzlům), které jsou přímými potomky daného rodiče.
První z nich je dostupný jako <code>parent.firstElementChild</code>,
poslední pak <code>parent.lastElementChild</code>.</p></li>
<li><p>Vlastnost <code>parent.childNodes</code> odpovídá všem dětem
daného rodiče (textové uzly i HTML prvky). První z nich je dostupný jako
<code>parent.firstChild</code>, poslední pak
<code>parent.lastChild</code>.</p></li>
<li><p>Vlastnost <code>element.previousElementSibling</code> je
předchozí HTML prvek ve stejném rodiči; symetricky
<code>element.nextElementSibling</code> je následující HTML
prvek.</p></li>
<li><p>Vlastnost <code>element.previousSibling</code> je předchozí uzel;
symetricky <code>element.nextSibling</code> je následující
uzel.</p></li>
</ul>
<p>V rozhraní DOM nalezneme i další vlastnosti a metody užitečné pro
navigaci stromem, ale ty výše uvedené nám bohatě postačí.</p>
<h3 id="tvorba-nových-uzlů">Tvorba nových uzlů</h3>
<ul>
<li><p><code>document.createElement(name)</code> vyrobí nový HTML prvek.
Je to jedináček a sirotek; dokud jej nevložíme někam do stromu, nebude
mít rodiče, sourozence ani potomky.</p></li>
<li><p><code>document.createElementNS(ns, name)</code> je historickou
specialitou, kterou používáme téměř výhradně k tvorbě SVG prvků. Více se
o nich dočteme v bonusové čtrnácté kapitole.</p></li>
<li><p><code>document.createTextNode(text)</code> vyrobí nový textový
uzel. Mohlo by se zdát, že je to docela praktická metoda, ale uvidíme,
že ji téměř nikdy nepotřebujeme.</p></li>
</ul>
<h3 id="vkládání-uzlů-do-stromu">Vkládání uzlů do stromu</h3>
<p>Níže uvedené metody fungují obdobně: vloží zadané uzly na konkrétní
místo ve stromu dokumentu. Jsou variadické, takže jim můžeme předat
libovolný počet parametrů. Těmi můžou být nejen HTML prvky (vzniklé
například voláním <code>createElement</code> či
<code>querySelector</code>), ale také obyčejné JS řetězce, které budou
automaticky převedeny na textové uzly.</p>
<p>Pokud tímto způsobem vložíme do stromu uzel, který už předtím někde
ve stromu byl, tak dojde k jeho přesunu na nové místo.</p>
<ul>
<li><p><code>parent.append(child1, child2, ...)</code> přidá nové uzly
jako potomky na konec rodiče.</p></li>
<li><p><code>parent.prepend(child1, child2, ...)</code> přidá nové uzly
jako potomky na začátek rodiče (před prvního existujícího potomka, pokud
nějaký je).</p></li>
<li><p><code>element.before(other1, other2, ...)</code> přidá nové uzly
před daný prvek (tj. budou to jeho sourozenci).</p></li>
<li><p><code>element.after(other1, other2, ...)</code> přidá nové uzly
za daný prvek (tj. budou to jeho sourozenci).</p></li>
</ul>
<h3 id="nahrazení-uzlů-jinými">Nahrazení uzlů jinými</h3>
<ul>
<li><p><code>parent.replaceChildren(child1, child2, ...)</code> odebere
všechny potomky a nahradí je novými.</p></li>
<li><p><code>element.replaceWith(other1, other2, ...)</code> nahradí
daný prvek jedním či více jinými.</p></li>
</ul>
<h3 id="odebrání-uzlů">Odebrání uzlů</h3>
<ul>
<li><p>
<code>element.remove()</code>
</p></li>
</ul>
<h3 id="ostatní">Ostatní</h3>
<p>Kromě výše uvedených metod lze strom stránky měnit ještě pomocí
několika dalších vlastností. My se nyní podíváme na dvě z nich, které
jsou důležité jak pro <em>čtení</em>, tak pro <em>zápis</em>.</p>
<p>Čtením vlastnosti <code>element.textContent</code> získáme zřetězení
všech textových uzlů, které jsou potomky prvku <code>element</code>.
Když do této vlastnosti přiřadíme, tak zadaným textem nahradíme obsah
prvku <code>element</code>. Následující dva zápisy jsou tedy
identické:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode js"><code class="sourceCode javascript"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>element<span class="op">.</span><span class="at">textContent</span> <span class="op">=</span> <span class="st">&quot;Mám styl Čendy&quot;</span><span class="op">;</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>element<span class="op">.</span><span class="fu">replaceChildren</span>(<span class="st">&quot;Mám styl Čendy&quot;</span>)<span class="op">;</span></span></code></pre></div>
<p>Obdobným systémem funguje druhá vlastnost
<code>element.innerHTML</code>. Jejím čtením získáme zřetězení
<em>veškerých</em> potomků daného prvku, tedy nejen těch textových. HTML
potomci budou převedeni na text pomocí jejich zápisu v HTML.</p>
<p>Přiřazení do <code>element.innerHTML</code> nám dovoluje vystavět
nový podstrom z řetězce obsahujícího HTML. Stejně jako
u <code>textContent</code>, původní obsah značky bude odstraněn
a nahrazen novým, získaným převodem zadaného HTML na strom. Tato operace
patří k těm nejsilnějším, které nám DOM nabízí – ale je nutné pamatovat,
že s velkou mocí přichází také velká zodpovědnost. Neopatrné přiřazení
do <code>innerHTML</code> totiž může být <strong>zdrojem zranitelnosti
typu XSS</strong> (více se o tom dočteme v kapitole 6)!</p>
<h2 id="profíci-druhy-skriptů">Profíci: druhy skriptů</h2>
<p>HTML značku <code>&lt;script&gt;</code> můžeme použít jedním ze dvou
způsobů: buď ji naplníme kódem, nebo uvedeme atribut <code>src</code>
s odkazem na JavaScriptový soubor. Chování prohlížeče ale můžeme
ovlivnit ještě dalšími jejími atributy. Děláme to proto, abychom
ovlivnili, kdy prohlížeč skript <strong>stáhne</strong>, kdy prohlížeč
skript <strong>vykoná</strong> a co všechno je v daném skriptu
<strong>dovoleno</strong>.</p>
<p>Klientský JavaScript je, stejně jako HTML a CSS, zatížen břemenem
zpětné kompatibility. Je to jeho výhoda i prokletí. Výhoda proto, že náš
kód napsaný před dvaceti lety dnes funguje stejně jako tehdy a do
budoucna máme stejně pozitivní vyhlídky. Prokletí proto, že je velmi
obtížné do jazyka přinášet novinky a změny tak, aby se tím <em>nic
nerozbilo</em>. Prohlížeče kvůli tomu musí stále obsahovat implementaci
všeho možného, včetně technologií, které už dávno považujeme za
překonané.</p>
<p>Jeden mechanismus, který lze pro modernizaci použít, je zavedení
<em>nového druhu skriptů</em>. Tento krok se objevil naposledy po roce
2015, kdy JavaScript prošel pořádnou aktualizací. Namísto nové HTML
značky byla ovšem zavedena nová hodnota atributu <code>type</code>. Dnes
tak máme dva druhy skriptů:</p>
<ul>
<li><p><strong>klasické skripty</strong>, které atribut
<code>type</code> nemají (nebo mají, s historickou a zbytečnou hodnotou
<code>text/javascript</code>), a</p></li>
<li><p><strong>JS moduly</strong>, které mají atribut
<code>type=module</code>.</p></li>
</ul>
<p>Pojďme se na ně podívat detailněji.</p>
<h3 id="klasické-skripty">Klasické skripty</h3>
<p>Klasické skripty představují původní mechanismus spolupráce HTML
a JavaScriptu. Jejich funkce a globální proměnné jsou sdíleny napříč
všemi takovými skripty a není povoleno v nich používat některé moderní
syntaktické prvky jazyka (zejména direktivy <code>import</code>
a <code>export</code>, viz kapitolu 8).</p>
<p>Klasické skripty začne prohlížeč načítat, jakmile na ně v HTML
narazí. Přestane přitom dělat všechno ostatní, takže pokud stažení
klasického skriptu trvá dlouho, zcela to zablokuje proces načítání
a vykreslení HTML stránky. Tomuto chování lze předejít přidáním atributu
<code>async</code>: prohlížeč pak skript stahuje zároveň (paralelně) se
zpracováváním dalšího HTML.</p>
<p>Klasické skripty prohlížeč vykoná, jakmile je načte. Tomuto chování
lze předejít přidáním atributu <code>defer</code>: prohlížeč pak skript
vykoná až poté, co zpracuje celé HTML a vystaví celý strom stránky.</p>
<p>Je zbytečné kombinovat atributy <code>async</code>
i <code>defer</code> zároveň. Pokud má klasický skript atribut
<code>async</code>, je jeho atribut <code>defer</code> ignorován (bude
načten paralelně se zpracováním HTML a vykonán ihned po načtení).</p>
<h3 id="js-moduly">JS moduly</h3>
<p>Použitím atributu <code>type=module</code> říkáme, že chceme náš
skript zpracovat modernějším mechanismem. Dostaneme tak od prohlížeče
chování, které se časem ukázalo jako praktičtější (ale nemožné zavést
paušálně pro všechny skripty, kvůli zpětné kompatibilitě). Všechny
funkce a proměnné v JS modulu nejsou dostupné z jiných skriptů na
stránce; pro spolupráci je nutné využít direktivy <code>export</code>
a <code>import</code>. JS moduly jsou automaticky vykonávány ve
<em>striktním režimu</em> (koumáci se o něm mohou dočíst ve čtrnácté
bonusové kapitole).</p>
<p>JS moduly jsou automaticky zpracovávány způsobem <code>defer</code>,
tj. jejich načítání probíhá zároveň se zpracováním HTML a jejich
vykonávání nastane až po vytvoření stromu stránky. Pokud chceme JS modul
vykonat ihned po jeho načtení (tj. potenciálně dříve, než je strom
sestaven), můžeme mu přidat atribut <code>async</code>.</p>
<p>JS moduly s atributem <code>src</code> je nutné vydávat pomocí HTTP
(tj. pomocí webového serveru, nikoliv z adresy začínající na
<code>file://</code>). Jejich načítání podléhá mechanismu
<em>same-origin / CORS</em> (viz kapitolu 5).</p>
<h3 id="příliš-rychlý-skript">Příliš rychlý skript</h3>
<p>Výše uvedené možnosti se nám hodí mimo jiné v situaci, kdy narazíme
na problém způsobený skriptem, který je vykonáván příliš brzy. Typická
začátečnická chyba může vypadat například takto:</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode html"><code class="sourceCode html"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="dt">&lt;</span><span class="kw">script</span><span class="dt">&gt;</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> button <span class="op">=</span> <span class="bu">document</span><span class="op">.</span><span class="fu">querySelector</span>(<span class="st">&quot;button&quot;</span>)<span class="op">;</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>button<span class="op">.</span><span class="fu">addEventListener</span>(<span class="st">&quot;click&quot;</span><span class="op">,</span> <span class="op">...</span>)<span class="op">;</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="dt">&lt;/</span><span class="kw">script</span><span class="dt">&gt;</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a><span class="dt">&lt;</span><span class="kw">button</span><span class="dt">&gt;</span> Klikni! <span class="dt">&lt;</span><span class="kw">button</span><span class="dt">&gt;</span></span></code></pre></div>
<p>Poznáte, v čem je problém? Jedná se o <strong>klasický
skript</strong>, takže jeho načtení i vykonání proběhne přesně v tom
místě, kde je v HTML značka <code>&lt;script&gt;</code>. A až se
prohlížeč pokusí vykonat metodu <code>document.querySelector</code>, ve
stránce žádný prvek odpovídající selektoru nenajde. Že ho tam vidíme? My
možná ano, ale prohlížeč ještě ne: při zpracování HTML se zatím tak
daleko nedostal.</p>
<p>Pro tuto situaci existuje hned několik řešení, z kterých si můžeme
vybrat to, které nám bude nejvíce vyhovovat.</p>
<ol type="1">
<li><p>Odložení vykonání skriptu: <code>&lt;script defer&gt;</code> nebo
<code>&lt;script type=module&gt;</code></p></li>
<li><p>Přesun skriptu v rámci HTML:</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode html"><code class="sourceCode html"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="dt">&lt;</span><span class="kw">button</span><span class="dt">&gt;</span> Klikni! <span class="dt">&lt;/</span><span class="kw">button</span><span class="dt">&gt;</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="dt">&lt;</span><span class="kw">script</span><span class="dt">&gt;</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> button <span class="op">=</span> <span class="bu">document</span><span class="op">.</span><span class="fu">querySelector</span>(<span class="st">&quot;button&quot;</span>)<span class="op">;</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>button<span class="op">.</span><span class="fu">addEventListener</span>(<span class="st">&quot;click&quot;</span><span class="op">,</span> <span class="op">...</span>)<span class="op">;</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a><span class="dt">&lt;/</span><span class="kw">script</span><span class="dt">&gt;</span></span></code></pre></div></li>
<li><p>Umístění skriptu do funkce vykonané později:</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode html"><code class="sourceCode html"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="dt">&lt;</span><span class="kw">script</span><span class="dt">&gt;</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">go</span>() {</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> button <span class="op">=</span> <span class="bu">document</span><span class="op">.</span><span class="fu">querySelector</span>(<span class="st">&quot;button&quot;</span>)<span class="op">;</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>  button<span class="op">.</span><span class="fu">addEventListener</span>(<span class="st">&quot;click&quot;</span><span class="op">,</span> <span class="op">...</span>)<span class="op">;</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a><span class="bu">document</span><span class="op">.</span><span class="fu">addEventListener</span>(<span class="st">&quot;DOMContentLoaded&quot;</span><span class="op">,</span> go)<span class="op">;</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a><span class="dt">&lt;/</span><span class="kw">script</span><span class="dt">&gt;</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a><span class="dt">&lt;</span><span class="kw">button</span><span class="dt">&gt;</span> Klikni! <span class="dt">&lt;</span><span class="kw">button</span><span class="dt">&gt;</span></span></code></pre></div></li>
</ol>
<p>Poslední varianta dříve patřila mezi velmi oblíbené možnosti. Použitá
událost <code>DOMContentLoaded</code> odpovídá okamžiku, kdy prohlížeč
dokončil načítání HTML a sestavil strom stránky. Takovéto odložení
(vlastně stejné, jako atribut <code>defer</code>) je šikovné, ale
nezbaví nás problematického zablokování stránky během načítání
klasického skriptu. Vhodnější je proto použití prvního nebo druhého
řešení.</p>
<h1 id="pole-a-iterace">Pole a iterace</h1>
<h2 id="úloha-1">Úloha</h2>
<p>Kód z předchozí kapitoly se osvědčil! Rádi bychom jej nyní použili
i na další stránce, kde bude naráz vypsáno několik písní. Zkrácení
(a zobrazení pomocí tlačítka) je proto nutné provést na všech textech
písní, které se v dokumentu objeví.</p>
<h3 id="řešení-1">Řešení</h3>
<div class="sourceCode" id="cb13"><pre
class="sourceCode html"><code class="sourceCode html"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="co">&lt;!-- kapitola-3.html --&gt;</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="dt">&lt;</span><span class="kw">h2</span><span class="dt">&gt;</span>Mám styl Čendy<span class="dt">&lt;/</span><span class="kw">h2</span><span class="dt">&gt;</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="dt">&lt;</span><span class="kw">pre</span> <span class="er">class</span><span class="ot">=</span><span class="st">&quot;song&quot;</span><span class="dt">&gt;</span> ... <span class="dt">&lt;/</span><span class="kw">pre</span><span class="dt">&gt;</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a><span class="dt">&lt;</span><span class="kw">h2</span><span class="dt">&gt;</span>Hříšné bolero<span class="dt">&lt;/</span><span class="kw">h2</span><span class="dt">&gt;</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a><span class="dt">&lt;</span><span class="kw">pre</span> <span class="er">class</span><span class="ot">=</span><span class="st">&quot;song&quot;</span><span class="dt">&gt;</span> ... <span class="dt">&lt;/</span><span class="kw">pre</span><span class="dt">&gt;</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a><span class="dt">&lt;</span><span class="kw">script</span> <span class="er">src</span><span class="ot">=</span><span class="st">&quot;kapitola-3.js&quot;</span><span class="dt">&gt;&lt;/</span><span class="kw">script</span><span class="dt">&gt;</span></span></code></pre></div>
<div class="sourceCode" id="cb14"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="co">// kapitola-3.js</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> LIMIT <span class="op">=</span> <span class="dv">50</span><span class="op">;</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">shortenSong</span>(song) {</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> text <span class="op">=</span> song<span class="op">.</span><span class="at">textContent</span><span class="op">;</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> button <span class="op">=</span> <span class="bu">document</span><span class="op">.</span><span class="fu">createElement</span>(<span class="st">&quot;button&quot;</span>)<span class="op">;</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>  button<span class="op">.</span><span class="at">textContent</span> <span class="op">=</span> <span class="st">&quot;zobrazit celý text&quot;</span><span class="op">;</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>  song<span class="op">.</span><span class="fu">replaceChildren</span>(text<span class="op">.</span><span class="fu">substring</span>(<span class="dv">0</span><span class="op">,</span> LIMIT)<span class="op">,</span> <span class="st">&quot;…&quot;</span><span class="op">,</span> button)<span class="op">;</span></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">function</span> <span class="fu">showCompleteText</span>() {</span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>    song<span class="op">.</span><span class="at">textContent</span> <span class="op">=</span> text<span class="op">;</span></span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a>  button<span class="op">.</span><span class="fu">addEventListener</span>(<span class="st">&quot;click&quot;</span><span class="op">,</span> showCompleteText)<span class="op">;</span></span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> songs <span class="op">=</span> <span class="bu">document</span><span class="op">.</span><span class="fu">querySelectorAll</span>(<span class="st">&quot;.song&quot;</span>)<span class="op">;</span></span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (<span class="kw">let</span> i<span class="op">=</span><span class="dv">0</span><span class="op">;</span> i<span class="op">&lt;</span>songs<span class="op">.</span><span class="at">length</span><span class="op">;</span> i<span class="op">++</span>) {</span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true" tabindex="-1"></a>  <span class="fu">shortenSong</span>(songs[i])<span class="op">;</span></span>
<span id="cb14-20"><a href="#cb14-20" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Po zbytek knihy už budeme vždy uvažovat JavaScriptový kód oddělený od
HTML. Trochu se tím komplikuje možnost si jednoduše uvedená řešení
vyzkoušet, ale zase se jedná o přístup, který v praxi vídáme
nejčastěji.</p>
<p>Výše uvedené řešení je motivováno přímočarou úvahou: chceme vzít
hotový kód (z minulé kapitoly) a aplikovat jej opakovaně. Dopředu není
jisté, kolikrát to bude, protože náš výsledek by měl fungovat u stránky
se dvěma písněmi, stejně jako když jich tam bude padesát. V takovém
případě je logické sáhnout po nějaké formě <strong>cyklu</strong>.
JavaScript nabízí různé formy iterace (více o tom v podkapitole pro
zelenáče) a my můžeme použít hned tu nejsnazší – pomocí klíčového slova
<code>for</code> s iterační proměnnou. Tento zápis je známý z mnoha
jiných programovacích jazyků. Používáme v něm tzv. <em>iterační
proměnnou</em> (zde <code>i</code>), kterou nejprve nastavíme na nulu
a následně v každé iteraci zvýšíme o jedničku (operátor
<code>++</code>). To děláme tak dlouho, dokud je hodnota této proměnné
menší, než zadaný limit.</p>
<p>Naše data jsou dostupná v proměnné <code>songs</code>, pro jejíž
naplnění jsme zvolili metodu <code>document.querySelectorAll</code>.
Jedná se o hodnotu, jejíž datový typ se formálně nazývá <em>statický
NodeList</em>, tedy něco jako <em>posloupnost HTML uzlů</em>. V mnoha
ohledech bychom takovou proměnnou mohli považovat za pole (datový typ
zpravidla užívaný pro řady hodnot), ale pozor – JavaScriptové pole to
není. Nelze proto použít např. funkcionální iteraci (viz dále). Nám
ovšem stačí, když:</p>
<ol type="1">
<li><p>umíme ověřit, kolik má <code>songs</code> hodnot (pomocí
vlastnosti <code>length</code>),</p></li>
<li><p>dokážeme získat konkrétní N-tou položku z této posloupnosti
(pomocí operátoru hranatých závorek).</p></li>
</ol>
<p>Pro potřeby této ukázky kódu jsme použili selektor
<code>.song</code>, kterému vyhovují všechny HTML prvky, jejichž atribut
<code>class</code> obsahuje slovo <code>song</code>. To rozhodně není
jediný způsob, jak v dokumentu písně nalézt. Je to předmětem dohody mezi
autorem HTML a autorem skriptu; ve stránce musí být písně zapsány
takovým způsobem, aby je pak v JavaScriptu šlo všechny <em>najít</em>.
Kdybychom použili například selektor <code>pre</code>, je možné, že by
kód fungoval stejně dobře. Trochu bychom se tím ale vystavili riziku, že
do HTML stránky někdo následně vloží značku <code>&lt;pre&gt;</code>,
která ovšem vůbec nebude použitá k výpisu textu písně. I takovou bychom
pak naivně považovali za píseň a pokoušeli se její obsah zkrátit. Proto
bude šikovnější v HTML explicitně označit (atributem <code>class</code>)
jen ta správná místa, která si zaslouží zpracovat.</p>
<p>V každé iteraci nakonec zavoláme funkci <code>shortenSong</code>,
která je jen obalem kolem kódu z minulé kapitoly. Její zodpovědností je
zkrácení textu konkrétní písně a tvorba interaktivního tlačítka. Dochází
zde poprvé k situaci, kdy <em>definujeme funkci uvnitř jiné funkce</em>.
To je v JavaScriptu docela běžný postup a neměl by nás překvapit
(z minulé kapitoly si pamatujeme, že funkce je datový typ, takže její
vznik je vlastně jen vznik stejně pojmenované proměnné). Jen si musíme
dát pozor na to, abychom takové definice nevyužívali příliš hluboce
zanořené: dochází tím k velkému odsazení kódu, ke snížení čitelnosti
a také se tím komplikuje porozumění chování zanořených funkcí. Jejich
<em>scope</em> totiž neprakticky narůstá – povíme si o tom něco
v podkapitole pro profíky.</p>
<h3 id="co-jsme-se-naučili-1">Co jsme se naučili</h3>
<p>Po vyřešení druhé úlohy by měl čtenář chápat a ovládat:</p>
<ul>
<li><p>spolupráci mezi HTML a JS pomocí <code>querySelector</code>
a <code>querySelectorAll</code></p></li>
<li><p>zápis iterace s pomocnou proměnnou</p></li>
<li><p>definici funkce uvnitř funkce</p></li>
</ul>
<h2 id="zelenáči-anonymní-a-arrow-funkce">Zelenáči: anonymní a arrow
funkce</h2>
<p>Doposud jsme viděli funkce definované dvěma obdobnými způsoby:
kombinací klíčového slova <code>function</code> a jména. Vypadalo to
zhruba takto:</p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">scitani</span>(a<span class="op">,</span> b) { <span class="cf">return</span> a<span class="op">+</span>b }</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> odcitani <span class="op">=</span> <span class="kw">function</span>(a<span class="op">,</span> b) { <span class="cf">return</span> a<span class="op">-</span>b }</span></code></pre></div>
<p>Byť se tyto dva zápisy funkčně <em>trošinku</em> liší, můžeme je
považovat za prakticky identické. JavaScript nám ovšem dovoluje i další
formy definice funkcí. Jednou z nich je tzv. <em>anonymní funkce</em>,
která se od té normální liší pouze absencí jména. V ukázce s klikacím
tlačítkem bychom ji mohli použít takto:</p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>button<span class="op">.</span><span class="fu">addEventListener</span>(<span class="st">&quot;click&quot;</span><span class="op">,</span> <span class="kw">function</span>() {</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>  song<span class="op">.</span><span class="at">textContent</span> <span class="op">=</span> text<span class="op">;</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>})<span class="op">;</span></span></code></pre></div>
<p>Chování je stejné jako dříve. Protože však funkce nemá jméno, není
uložena v žádné proměnné. Nemůžeme se na ni proto odkázat ani ji
vykonat. Takový zápis je praktický přesně v těch místech, kde funkci
potřebujeme <em>jen předat</em> (jako např. druhý parametr
<code>addEventListener</code>). Neuvedením jména ušetříme trochu místa
a zároveň čtenáři naznačíme, že tato funkce je užitečná jen jako
posluchač události. Nechceme ji nikam ukládat, ani sami později odnikud
volat.</p>
<p>V roce 2015 došlo k značnému rozšíření možností JavaScriptu
a společně s tím přibyla další syntaxe pro definici funkcí. Namísto
slova <code>function</code> lze použít tzv. <strong>operátor tlusté
šipky <code>=&gt;</code></strong> a pomocí něj definovat funkci, které
se říká po anglicku <em>arrow function</em>:</p>
<div class="sourceCode" id="cb17"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> scitani <span class="op">=</span> (a<span class="op">,</span> b) <span class="kw">=&gt;</span> {</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> a<span class="op">+</span>b<span class="op">;</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Tento způsob vytváření funkcí má řadu odlišností od použití klíčového
slova <code>function</code>. Ty nejdůležitější jsou:</p>
<ul>
<li><p>Arrow funkce používají úspornější zápis.</p></li>
<li><p>Pokud má funkce přesně jeden parametr, nemusí se kolem něj psát
kulaté závorky.</p></li>
<li><p>Pokud funkce obsahuje jen jeden příkaz, pak se kolem těla nemusí
psát složené závorky a výsledek tohoto jednoho příkazu je z funkce
vrácen i bez použití klíčového slova <code>return</code>.</p></li>
<li><p>Uvnitř arrow funkce nefunguje (resp. funguje odlišně) klíčové
slovo <code>this</code> (viz kapitolu 8).</p></li>
</ul>
<p>Arrow funkce si mezi JavaScriptovými vývojáři získaly značnou oblibu,
a tak je v kódu potkáváme častěji a častěji. Za zmínku stojí, že je lze
používat taktéž jako anonymní funkce. Řešení třetí kapitoly bychom proto
mohli upravit pomocí anonymní arrow funkce takto:</p>
<div class="sourceCode" id="cb18"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>button<span class="op">.</span><span class="fu">addEventListener</span>(<span class="st">&quot;click&quot;</span><span class="op">,</span> () <span class="kw">=&gt;</span> song<span class="op">.</span><span class="at">textContent</span> <span class="op">=</span> text)<span class="op">;</span></span></code></pre></div>
<p>To je výrazné zkrácení, aniž by utrpěla čitelnost kódu.</p>
<h2 id="koumáci-druhy-iterací">Koumáci: druhy iterací</h2>
<p>Cyklus <code>for</code> s iterační proměnnou je jen jednou z celé
řady možností, jak v JavaScriptu opakovaně vykonávat potřebnou logiku.
Jeho charakteristickým rysem je, že pro jeho konstrukci vůbec
nepotřebujeme žádný pokročilejší datový typ. Kdybychom například chtěli
vypsat prvních deset čísel, mohli bychom:</p>
<div class="sourceCode" id="cb19"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (<span class="kw">let</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span> i<span class="op">&lt;=</span><span class="dv">10</span><span class="op">;</span> i<span class="op">++</span>) {</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>  <span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(i)<span class="op">;</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Tuto vlastnost obsahuje také druhý elementární cyklus
<code>while</code>:</p>
<div class="sourceCode" id="cb20"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> i<span class="op">=</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> (i <span class="op">&lt;=</span> <span class="dv">10</span>) {</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>  <span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(i)<span class="op">;</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>V obou případech stačí jedna číselná proměnná, nemusíme mít žádné
pole ani jinou datovou strukturu. Jakmile máme zpracovávaná data uložená
v nějaké složitější proměnné, můžeme uvažovat pokročilejší syntaxi pro
iteraci. Další v řadě je cyklus <code>for-in</code>:</p>
<div class="sourceCode" id="cb21"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> data <span class="op">=</span> {</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">name</span><span class="op">:</span> <span class="st">&quot;Jan&quot;</span><span class="op">,</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">age</span><span class="op">:</span> <span class="dv">42</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (<span class="kw">let</span> p <span class="kw">in</span> data) {</span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>  <span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(p)<span class="op">;</span>       <span class="co">// &quot;name&quot;, &quot;age&quot;</span></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>  <span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(data[p])  <span class="co">// &quot;Jan&quot;, 42</span></span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Pomocná proměnná <code>p</code> nabývá postupně hodnot všech
<em>klíčů</em> v iterovaném objektu. Pro použití této syntaxe proto
potřebujeme cokoliv, co odpovídá JavaScriptové definici
<em>objektu</em>. Zde se trochu rozcházíme s terminologií
objektově-orientovaného programování, kde slovo <em>objekt</em> značí
<em>instanci třídy</em>. V JavaScriptu se objektem nazývá každý datový
typ, který má <em>klíče</em> a jim odpovídající <em>hodnoty</em>.
Spadají sem pole, funkce, množiny, třídy i jejich instance. Zejména se
nám pak cyklus <code>for-in</code> hodí u proměnné <code>data</code>
z této ukázky; její datový typ se formálně nazývá <em>objekt ex
nihilo</em>, ale mnohem častěji mu říkáme <em>slovník</em> nebo
<em>záznam</em> (anglicky <em>dictionary</em> nebo <em>record</em>).</p>
<p>Ve slovníku ukládáme data jako dvojice klíč-hodnota, kde klíč je vždy
řetězec (i když kolem něj zpravidla nemusíme psát uvozovky) a hodnota je
libovolná. O slovnících a jejich schopnostech si více povíme v osmé
kapitole.</p>
<p>Protože JS pole je také objekt, nabízí se možnost iterovat proměnnou
typu pole také pomocí syntaxe <code>for-in</code>. Jeho klíče by pak
byly jednotlivé číselné indexy (hodnoty 0, 1, 2, …). Takový postup ovšem
nemůžeme vždy doporučit, protože v poli by se mohly objevit i další
klíče, které naše iterace neočekává (viz kapitolu 8). Pokud jsou naše
data uložena v opravdovém poli, je o něco lepší variantou
<strong>funkcionální iterace</strong>:</p>
<div class="sourceCode" id="cb22"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> todo <span class="op">=</span> [<span class="st">&quot;cvičit&quot;</span><span class="op">,</span> <span class="st">&quot;tančit&quot;</span><span class="op">,</span> <span class="st">&quot;dožít&quot;</span>]<span class="op">;</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">show</span>(task) {</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>  <span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(<span class="st">&quot;Je potřeba&quot;</span><span class="op">,</span> task)<span class="op">;</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>todo<span class="op">.</span><span class="fu">forEach</span>(show)<span class="op">;</span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a><span class="co">// varianta s anonymní funkcí</span></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>todo<span class="op">.</span><span class="fu">forEach</span>(<span class="kw">function</span>(task) {</span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>  <span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(<span class="st">&quot;Je potřeba&quot;</span><span class="op">,</span> task)<span class="op">;</span></span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a>})<span class="op">;</span></span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a><span class="co">// varianta s anonymní arrow funkcí</span></span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a>todo<span class="op">.</span><span class="fu">forEach</span>((task) <span class="kw">=&gt;</span> {</span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true" tabindex="-1"></a>  <span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(<span class="st">&quot;Je potřeba&quot;</span><span class="op">,</span> task)<span class="op">;</span></span>
<span id="cb22-16"><a href="#cb22-16" aria-hidden="true" tabindex="-1"></a>})<span class="op">;</span></span>
<span id="cb22-17"><a href="#cb22-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-18"><a href="#cb22-18" aria-hidden="true" tabindex="-1"></a><span class="co">// varianta se zkrácenou anonymní arrow funkcí</span></span>
<span id="cb22-19"><a href="#cb22-19" aria-hidden="true" tabindex="-1"></a>todo<span class="op">.</span><span class="fu">forEach</span>(task <span class="kw">=&gt;</span> <span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(<span class="st">&quot;Je potřeba&quot;</span><span class="op">,</span> task))<span class="op">;</span></span></code></pre></div>
<p>Jak to funguje? Koncept funkcionální iterace přichází z oblasti zvané
<em>funkcionální programování</em>, ve kterém už podle názvu hrají prim
funkce. Abychom mohli iterovat skrz pole, musíme definovat (zpravidla
malinkatou) iterační funkci, která je pak automaticky <strong>volána pro
každý prvek pole</strong>, tj. právě procházený prvek pole jí je předán
jako parametr. V první ukázce vytváříme pro větší čitelnost pojmenovanou
funkci <code>show</code>, v dalších ukázkách šetříme místo a funkce jsou
anonymní.</p>
<p>Pro nás je to druhé setkání s konceptem <em>předávání funkce jako
parametru</em> (první bylo u <code>addEventListener</code>).
V JavaScriptu je funkcionální iterace dostupná nejen prostřednictvím
metody <code>forEach</code>, ale i dalšími metodami (<code>map</code>,
<code>filter</code>, <code>reduce</code>, …). Více si o tom povíme
v kapitole 6. Ideálním partnerem pro funkcionální iteraci jsou arrow
funkce, jejichž úsporný zápis dobře vyrovnává funkcionální přístup, tj.
<em>velmi časté používání minimálních funkcí</em>.</p>
<p>Fanoušci funkcionální iterace jsou v tuto chvíli možná zaskočeni tím,
že v řešené úloze je proměnná <code>songs</code> typu <em>statický
NodeList</em>, tj. nejedná se o pole – nelze použít funkcionální
iteraci. Pokud chceme, můžeme si ovšem pole vyrobit funkcí
<code>Array.from</code> a naplnit ho daty z proměnné <code>songs</code>.
Pak už funkcionální iteraci nic nebrání:</p>
<div class="sourceCode" id="cb23"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> songs <span class="op">=</span> <span class="bu">document</span><span class="op">.</span><span class="fu">querySelectorAll</span>(<span class="st">&quot;.song&quot;</span>)<span class="op">;</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> songsArray <span class="op">=</span> <span class="bu">Array</span><span class="op">.</span><span class="fu">from</span>(songs)<span class="op">;</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>songsArray<span class="op">.</span><span class="fu">forEach</span>(shortenSong)<span class="op">;</span></span></code></pre></div>
<p>Na závěr této podkapitoly si ještě ukážeme poslední iterační
mechanismus, nazývaný <em>programovatelná iterace</em>. Jeho syntaxe
využívá konstrukci <code>for-of</code>:</p>
<div class="sourceCode" id="cb24"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> todo <span class="op">=</span> [<span class="st">&quot;cvičit&quot;</span><span class="op">,</span> <span class="st">&quot;tančit&quot;</span><span class="op">,</span> <span class="st">&quot;dožít&quot;</span>]<span class="op">;</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (<span class="kw">let</span> task <span class="kw">of</span> todo) {</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>  <span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(<span class="st">&quot;Je potřeba&quot;</span><span class="op">,</span> task)<span class="op">;</span></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Zápis připomíná syntaxi <code>for-in</code>, ale jedná se o velmi
odlišný systém. Při této formě iterace JavaScript opakovaně volá předem
domluvenou metodu objektu, který je uveden vpravo od klíčového slova
<code>of</code> (této domluvě se říká <em>iterační protokol</em>). Jejím
úkolem je <em>vrátit další položku</em>, která je následně přiřazena do
lokální proměnné vlevo od klíčového slova <code>of</code>. V praxi to
znamená, že počet cyklů a procházené hodnoty jsou řízeny výhradně
objektem, který je iterován. Programátorovi to dává možnost vytvořit
vlastní objekt se specializovanými schopnostmi iterace. Může to být
třeba objekt zastřešující textový soubor, který postupně vrací
jednotlivé řádky; nebo objekt odpovídající databázovému dotazu, který
v rámci iterace vrací získaná data. Implementace iteračního protokolu je
ovšem komplikovaná a dostaneme se k ní až v poslední čtrnácté
kapitole.</p>
<p>JavaScript poskytuje implementaci iteračního protokolu pro řadu
vestavěných objektů, abychom mohli cyklus <code>for-of</code> rovnou
použít bez většího úsilí. Zejména je k dispozici pro všechna pole a také
pro <em>NodeList</em>, který používáme v řešení úlohy třetí
kapitoly:</p>
<div class="sourceCode" id="cb25"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> songs <span class="op">=</span> <span class="bu">document</span><span class="op">.</span><span class="fu">querySelectorAll</span>(<span class="st">&quot;.song&quot;</span>)<span class="op">;</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (<span class="kw">let</span> song <span class="kw">of</span> songs) {</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">shortenSong</span>(song)<span class="op">;</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Shrňme jednotlivé varianty iterace spolu s jejich doporučeným
použitím:</p>
<ul>
<li><p>Cykly s pomocnou iterační proměnnou (<code>for</code>,
<code>while</code>): tam, kde chceme sami řídit, které položky
zpracujeme.</p></li>
<li><p>Cyklus <code>for-in</code>: tam, kde chceme procházet klíče
a/nebo hodnoty slovníku.</p></li>
<li><p>Funkcionální iterace <code>forEach</code>: pouze pole, případně
data, která lze na pole převést.</p></li>
<li><p>Cyklus <code>for-of</code>: tam, kde potřebujeme sami
naprogramovat iteraci, nebo se nám líbí možnost iterace většiny
složitějších datových typů.</p></li>
</ul>
<h2 id="profíci-scope-a-closure">Profíci: scope a closure</h2>
<p>Pojďme si vyjasnit a upřesnit otázku, ke které jsme zatím
přistupovali spíš nahodile: <strong>jaký je obor platnosti proměnných
v JavaScriptu</strong>? Intuitivně chápeme, že proměnná slouží jako
označení pro hodnotu uloženou v paměti. Jak dlouho ale proměnná (a jí
odpovídající paměť) existuje? Může se stát, že o hodnotu v ní uloženou
přijdeme, nebo se dokonce změní na jinou?</p>
<p>Na úvod této podkapitoly je dobré si zopakovat, že JavaScript je
jazyk, jehož paměť je spravovaná nepřímo, procesem zvaným <em>Garbage
Collection</em>. Pro programátora to znamená, že je v absolutní většině
případů odstíněn od manuální správy paměti. Prohlížeč ji za něj od
operačního systému získá, kdykoliv je to potřeba, a naopak uvolněna zpět
bude až teprve, když je to absolutně bezpečné (tj. když je jisté, že
v ní již nejsou žádná data, se kterými bychom chtěli pracovat). Garbage
collector (komponenta vestavěná v implementaci JavaScriptu) hlídá každou
proměnnou a paměť uvolní teprve tehdy, když k proměnné nevede žádná
cesta. Navíc je chytrý a paměť neuvolňuje ihned, ale až když je na to
vhodná chvíle (nebo když je větší množství paměti potřeba k něčemu
dalšímu). V tomto smyslu tedy nepotřebujeme žádné speciální
vědomosti.</p>
<p>Musíme ale rozumět tomu, co znamená zjednodušené konstatování
<em>když k proměnné nevede žádná cesta</em>. Při pohledu na proměnnou je
totiž nutné uvážit nejen její platnost <em>v prostoru</em> (tj. kde
v kódu ji můžeme používat), ale i <em>časovou</em> (kdy k takovému
použití může dojít).</p>
<p>Prostorová platnost proměnných se anglicky nazývá <em>scope</em> a je
definována podle několika pravidel ukotvených ve standardu jazyka.
Nejjednodušeji je můžeme shrnout tak, že proměnná platí od své definice
až po konec <em>bloku</em> (zavírací složenou závorku), ve které byla
definována. Podívejme se na krátkou ukázku:</p>
<div class="sourceCode" id="cb26"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> x <span class="op">=</span> <span class="dv">3</span><span class="op">;</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">scitani</span>(a<span class="op">,</span> b) {</span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> sum <span class="op">=</span> a<span class="op">+</span>b<span class="op">;</span></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (sum <span class="op">&gt;</span> <span class="dv">99</span>) {</span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> str <span class="op">=</span> <span class="st">&quot;Pozor s velkými čísly!&quot;</span><span class="op">;</span></span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>    <span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(str)<span class="op">;</span></span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> sum<span class="op">;</span></span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Proměnná <code>x</code> není definována v žádném bloku, takže platí
od své definice až do konce souboru. Říkáme o ní, že je
<em>globální</em>. Pokud je tento kód umístěn v JS modulu (viz předchozí
kapitolu), tak to není zcela pravda – v takovém případě je globální jen
pro kód v tomto modulu. Ostatní skripty a moduly s ní pracovat
nemohou.</p>
<p>Proměnná <code>sum</code> je definována ve funkci, takže platí od své
definice až do konce funkce <code>scitani</code>. Říkáme o ní, že je
<em>lokální</em>.</p>
<p>Proměnná <code>str</code> je definována v bloku kódu následujícím za
podmínkou. Její scope je jen do konce této podmínky; nemůžeme ji použít
například tam, kde vracíme hodnotu <code>sum</code>. Toto chování je
ovšem specifické pro proměnné definované klíčovým slovem
<code>let</code>, které se v JavaScriptu objevily až po roce 2015.
Starší kód používal klíčové slovo <code>var</code>, které vytváří scope
<em>do konce funkce</em>.</p>
<p>Pojďme se nyní vrátit ke kódu z řešení této kapitoly. V něm pro každý
nalezený text písně voláme funkci <code>shortenSong</code> definovanou
takto:</p>
<div class="sourceCode" id="cb27"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">shortenSong</span>(song) {</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> text <span class="op">=</span> song<span class="op">.</span><span class="at">textContent</span><span class="op">;</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> button <span class="op">=</span> <span class="bu">document</span><span class="op">.</span><span class="fu">createElement</span>(<span class="st">&quot;button&quot;</span>)<span class="op">;</span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>  button<span class="op">.</span><span class="at">textContent</span> <span class="op">=</span> <span class="st">&quot;zobrazit celý text&quot;</span><span class="op">;</span></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>  song<span class="op">.</span><span class="fu">replaceChildren</span>(text<span class="op">.</span><span class="fu">substring</span>(<span class="dv">0</span><span class="op">,</span> LIMIT)<span class="op">,</span> <span class="st">&quot;…&quot;</span><span class="op">,</span> button)<span class="op">;</span></span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">function</span> <span class="fu">showCompleteText</span>() {</span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a>    song<span class="op">.</span><span class="at">textContent</span> <span class="op">=</span> text<span class="op">;</span></span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb27-11"><a href="#cb27-11" aria-hidden="true" tabindex="-1"></a>  button<span class="op">.</span><span class="fu">addEventListener</span>(<span class="st">&quot;click&quot;</span><span class="op">,</span> showCompleteText)<span class="op">;</span></span>
<span id="cb27-12"><a href="#cb27-12" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Za zmínku stojí proměnná <code>song</code>. Je parametrem funkce,
takže se fakticky jedná o běžnou lokální proměnnou. Z minulého textu
víme, že její scope je do konce funkce <code>shortenSong</code>.
Všimněme si ale zajímavé odlišnosti: proměnnou <code>song</code>
využíváme i ve funkci <code>showCompleteText</code>, kterou následně
předáváme jako parametr pro <code>addEventListener</code>.</p>
<p>Tím se dostáváme k otázce časové platnosti proměnné. Neplatí totiž,
že dokončením vykonávání funkce <code>shortenSong</code> může proměnná
<code>song</code> zaniknout. Její scope již sice (v prostoru) skončil,
ale stále se může stát, že dojde k vykonání funkce
<code>showCompleteText</code>. V takovou chvíli budeme proměnnou
<code>song</code> potřebovat!</p>
<p>Nastala důležitá situace, které se říká <strong>uzávěra</strong>
(anglicky <em>closure</em>). To proto, že funkce
<code>showCompleteText</code> do svého scope <em>uzavírá</em> proměnnou
<code>song</code>. S touto proměnnou lze tedy pracovat kdekoliv uvnitř
dané funkce a zároveň i kdykoliv bude tuto funkci možné zavolat.</p>
<p>Použití uzávěr je běžné a užitečné, jistě na ně ještě narazíme. Může
mít ale dramatický dopad na životní cyklus našich proměnných. Jejich
uzavřením bráníme Garbage collectoru, aby uvolnil jimi zabranou paměť,
a zároveň se vystavujeme riziku, že uzavřená proměnná změní svoji
hodnotu dříve, než ji v uzavírající funkci využijeme. Třeba takto:</p>
<div class="sourceCode" id="cb28"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> buttons <span class="op">=</span> <span class="bu">document</span><span class="op">.</span><span class="fu">querySelectorAll</span>(<span class="st">&quot;button&quot;</span>)<span class="op">;</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> (i <span class="op">&lt;</span> buttons<span class="op">.</span><span class="at">length</span>) {</span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>  buttons[i]<span class="op">.</span><span class="fu">addEventListener</span>(<span class="st">&quot;click&quot;</span><span class="op">,</span> () <span class="kw">=&gt;</span> <span class="fu">alert</span>(i))<span class="op">;</span></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>  i<span class="op">++;</span></span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>V této ukázce bychom rádi, aby každé tlačítko po kliku ukázalo takové
číslo, kolikáté tlačítko to je. První tlačítko nulu, druhé jedničku…
Proměnná <code>i</code> je uzavřená do anonymní arrow funkce, předávané
jako druhý parametr <code>addEventListener</code>. Všechny tyto malé
funkce ovšem uzavírají <em>tu samou proměnnou</em>, takže po kliku na
libovolné tlačítko se vždy zobrazí ta samá hodnota. Bude to proměnná
<code>i</code>, která tou dobou nabývá hodnoty počtu všech tlačítek.</p>
<p>Co s tím? Typické řešení představuje tvorba proměnné s omezeným
scope, která bude specifická pro každou iteraci cyklu. Docílit toho
můžeme buď použitím cyklu
<code>for (let i=0; i&lt;buttons.length; i++)</code>, nebo dodatečnou
proměnnou:</p>
<div class="sourceCode" id="cb29"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> buttons <span class="op">=</span> <span class="bu">document</span><span class="op">.</span><span class="fu">querySelectorAll</span>(<span class="st">&quot;button&quot;</span>)<span class="op">;</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> (i <span class="op">&lt;</span> buttons<span class="op">.</span><span class="at">length</span>) {</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> j <span class="op">=</span> i<span class="op">;</span>  <span class="co">// v každé iteraci je to nová proměnná &quot;j&quot;</span></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>  buttons[j]<span class="op">.</span><span class="fu">addEventListener</span>(<span class="st">&quot;click&quot;</span><span class="op">,</span> () <span class="kw">=&gt;</span> <span class="fu">alert</span>(j))<span class="op">;</span></span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>  i<span class="op">++;</span></span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>A ještě jedno varování: používání uzávěr jde ruku v ruce se
zanořováním definic funkcí do sebe, někdy i v několika úrovních. Dochází
tím k odsazování a snižování čitelnosti kódu a také to znamená, že
chování vnitřních funkcí je pak ovlivňováno (uzavřenými) hodnotami,
které nemusí být při studiu kódu snadno a blízko vidět. Takovému
JavaScriptu bude výrazně obtížnější porozumět, než kdyby funkce své
chování ovlivňovaly výhradně pomocí parametrů.</p>
<h1 id="kontrola-formuláře">Kontrola formuláře</h1>
<h2 id="úloha-2">Úloha</h2>
<p>Vzpomínkový web o Karlu Gottovi je velmi populární a rádi bychom
s jeho uživateli a fanoušky vstoupili do bližšího kontaktu. Na konci
stránky chceme formulář, kde bude moci uživatel vložit svůj názor
a zanechat na sebe telefon či e-mail, abychom se na něj mohli případně
obrátit. Formulář by měl jít odeslat pouze při správně vyplněném e-mailu
či telefonním čísle.</p>
<h3 id="řešení-2">Řešení</h3>
<div class="sourceCode" id="cb30"><pre
class="sourceCode html"><code class="sourceCode html"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="co">&lt;!-- kapitola-4.html --&gt;</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a><span class="dt">&lt;</span><span class="kw">form</span><span class="dt">&gt;</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&lt;</span><span class="kw">h3</span><span class="dt">&gt;</span>Zanechejte nám vzkaz!<span class="dt">&lt;/</span><span class="kw">h3</span><span class="dt">&gt;</span></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&lt;</span><span class="kw">p</span><span class="dt">&gt;&lt;</span><span class="kw">textarea</span> <span class="er">name</span><span class="ot">=</span><span class="st">&quot;text&quot;</span><span class="dt">&gt;&lt;/</span><span class="kw">textarea</span><span class="dt">&gt;&lt;/</span><span class="kw">p</span><span class="dt">&gt;</span></span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&lt;</span><span class="kw">p</span><span class="dt">&gt;&lt;</span><span class="kw">label</span><span class="dt">&gt;</span></span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a>    Váš e-mail: <span class="dt">&lt;</span><span class="kw">input</span> <span class="er">type</span><span class="ot">=</span><span class="st">&quot;email&quot;</span> <span class="er">name</span><span class="ot">=</span><span class="st">&quot;email&quot;</span> <span class="dt">/&gt;</span></span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&lt;/</span><span class="kw">label</span><span class="dt">&gt;&lt;/</span><span class="kw">p</span><span class="dt">&gt;</span></span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&lt;</span><span class="kw">p</span><span class="dt">&gt;&lt;</span><span class="kw">label</span><span class="dt">&gt;</span></span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a>    nebo telefon: <span class="dt">&lt;</span><span class="kw">input</span> <span class="er">type</span><span class="ot">=</span><span class="st">&quot;tel&quot;</span> <span class="er">name</span><span class="ot">=</span><span class="st">&quot;tel&quot;</span> <span class="dt">/&gt;</span></span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&lt;/</span><span class="kw">label</span><span class="dt">&gt;&lt;/</span><span class="kw">p</span><span class="dt">&gt;</span></span>
<span id="cb30-11"><a href="#cb30-11" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&lt;</span><span class="kw">p</span><span class="dt">&gt;&lt;</span><span class="kw">input</span> <span class="er">type</span><span class="ot">=</span><span class="st">&quot;submit&quot;</span> <span class="er">value</span><span class="ot">=</span><span class="st">&quot;Poslat vzkaz&quot;</span> <span class="dt">/&gt;&lt;/</span><span class="kw">p</span><span class="dt">&gt;</span></span>
<span id="cb30-12"><a href="#cb30-12" aria-hidden="true" tabindex="-1"></a><span class="dt">&lt;/</span><span class="kw">form</span><span class="dt">&gt;</span></span>
<span id="cb30-13"><a href="#cb30-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-14"><a href="#cb30-14" aria-hidden="true" tabindex="-1"></a><span class="dt">&lt;</span><span class="kw">script</span> <span class="er">src</span><span class="ot">=</span><span class="st">&quot;kapitola-4.js&quot;</span><span class="dt">&gt;&lt;/</span><span class="kw">script</span><span class="dt">&gt;</span></span>
<span id="cb30-15"><a href="#cb30-15" aria-hidden="true" tabindex="-1"></a><span class="dt">&lt;</span><span class="kw">link</span> <span class="er">rel</span><span class="ot">=</span><span class="st">&quot;stylesheet&quot;</span> <span class="er">href</span><span class="ot">=</span><span class="st">&quot;kapitola-4.css&quot;</span> <span class="dt">/&gt;</span></span></code></pre></div>
<div class="sourceCode" id="cb31"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="co">// kapitola-4.js</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> form <span class="op">=</span> <span class="bu">document</span><span class="op">.</span><span class="fu">querySelector</span>(<span class="st">&quot;form&quot;</span>)<span class="op">;</span></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> email <span class="op">=</span> form<span class="op">.</span><span class="fu">querySelector</span>(<span class="st">&quot;[name=email]&quot;</span>)<span class="op">;</span></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> tel <span class="op">=</span> form<span class="op">.</span><span class="fu">querySelector</span>(<span class="st">&quot;[name=tel]&quot;</span>)<span class="op">;</span></span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> TEL_RE <span class="op">=</span> <span class="ss">/</span><span class="sc">^\+?\d{5,12}$</span><span class="ss">/</span><span class="op">;</span></span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">isEmpty</span>(input) {</span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> input<span class="op">.</span><span class="at">value</span><span class="op">.</span><span class="fu">trim</span>() <span class="op">==</span> <span class="st">&quot;&quot;</span><span class="op">;</span></span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb31-11"><a href="#cb31-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-12"><a href="#cb31-12" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">checkForm</span>(e) {</span>
<span id="cb31-13"><a href="#cb31-13" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (<span class="fu">isEmpty</span>(email) <span class="op">&amp;&amp;</span> <span class="fu">isEmpty</span>(tel)) {</span>
<span id="cb31-14"><a href="#cb31-14" aria-hidden="true" tabindex="-1"></a>    <span class="fu">alert</span>(<span class="st">&quot;Vyplňte e-mail nebo telefon&quot;</span>)<span class="op">;</span></span>
<span id="cb31-15"><a href="#cb31-15" aria-hidden="true" tabindex="-1"></a>    e<span class="op">.</span><span class="fu">preventDefault</span>()<span class="op">;</span></span>
<span id="cb31-16"><a href="#cb31-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span><span class="op">;</span></span>
<span id="cb31-17"><a href="#cb31-17" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb31-18"><a href="#cb31-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-19"><a href="#cb31-19" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (<span class="op">!</span><span class="fu">isEmpty</span>(tel)) {</span>
<span id="cb31-20"><a href="#cb31-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> t <span class="op">=</span> tel<span class="op">.</span><span class="at">value</span><span class="op">;</span></span>
<span id="cb31-21"><a href="#cb31-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (<span class="op">!</span>t<span class="op">.</span><span class="fu">match</span>(TEL_RE)) {</span>
<span id="cb31-22"><a href="#cb31-22" aria-hidden="true" tabindex="-1"></a>      tel<span class="op">.</span><span class="at">classList</span><span class="op">.</span><span class="fu">add</span>(<span class="st">&quot;error&quot;</span>)<span class="op">;</span></span>
<span id="cb31-23"><a href="#cb31-23" aria-hidden="true" tabindex="-1"></a>      e<span class="op">.</span><span class="fu">preventDefault</span>()<span class="op">;</span></span>
<span id="cb31-24"><a href="#cb31-24" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb31-25"><a href="#cb31-25" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb31-26"><a href="#cb31-26" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb31-27"><a href="#cb31-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-28"><a href="#cb31-28" aria-hidden="true" tabindex="-1"></a>form<span class="op">.</span><span class="fu">addEventListener</span>(<span class="st">&quot;submit&quot;</span><span class="op">,</span> checkForm)<span class="op">;</span></span></code></pre></div>
<p>První část řešení je opět fragment HTML dokumentu. Nebudeme se mu
věnovat příliš zevrubně, protože znalost HTML u čtenáře předpokládáme
a tato kniha se soustředí více na JavaScript. U formuláře pro
jednoduchost nejsou specifikovány atributy <code>method</code> ani
<code>action</code>, které by ve skutečnosti rozhodně chybět neměly
(jejich hodnoty ovšem pro náš kód nejsou podstatné). Popisky pro
jednotlivé značky <code>&lt;input&gt;</code> vkládáme do značek
<code>&lt;label&gt;</code> (a tyto dva spolu propojíme zanořením). Tím
jednak napomáháme přístupnosti dokumentu a jednak je pak kliknutím na
popisek možno aktivovat jemu odpovídající formulářové pole.</p>
<p>Pro zadávání e-mailu je vhodný
<code>&lt;input type="email"&gt;</code>, který sám od sebe kontroluje
korektní formát zadané adresy a zároveň na softwarové klávesnici
(v mobilních zařízeních) rovnou nabízí nezbytný znak zavináče. Stejně
tak pro zadávání telefonu se nabízí
<code>&lt;input type="tel"&gt;</code>, pro který se zobrazí klávesnice
číselná. Zde ovšem žádná kontrola vstupu sama od sebe neproběhne, a tak
ji budeme muset naimplementovat sami v JavaScriptu.</p>
<p>V tradiční úloze kontroly formulářových polí se pohybujeme na nejisté
hranici mezi JavaScriptem a HTML. Atributy <code>required</code>
a <code>pattern</code> nám dovolují definovat kontrolní podmínky přímo
v HTML stránce bez nutnosti JavaScriptu, ale jejich schopnosti nejsou
velké. HTML kontrola je prováděna jen pro konkrétní izolované pole (bez
vazby na ostatní položky), jsme velmi omezeni možností zobrazení textu
chyby a kontrolu můžeme specifikovat jen pomocí tzv. <em>regulárních
výrazů</em>. Proto ji použijeme pro e-mailové pole a to telefonní
zkontrolujeme pomocí JavaScriptu.</p>
<p>V něm nejprve na prvních třech řádcích používáme rozhraní DOM pro
získání důležitých prvků – formuláře a obou inputů. Metodě
<code>querySelector</code> tentokrát předáváme složitější (atributové)
selektory. Rozhodně to není jediný způsob; další možností by byl
například výběr pomocí atributu <code>type</code>. Následuje naše první
konstanta <code>TEL_RE</code>, ve které specifikujeme regulární výraz
pro telefonní číslo. Jedná se o jakýsi <em>vzor</em> nebo
<em>šablonu</em>, která speciálními znaky popisuje, jak má vypadat
platná hodnota. Za zmínku stojí, že regulární výrazy mají v JavaScriptu
vlastní datový typ a proměnné tohoto typu vznikají zápisem mezi dvě
dopředná lomítka. Ve složitějších případech je můžeme vyrábět také
funkcí <code>RegExp()</code>.</p>
<p>Jazyk a celý koncept regulárních výrazů převyšuje rozsah této knihy,
takže si jen v rychlosti vyložíme části našeho jednoduchého výrazu:</p>
<ul>
<li><p>Znaky <code>^</code> a <code>$</code> na začátku resp. konci
výrazu říkají, že tomuto vzoru musí vyhovovat celý text kontrolovaného
pole, tedy nikoliv jen nějaká podmnožina (kolem které by pak mohly být
nesouvisející neplatné znaky).</p></li>
<li><p>Zápis <code>\+?</code> určuje, že text smí začínat jedním znakem
plus (v telefonním čísle jde o tzv. mezinárodní volací kód).</p></li>
<li><p>Zápis <code>\d{5,12}</code> určuje, že zbytek textu má obsahovat
posloupnost pěti až dvanácti číslic.</p></li>
</ul>
<p>Nejedná se o univerzálně spolehlivou kontrolu telefonního čísla, ale
spíš o ilustraci toho, jak bychom mohli zhruba postupovat. Tuto
konstantu použijeme hned za chvíli, jakmile si nachystáme kontrolní
funkci.</p>
<p>V kódu se nám hodí funkce dvě: jedna pro ověření prázdnosti
formulářového pole (<code>isEmpty</code>) a jedna pro celou kontrolu
formuláře (<code>checkForm</code>). Hlavní kontrolní funkci pak předáme
jako parametr do <code>addEventListener</code>, neboť kontrolu chceme
provést až v důsledku nějaké události. V této úloze se jako událost
nabízí <code>submit</code>, tedy okamžik, kdy se uživatel chystá
formulář odeslat. Tato událost je vázána na HTML formulář, a tak funkci
<code>addEventListener</code> voláme jako metodu proměnné
<code>form</code>, do které jsme formulář přiřadili výše.</p>
<p>Zbývá nastudovat tělo funkce <code>checkForm</code>. Obsahuje dvě
kontroly, které odpovídají zadání úlohy. První kontrola prostě ověří, že
bylo vyplněno alespoň jedno pole. Využíváme zde pomocné funkce
<code>isEmpty</code>, která z předaného inputu vybere vyplněný text,
odstraní z něj případné přebytečné mezery na začátku a konci (metoda
<code>trim()</code>) a ověří, zda něco zbylo. Zvídavý čtenář si může
povšimnout, že v porovnání se zadáním používáme obrácenou logiku:
namísto testu <em>je nějaké pole vyplněné?</em> se ptáme <em>jsou obě
pole prázdná?</em> Vlastně tedy ověřujeme, zdali je formulář vyplněn
špatně. To nám dovoluje použít programátorský koncept nazvaný anglicky
<em>return early</em>: chceme přestat vykonávat funkci jakmile ověříme,
že to nemá smysl. Při nesprávném vyplnění zakončíme kód voláním
<code>e.preventDefault()</code>, k jehož vysvětlení se dostaneme za malý
okamžik.</p>
<p>Druhý test využívá regulárního výrazu z konstanty
<code>TEL_RE</code>, a pokud mu zadané telefonní číslo neodpovídá,
nastává opět chybový stav. Tentokrát neukážeme uživateli nehezký
<code>alert</code>, ale pokusíme se problém naznačit vizuálně –
například vyplněním políčka červenou barvou. Z JavaScriptu bychom sice
pomocí DOM mohli přímo ovlivňovat vzhledové atributy daného prvku, ale
takový postup je nepraktický. Těžko by se nám hluboko uvnitř JS souborů
hledalo, kde a jak se kterému poli nastavuje jaká barva, takže pro
definici vzhledu upřednostňujeme jazyk CSS. Proto raději volíme přístup,
kdy JavaScriptem měníme hodnotu atributu <code>class</code>, který
v HTML slouží právě k tomuto účelu. Označujeme pomocí něj prvky, které
se svými vlastnostmi nějak odlišují od ostatních, a chceme na ně
aplikovat specifická stylová pravidla. Fanoušci lososové barvy pak mohou
doplnit například následující CSS:</p>
<div class="sourceCode" id="cb32"><pre
class="sourceCode css"><code class="sourceCode css"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="co">/* kapitola-4.css */</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a><span class="fu">.error</span> { <span class="kw">background-color</span>: <span class="cn">salmon</span> }</span></code></pre></div>
<p>Z JavaScriptu ovšem nechceme nastavit atribut <code>class</code> na
novou hodnotu <code>error</code>, neboť tento atribut může mít hodnot
více (oddělených mezerami) a náš kód dopředu nemusí vědět, zdali a proč
už tam nějaké hodnoty jsou. Je proto praktičtější postupovat
<em>defenzivněji</em> a k existující hodnotě <code>class</code> jen něco
nového přidat. K takovému účelu nejlépe slouží objekt
<code>classList</code>, jehož metody dovolují k atributu
<code>class</code> přidávat další hodnoty či odebírat existující.</p>
<p>Poslední otázkou k vyřešení je metoda <code>e.preventDefault()</code>
volaná v obou dílčích kontrolách. Jedná se o tzv. <em>metodu objektu
události</em>, tedy logiku, která nám je k dispozici jen ve speciálních
chvilkách, konkrétně v průběhu zpracování nějaké události. Vzpomeňme si,
že náš současný kód (funkce <code>checkForm</code>) byl naplánován
k vykonání teprve tehdy, když se uživatel pokusí odeslat formulář.
Jakmile tato situace nastane, je v prohlížeči vytvořen <em>objekt
události</em>, který popisuje skutečnosti pro tuto událost relevantní.
Při vykonávání všech <em>posluchačů</em> dané události je pak objekt
události každému posluchači předán jako parametr.</p>
<p>V objektu události nalezneme řadu užitečných informací a také několik
metod. Ta nejdůležitější je <code>preventDefault</code>, nemá žádné
parametry, a pokud ji kterýkoliv posluchač vykoná, žádá tím prohlížeč,
aby <strong>na tuto událost po vykonání posluchačů dále
nereagoval</strong>. To je smysluplné jen u takových událostí, které
představují nějakou aktivitu pro prohlížeč samotný: může jít o událost
kliknutí na odkaz (způsobí navigaci), stisk klávesy ve formulářovém poli
(způsobí vložení znaku) nebo kliknutí na odesílací tlačítko (způsobí
odeslání formuláře). Když v našem kódu kontrola selže, voláním
<code>e.preventDefault()</code> zařídíme, aby nedošlo k odeslání
formuláře s neplatnými daty.</p>
<h3 id="co-jsme-se-naučili-2">Co jsme se naučili</h3>
<p>Po vyřešení třetí úlohy by měl čtenář chápat a ovládat:</p>
<ul>
<li><p>zamezení zpracování události metodou
<code>preventDefault</code></p></li>
<li><p>použití regulárního výrazu pro kontrolu textu</p></li>
<li><p>použití rozhraní <code>classList</code> pro snadnou úpravu HTML
atributu <code>class</code></p></li>
</ul>
<h2 id="zelenáči-další-druhy-událostí">Zelenáči: další druhy
událostí</h2>
<p>Svět DOM událostí je pestrý a nabízí nám nástroje k tvorbě
uživatelsky přívětivých stránek a aplikací. V řešených úlohách jsme se
zatím setkali se dvěma událostmi a jejich původci:</p>
<ul>
<li><p>Událost <code>click</code> odpovídající kliknutí myší (či prstem,
stylusem, …) na libovolný HTML prvek.</p></li>
<li><p>Událost <code>submit</code> odpovídající pokusu o odeslání
formuláře, nastávající jen na HTML formulářích. Tato událost může být
vyvolána různými způsoby; zejména to je kliknutí na odesílací tlačítko
nebo stisk klávesy Enter, pokud je aktivní některé formulářové
pole.</p></li>
</ul>
<p>V dokumentaci rozhraní DOM můžeme nalézt desítky dalších druhů
událostí. V kontextu kontroly formulářových polí připadají v úvahu
například tyto:</p>
<ul>
<li><p>Událost <code>focus</code> nastává na HTML prvku
<code>&lt;input&gt;</code>, jakmile tento začne být aktivní (uživatel do
něj klikne, nebo se do něj přesune klávesou Tab). Symetricky s tím
událost <code>blur</code> odpovídá ztrátě aktivity formulářového
pole.</p></li>
<li><p>Na formulářových polích vznikají události související
s klávesnicí. Při stisku klávesy je to <code>keydown</code>, při puštění
následně <code>keyup</code>.</p></li>
<li><p>Pokud nás nezajímá, jakým způsobem ke změně formulářového pole
došlo (klávesnicí, myší, vložením ze schránky, …), můžeme použít událost
<code>input</code>, která odpovídá libovolné úpravě daného
pole.</p></li>
</ul>
<p>Pro různé scénáře volíme různé události či jejich kombinace. Abychom
vzorové řešení vylepšili, můžeme políčko pro telefonní číslo
zkontrolovat dříve, než se uživatel pokusí formulář odeslat. Stisk každé
klávesy (případně jiná změna hodnoty) je ovšem zbytečně agresivní, neboť
bychom pak pole kontrolovali už od prvního zadaného znaku (a považovali
ho za nesprávně vyplněné, i když jej uživatel plánuje vyplnit správně).
Pro tento scénář je ideální událost <code>blur</code>, tedy opuštění
aktivního pole.</p>
<p>K tomu se nám bude hodit nová funkce a nový posluchač události:</p>
<div class="sourceCode" id="cb33"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">checkPhone</span>() {</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>tel<span class="op">.</span><span class="fu">addEventListener</span>(<span class="st">&quot;blur&quot;</span><span class="op">,</span> checkPhone)<span class="op">;</span></span></code></pre></div>
<p>Budeme v této funkci chtít volat <code>preventDefault</code>?
Nikoliv, protože na tuto událost prohlížeč sám nijak nereaguje, takže mu
nemáme co zakazovat. Proto bychom se patrně mohli obejít bez parametru
<code>e</code>, tj. bez objektu události (tak, jako v druhé a třetí
kapitole).</p>
<p>Tato kontrolní funkce nalezne telefonní pole v jednom ze tří
stavů:</p>
<ol type="1">
<li><p>prázdné → není potřeba kontrolovat, resp. pole neobsahuje
chybu</p></li>
<li><p>vyplněné špatně → je nutno označit jako chybné</p></li>
<li><p>vyplněné správně → je nutno neoznačovat jako chybné</p></li>
</ol>
<p>První implementace by mohla vypadat takto:</p>
<div class="sourceCode" id="cb34"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">checkPhone</span>() {</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (<span class="fu">isEmpty</span>(tel)) {</span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>    tel<span class="op">.</span><span class="at">classList</span><span class="op">.</span><span class="fu">remove</span>(<span class="st">&quot;error&quot;</span>)<span class="op">;</span></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>  } <span class="cf">else</span> {</span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> t <span class="op">=</span> tel<span class="op">.</span><span class="at">value</span><span class="op">;</span></span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (t<span class="op">.</span><span class="fu">match</span>(TEL_RE)) {</span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a>      tel<span class="op">.</span><span class="at">classList</span><span class="op">.</span><span class="fu">remove</span>(<span class="st">&quot;error&quot;</span>)<span class="op">;</span></span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true" tabindex="-1"></a>    } <span class="cf">else</span> {</span>
<span id="cb34-9"><a href="#cb34-9" aria-hidden="true" tabindex="-1"></a>      tel<span class="op">.</span><span class="at">classList</span><span class="op">.</span><span class="fu">add</span>(<span class="st">&quot;error&quot;</span>)<span class="op">;</span></span>
<span id="cb34-10"><a href="#cb34-10" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb34-11"><a href="#cb34-11" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb34-12"><a href="#cb34-12" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Kód je ovšem zbytečně košatý, zanořený a není snadné z něj rychle
a snadno odhadnout, za jakých podmínek je pole považováno za špatně či
správně vyplněné. Můžeme jej snadno zjednodušit za použití dvou
triků:</p>
<ul>
<li><p>Operátor <em>nebo</em> (znaky <code>||</code>) platí, jen když je
splněna libovolná ze dvou podmínek po jeho stranách. Tím dokážeme snadno
popsat podmínku ze zadání, že <em>telefonní pole je správné, když je
prázdné nebo vyplněné dle regulárního výrazu</em>.</p></li>
<li><p>Metoda <code>classList.toggle()</code> do atributu
<code>class</code> přidá danou hodnotu, pokud je její druhý parametr
pravdivý. V opačném případě danou hodnotu z <code>class</code>
odebere.</p></li>
</ul>
<p>Když už jsme v úpravách funkce <code>checkPhone</code>, všimneme si
také, že její chování je závislé na proměnné <code>tel</code>, jejíž
hodnota je ve funkci uzavřena (tento jev je detailněji vysvětlen
v podkapitole pro profíky v předchozí kapitole). Zde je prostor pro
zvýšení čitelnosti. V objektu události (který jsme plánovali ignorovat)
je totiž mimo jiné obsažen také HTML prvek, na kterém událost nastala.
Dozvíme se jej pomocí vlastnosti <code>e.target</code>. Proto můžeme
vrátit parametr <code>e</code>, a tím funkci explicitně dodat veškerá
data, která potřebuje:</p>
<div class="sourceCode" id="cb35"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">checkPhone</span>(e) {</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> tel <span class="op">=</span> e<span class="op">.</span><span class="at">target</span><span class="op">;</span></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> t <span class="op">=</span> tel<span class="op">.</span><span class="at">value</span><span class="op">;</span></span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> isOk <span class="op">=</span> <span class="fu">isEmpty</span>(tel) <span class="op">||</span> t<span class="op">.</span><span class="fu">match</span>(TEL_RE)<span class="op">;</span></span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a>  tel<span class="op">.</span><span class="at">classList</span><span class="op">.</span><span class="fu">toggle</span>(<span class="st">&quot;error&quot;</span><span class="op">,</span> <span class="op">!</span>isOk)<span class="op">;</span></span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a>tel<span class="op">.</span><span class="fu">addEventListener</span>(<span class="st">&quot;blur&quot;</span><span class="op">,</span> checkPhone)<span class="op">;</span></span></code></pre></div>
<p>Tato funkce <code>checkPhone</code> je kratší, bez zanoření, a také
ji lze použít pro zpracování více telefonních polí naráz! Ale ještě ji
musíme upravit jednou.</p>
<p>Pokud logiku kontroly telefonního pole přesuneme do
<code>checkPhone</code>, znamená to, že ji budeme chtít volat i ve
chvíli kontroly celého formuláře (funkce <code>checkForm</code>). Ale
naše současná <code>checkPhone</code> není dobře připravena k zavolání
z jiné funkce: nemá návratovou hodnotu a jako parametr očekává objekt
události vyvolané na telefonním inputu. Přidáme proto funkci návratovou
hodnotu a změníme její parametrizaci. Namísto objektu události jí
předáme rovnou input, se kterým má pracovat. Tím zůstane zachována její
obecnost a zároveň ji budeme moci použít nezávisle na tom, jaká událost
probíhá.</p>
<p>Následující rošáda je v JavaScriptu velmi běžná. Máme konkrétní
představu o tvaru naší funkce, ale zároveň ji chceme předat jako
posluchač, a proto musíme respektovat parametr s objektem události.
Vytvoříme si proto jako posluchač malinkou <strong>anonymní arrow
funkci</strong>, která tu opravdovou zavolá s upraveným parametrem:</p>
<div class="sourceCode" id="cb36"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">checkPhone</span>(tel) {</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> t <span class="op">=</span> tel<span class="op">.</span><span class="at">value</span><span class="op">;</span></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> isOk <span class="op">=</span> <span class="fu">isEmpty</span>(tel) <span class="op">||</span> t<span class="op">.</span><span class="fu">match</span>(TEL_RE)<span class="op">;</span></span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a>  tel<span class="op">.</span><span class="at">classList</span><span class="op">.</span><span class="fu">toggle</span>(<span class="st">&quot;error&quot;</span><span class="op">,</span> <span class="op">!</span>isOk)<span class="op">;</span></span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> isOk<span class="op">;</span></span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a>tel<span class="op">.</span><span class="fu">addEventListener</span>(<span class="st">&quot;blur&quot;</span><span class="op">,</span> e <span class="kw">=&gt;</span> <span class="fu">checkPhone</span>(e<span class="op">.</span><span class="at">target</span>))<span class="op">;</span></span></code></pre></div>
<p>Všimněme si, že v ukázce výše definujeme dvě různé funkce. Najdete
je?</p>
<p>Zbývá upravit zbytek kódu tak, abychom uvnitř kontroly celého
formuláře mohli znovupoužít naši dílčí kontrolní funkci
<code>checkPhone</code>. Celé vylepšené řešení této kapitoly pak vypadá
takto:</p>
<div class="sourceCode" id="cb37"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> form <span class="op">=</span> <span class="bu">document</span><span class="op">.</span><span class="fu">querySelector</span>(<span class="st">&quot;form&quot;</span>)<span class="op">;</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> email <span class="op">=</span> form<span class="op">.</span><span class="fu">querySelector</span>(<span class="st">&quot;[name=email]&quot;</span>)<span class="op">;</span></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> tel <span class="op">=</span> form<span class="op">.</span><span class="fu">querySelector</span>(<span class="st">&quot;[name=tel]&quot;</span>)<span class="op">;</span></span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> TEL_RE <span class="op">=</span> <span class="ss">/</span><span class="sc">^\+?\d{5,12}$</span><span class="ss">/</span><span class="op">;</span></span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">isEmpty</span>(input) {</span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> input<span class="op">.</span><span class="at">value</span><span class="op">.</span><span class="fu">trim</span>() <span class="op">==</span> <span class="st">&quot;&quot;</span><span class="op">;</span></span>
<span id="cb37-9"><a href="#cb37-9" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb37-10"><a href="#cb37-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-11"><a href="#cb37-11" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">checkPhone</span>(tel) {</span>
<span id="cb37-12"><a href="#cb37-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> t <span class="op">=</span> tel<span class="op">.</span><span class="at">value</span><span class="op">;</span></span>
<span id="cb37-13"><a href="#cb37-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> isOk <span class="op">=</span> <span class="fu">isEmpty</span>(tel) <span class="op">||</span> t<span class="op">.</span><span class="fu">match</span>(TEL_RE)<span class="op">;</span></span>
<span id="cb37-14"><a href="#cb37-14" aria-hidden="true" tabindex="-1"></a>  tel<span class="op">.</span><span class="at">classList</span><span class="op">.</span><span class="fu">toggle</span>(<span class="st">&quot;error&quot;</span><span class="op">,</span> <span class="op">!</span>isOk)<span class="op">;</span></span>
<span id="cb37-15"><a href="#cb37-15" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> isOk<span class="op">;</span></span>
<span id="cb37-16"><a href="#cb37-16" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb37-17"><a href="#cb37-17" aria-hidden="true" tabindex="-1"></a>tel<span class="op">.</span><span class="fu">addEventListener</span>(<span class="st">&quot;blur&quot;</span><span class="op">,</span> e <span class="kw">=&gt;</span> <span class="fu">checkPhone</span>(e<span class="op">.</span><span class="at">target</span>))<span class="op">;</span></span>
<span id="cb37-18"><a href="#cb37-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-19"><a href="#cb37-19" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">checkForm</span>(e) {</span>
<span id="cb37-20"><a href="#cb37-20" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (<span class="fu">isEmpty</span>(email) <span class="op">&amp;&amp;</span> <span class="fu">isEmpty</span>(tel)) {</span>
<span id="cb37-21"><a href="#cb37-21" aria-hidden="true" tabindex="-1"></a>    <span class="fu">alert</span>(<span class="st">&quot;Vyplňte e-mail nebo telefon&quot;</span>)<span class="op">;</span></span>
<span id="cb37-22"><a href="#cb37-22" aria-hidden="true" tabindex="-1"></a>    e<span class="op">.</span><span class="fu">preventDefault</span>()<span class="op">;</span></span>
<span id="cb37-23"><a href="#cb37-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span><span class="op">;</span></span>
<span id="cb37-24"><a href="#cb37-24" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb37-25"><a href="#cb37-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-26"><a href="#cb37-26" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (<span class="op">!</span><span class="fu">checkPhone</span>(tel)) {</span>
<span id="cb37-27"><a href="#cb37-27" aria-hidden="true" tabindex="-1"></a>    e<span class="op">.</span><span class="fu">preventDefault</span>()<span class="op">;</span></span>
<span id="cb37-28"><a href="#cb37-28" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb37-29"><a href="#cb37-29" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb37-30"><a href="#cb37-30" aria-hidden="true" tabindex="-1"></a>form<span class="op">.</span><span class="fu">addEventListener</span>(<span class="st">&quot;submit&quot;</span><span class="op">,</span> checkForm)<span class="op">;</span></span></code></pre></div>
<h2 id="koumáci-výjimky">Koumáci: výjimky</h2>
<p>Koncept práce s výjimkami (anglicky <em>exceptions</em>) je součástí
JavaScriptu po velmi dlouhou dobu (ve standardu se objevuje od konce
roku 1999). Je postavený stejným způsobem jako v celé řadě dalších
jazyků – C++, C#, Java, PHP, Python, Ruby a podobně. Čtenáři s výjimkami
již dříve seznámení tak naleznou základní syntaktické prvky (zejména
klíčová slova <code>try</code>, <code>catch</code> a <code>throw</code>)
v podobě, kterou znají. Pro ostatní je určena tato podkapitola, ve které
se naučíme nejen zpracovávat výjimky vyvolané mimo vlastní kód, ale
i vytvářet a využívat výjimky vlastní.</p>
<p>Na náš kód se často díváme jako na množství funkcí, které se navzájem
volají. Nezbytnou součástí volání je taktéž předávání hodnot: dovnitř
funkce pomocí parametrů, ven z funkce pomocí návratové hodnoty klíčovým
slovem <code>return</code>. Celá tato soustava funguje dobře za
předpokladu, že při volání funkce dochází ke shodě očekávání volaného
(dostane parametry, které potřebuje) a volajícího (z volané funkce jsou
vrácena správná data). Problém nastane ve chvíli, kdy některá funkce
není schopna požadavek splnit: buď dostala data, se kterými si neumí
poradit, nebo jí nějaká vnitřní překážka zabraňuje činnost vykonat
a potřebná data vrátit. Jak má taková funkce neschopnost <em>splnit
úkol</em> dát najevo?</p>
<p>Tradičním mechanismem je nechat funkci, aby vrátila nějakou
specifickou hodnotu, ze které volající pozná, že funkce nedokázala
vypočítat a vrátit to, co měla. Takové řešení funguje uspokojivě v celé
řadě programovacích jazyků, ale přináší jisté nepohodlí. Na první pohled
v něm vidíme tyto nedostatky:</p>
<ol type="1">
<li><p>Podle čeho z návratové hodnoty poznat, že se jedná o chybový
stav? Pokud má například funkce za úkol provést výpočet a vrátit
(libovolné) číslo, tak nelze použít žádnou konkrétní <em>chybovou
hodnotu</em> (nulu, minus jedničku), neboť by se mohlo jednat o korektní
výsledek.</p></li>
<li><p>Pokud funkce může kromě normálního výsledku vrátit i chybovou
hodnotu, znamená to, že každé místo v kódu, kde je volána, bude muset
umět na tuto chybovou hodnotu zareagovat. Pokud funkci voláme z více
míst, budeme muset každé takové místo vybavit speciální logikou na
zpracování chyby.</p></li>
</ol>
<p>Odpovědí na výše uvedené problémy je systém výjimek. Ten staví na
myšlence, že chybový stav ve funkci není signalizován konkrétní vrácenou
hodnotou, ale okamžitým pozastavením vykonávaného kódu, po kterém
následuje vyhledání nějaké vhodné komponenty, která je ochotna na tento
stav zareagovat a převzít řízení. Konkrétně, pokud naše vlastní funkce
potřebuje signalizovat neschopnost dokončit zadanou práci, použije
klíčové slovo <code>throw</code>. Tuto situaci, nazývanou <em>vyvolaná
výjimka</em> nebo <em>vyhozená výjimka</em>, můžeme následně zpracovat,
pokud je právě vykonávaný kód uvnitř bloku označeného klíčovým slovem
<code>try</code>. Dojde k posunu na odpovídající blok kódu označený
slovem <code>catch</code> (této části říkáme <em>chycená výjimka</em>)
a pokračuje se ve vykonávání. Pojďme se na to podívat na příkladu:</p>
<div class="sourceCode" id="cb38"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> tel <span class="op">=</span> form<span class="op">.</span><span class="fu">querySelector</span>(<span class="st">&quot;[name=tel]&quot;</span>)<span class="op">;</span></span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> TEL_RE <span class="op">=</span> <span class="ss">/</span><span class="sc">^\+?\d{5,12}$</span><span class="ss">/</span><span class="op">;</span></span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">isEmpty</span>(input) {</span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (<span class="op">!</span>input) { <span class="cf">throw</span> <span class="kw">new</span> <span class="bu">Error</span>(<span class="st">&quot;No input available&quot;</span>)<span class="op">;</span> }</span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> input<span class="op">.</span><span class="at">value</span><span class="op">.</span><span class="fu">trim</span>() <span class="op">==</span> <span class="st">&quot;&quot;</span><span class="op">;</span></span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb38-8"><a href="#cb38-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-9"><a href="#cb38-9" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">checkPhone</span>(tel) {</span>
<span id="cb38-10"><a href="#cb38-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> t <span class="op">=</span> tel<span class="op">.</span><span class="at">value</span><span class="op">;</span></span>
<span id="cb38-11"><a href="#cb38-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> isOk <span class="op">=</span> <span class="fu">isEmpty</span>(tel) <span class="op">||</span> t<span class="op">.</span><span class="fu">match</span>(TEL_RE)<span class="op">;</span></span>
<span id="cb38-12"><a href="#cb38-12" aria-hidden="true" tabindex="-1"></a>  tel<span class="op">.</span><span class="at">classList</span><span class="op">.</span><span class="fu">toggle</span>(<span class="st">&quot;error&quot;</span><span class="op">,</span> <span class="op">!</span>isOk)<span class="op">;</span></span>
<span id="cb38-13"><a href="#cb38-13" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> isOk<span class="op">;</span></span>
<span id="cb38-14"><a href="#cb38-14" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb38-15"><a href="#cb38-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-16"><a href="#cb38-16" aria-hidden="true" tabindex="-1"></a><span class="cf">try</span> {</span>
<span id="cb38-17"><a href="#cb38-17" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> isOk <span class="op">=</span> <span class="fu">checkPhone</span>(tel)<span class="op">;</span></span>
<span id="cb38-18"><a href="#cb38-18" aria-hidden="true" tabindex="-1"></a>  <span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(isOk)<span class="op">;</span></span>
<span id="cb38-19"><a href="#cb38-19" aria-hidden="true" tabindex="-1"></a>} <span class="cf">catch</span> (e) {</span>
<span id="cb38-20"><a href="#cb38-20" aria-hidden="true" tabindex="-1"></a>  <span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(e<span class="op">.</span><span class="at">message</span>)<span class="op">;</span></span>
<span id="cb38-21"><a href="#cb38-21" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Úplně na konci ukázky je vidět uzavření volání funkce
<code>checkPhone</code> do konstrukce <code>try-catch</code>. Odpovídá
to intuitivní představě <em>budeme vykonávat první kus kódu, a když se
to nepodaří, budeme pokračovat jiným kusem kódu</em>. Pokud by
kupříkladu uvnitř funkce <code>checkPhone</code> došlo k vyvolání
výjimky, řádek <code>console.log(isOk)</code> se nevykoná a namísto toho
se vypíše <code>console.log(e)</code>. V proměnné <code>e</code> pak
nalezneme tu hodnotu, která byla vyvolána (tj. výjimku).</p>
<p>Co ještě stojí za povšimnutí:</p>
<ul>
<li><p>Blok <code>try-catch</code> může zachytit mnoho různých výjimek.
V našem kódu vyvoláváme jen jednu (uvnitř funkce <code>isEmpty</code>),
ale interpret JavaScriptu sám od sebe dokáže výjimek vyvolat celou řadu.
Pokud například v dokumentu nebude žádný prvek vyhovující selektoru,
bude proměnná <code>tel</code> nabývat hodnoty <code>null</code>.
Výjimka tak bude vyvolána již na prvním řádku funkce
<code>checkPhone</code> (neboť hodnota <code>null</code> nemá vlastnost
<code>value</code>). Obdobně pokud použitému selektoru bude vyhovovat
HTML prvek, který není <code>&lt;input&gt;</code>, nastane další výjimka
při přístupu k <code>input.value.trim</code> (neboť
<code>input.value</code> bude <code>undefined</code>, a tím pádem nebude
mít vlastnost <code>trim</code>).</p></li>
<li><p>Chycení výjimky lze provést <em>daleko</em> od místa, kde byla
vyvolána. V této ukázce je do bloku <code>try-catch</code> zabalena
funkce <code>checkPhone</code>, ale vznik výjimek očekáváme až teprve ve
funkci <code>isEmpty</code>. Z toho je vidět, že zodpovědnost za
zpracování výjimky neleží na tom, kdo funkci přímo volá (porovnejme
s druhou výhradou vůči návratovým hodnotám výše).</p></li>
<li><p>Hodnotu vyvolané výjimky píšeme vpravo od klíčového slova
<code>throw</code>. Je pak k dispozici jako lokální proměnná v bloku
<code>catch</code> a používáme ji jako nositel informace o tom, jaký
problém nastal. Smíme použít zcela libovolnou JavaScriptovou hodnotu,
ale bývá obvyklé používat objekty typu <code>Error</code> (jako na
ukázce) nebo jejich podtřídy. Tyto jsou vybaveny textovým popisem
problému, které je dostupný ve vlastnosti <code>message</code>.</p></li>
</ul>
<p>Používání výjimek může být užitečné, nicméně pro četnost a konkrétní
realizaci nejsou stanovena žádná pravidla. Je tak na naší vlastní
zkušenosti a úvaze, které všechny situace považujeme za vhodné kandidáty
pro obalení do bloku <code>try-catch</code>. Při kontrole formulářových
polí může nastat řada situací, při kterých chceme odeslání formuláře
zamezit. Jednou z alternativ k současnému řešení může být právě
vyvolávání výjimek pro nesprávně vyplněná pole. Kód z právě řešené úlohy
by s využitím výjimek vypadal třeba takto:</p>
<div class="sourceCode" id="cb39"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> form <span class="op">=</span> <span class="bu">document</span><span class="op">.</span><span class="fu">querySelector</span>(<span class="st">&quot;form&quot;</span>)<span class="op">;</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> email <span class="op">=</span> form<span class="op">.</span><span class="fu">querySelector</span>(<span class="st">&quot;[name=email]&quot;</span>)<span class="op">;</span></span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> tel <span class="op">=</span> form<span class="op">.</span><span class="fu">querySelector</span>(<span class="st">&quot;[name=tel]&quot;</span>)<span class="op">;</span></span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> TEL_RE <span class="op">=</span> <span class="ss">/</span><span class="sc">^\+?\d{5,12}$</span><span class="ss">/</span><span class="op">;</span></span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">checkEmpty</span>(email<span class="op">,</span> tel) {</span>
<span id="cb39-8"><a href="#cb39-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> emailValue <span class="op">=</span> email<span class="op">.</span><span class="at">value</span><span class="op">.</span><span class="fu">trim</span>()<span class="op">;</span></span>
<span id="cb39-9"><a href="#cb39-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> telValue <span class="op">=</span> tel<span class="op">.</span><span class="at">value</span><span class="op">.</span><span class="fu">trim</span>()<span class="op">;</span></span>
<span id="cb39-10"><a href="#cb39-10" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (emailValue <span class="op">==</span> <span class="st">&quot;&quot;</span> <span class="op">&amp;&amp;</span> telValue <span class="op">==</span> <span class="st">&quot;&quot;</span>) {</span>
<span id="cb39-11"><a href="#cb39-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">throw</span> <span class="kw">new</span> <span class="bu">Error</span>(<span class="st">&quot;Vyplňte e-mail nebo telefon&quot;</span>)<span class="op">;</span></span>
<span id="cb39-12"><a href="#cb39-12" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb39-13"><a href="#cb39-13" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb39-14"><a href="#cb39-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-15"><a href="#cb39-15" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">checkPhone</span>(input) {</span>
<span id="cb39-16"><a href="#cb39-16" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (<span class="op">!</span>input<span class="op">.</span><span class="at">value</span><span class="op">.</span><span class="fu">match</span>(TEL_RE)) {</span>
<span id="cb39-17"><a href="#cb39-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">throw</span> <span class="kw">new</span> <span class="bu">Error</span>(<span class="st">&quot;Špatně vyplněný telefon&quot;</span>)<span class="op">;</span></span>
<span id="cb39-18"><a href="#cb39-18" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb39-19"><a href="#cb39-19" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb39-20"><a href="#cb39-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-21"><a href="#cb39-21" aria-hidden="true" tabindex="-1"></a>tel<span class="op">.</span><span class="fu">addEventListener</span>(<span class="st">&quot;blur&quot;</span><span class="op">,</span> e <span class="kw">=&gt;</span> {</span>
<span id="cb39-22"><a href="#cb39-22" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> tel <span class="op">=</span> e<span class="op">.</span><span class="at">target</span><span class="op">;</span></span>
<span id="cb39-23"><a href="#cb39-23" aria-hidden="true" tabindex="-1"></a>  tel<span class="op">.</span><span class="at">classList</span><span class="op">.</span><span class="fu">remove</span>(<span class="st">&quot;error&quot;</span>)<span class="op">;</span></span>
<span id="cb39-24"><a href="#cb39-24" aria-hidden="true" tabindex="-1"></a>  <span class="cf">try</span> {</span>
<span id="cb39-25"><a href="#cb39-25" aria-hidden="true" tabindex="-1"></a>    <span class="fu">checkPhone</span>(e<span class="op">.</span><span class="at">target</span>)<span class="op">;</span></span>
<span id="cb39-26"><a href="#cb39-26" aria-hidden="true" tabindex="-1"></a>  } <span class="cf">catch</span> (err) {</span>
<span id="cb39-27"><a href="#cb39-27" aria-hidden="true" tabindex="-1"></a>    tel<span class="op">.</span><span class="at">classList</span><span class="op">.</span><span class="fu">add</span>(<span class="st">&quot;error&quot;</span>)<span class="op">;</span></span>
<span id="cb39-28"><a href="#cb39-28" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb39-29"><a href="#cb39-29" aria-hidden="true" tabindex="-1"></a>})<span class="op">;</span></span>
<span id="cb39-30"><a href="#cb39-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-31"><a href="#cb39-31" aria-hidden="true" tabindex="-1"></a>form<span class="op">.</span><span class="fu">addEventListener</span>(<span class="st">&quot;submit&quot;</span><span class="op">,</span> e <span class="kw">=&gt;</span> {</span>
<span id="cb39-32"><a href="#cb39-32" aria-hidden="true" tabindex="-1"></a>  <span class="cf">try</span> {</span>
<span id="cb39-33"><a href="#cb39-33" aria-hidden="true" tabindex="-1"></a>    <span class="fu">checkEmpty</span>(email<span class="op">,</span> tel)<span class="op">;</span></span>
<span id="cb39-34"><a href="#cb39-34" aria-hidden="true" tabindex="-1"></a>    <span class="fu">checkPhone</span>(tel)<span class="op">;</span></span>
<span id="cb39-35"><a href="#cb39-35" aria-hidden="true" tabindex="-1"></a>  } <span class="cf">catch</span> (err) {</span>
<span id="cb39-36"><a href="#cb39-36" aria-hidden="true" tabindex="-1"></a>    e<span class="op">.</span><span class="fu">preventDefault</span>()<span class="op">;</span></span>
<span id="cb39-37"><a href="#cb39-37" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb39-38"><a href="#cb39-38" aria-hidden="true" tabindex="-1"></a>})<span class="op">;</span></span></code></pre></div>
<p>Poslední část práce s výjimkami je klíčové slovo
<code>finally</code>, jehož použití je volitelné. Pokud chceme, můžeme
k částem <code>try</code> a <code>catch</code> přidat ještě třetí blok
kódu uvozený slovem <code>finally</code>. Tento bude vykonán v obou
případech, tj. buď po úspěšném provedení části <code>try</code>, nebo po
vykonání části <code>catch</code> v rámci zachycení výjimky. Blok
<code>finally</code> se tak podobá kódu, který následuje mimo sekci
<code>try-catch</code>, s jedním důležitým rozdílem: bude proveden,
i pokud se v <code>try</code> nebo <code>catch</code> objeví klíčové
slovo <code>return</code>.</p>
<p>Představme si například formulář s odesílacím tlačítkem. Pokud by
jeho kontrola trvala dlouho (více o tom v následující kapitole),
nervózní uživatel by mohl na tlačítko klikat opakovaně. Proto budeme
chtít po odeslání tlačítko zneaktivnit a teprve po dokončení kontroly
jej opět aktivovat. K tomu můžeme využít blok <code>finally</code>:</p>
<div class="sourceCode" id="cb40"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">onSubmit</span>(e) {</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>  e<span class="op">.</span><span class="fu">preventDefault</span>()<span class="op">;</span></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> button <span class="op">=</span> e<span class="op">.</span><span class="at">target</span><span class="op">.</span><span class="fu">querySelector</span>(<span class="st">&quot;[type=submit]&quot;</span>)<span class="op">;</span></span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a>  button<span class="op">.</span><span class="at">disabled</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">try</span> {</span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a>    <span class="fu">checkForm</span>(e<span class="op">.</span><span class="at">target</span>)<span class="op">;</span></span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true" tabindex="-1"></a>  } <span class="cf">catch</span> (e) {</span>
<span id="cb40-8"><a href="#cb40-8" aria-hidden="true" tabindex="-1"></a>    <span class="fu">alert</span>(e<span class="op">.</span><span class="at">message</span>)<span class="op">;</span></span>
<span id="cb40-9"><a href="#cb40-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span><span class="op">;</span></span>
<span id="cb40-10"><a href="#cb40-10" aria-hidden="true" tabindex="-1"></a>  } <span class="cf">finally</span> {</span>
<span id="cb40-11"><a href="#cb40-11" aria-hidden="true" tabindex="-1"></a>    button<span class="op">.</span><span class="at">disabled</span> <span class="op">=</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb40-12"><a href="#cb40-12" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb40-13"><a href="#cb40-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-14"><a href="#cb40-14" aria-hidden="true" tabindex="-1"></a>  <span class="fu">sendDataToServer</span>()<span class="op">;</span></span>
<span id="cb40-15"><a href="#cb40-15" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>V této ukázce bychom v rámci odeslání formuláře rádi poslali získaná
data na server vlastní funkcí. Je jasné, že to budeme dělat, jen pokud
při kontrole nenastane výjimka – proto je blok <code>catch</code>
ukončen příkazem <code>return</code>. Ale i v takové situaci potřebujeme
po dokončení kontroly tlačítko učinit aktivním. Proto tento kód umístíme
do bloku <code>finally</code> a máme zajištěno, že bude vykonán za všech
okolností.</p>
<h2 id="profíci-zpožděná-kontrola-při-psaní">Profíci: zpožděná kontrola
při psaní</h2>
<p>Doposud jsme v této kapitole potkali dvě události vhodné pro kontrolu
formuláře: <code>submit</code> (pokus o odeslání formuláře)
a <code>blur</code> (opuštění dříve aktivního pole). Pojďme se podívat,
zdali by v některé situaci dávalo smysl provádět kontrolu ještě dříve.
Proč? Aby měl uživatel pokud možno co nejrychlejší zpětnou vazbu ohledně
správnosti vyplnění.</p>
<p>V podkapitole pro začátečníky je zmíněna událost <code>input</code>,
která vzniká při každé změně hodnoty formulářového pole. Je jasné, že
tímto způsobem můžeme formulář kontrolovat opravdu s minimálním
zpožděním za uživatelem. Zároveň je to ale příliš agresivní forma
kontroly. Na vzorovém políčku s telefonním číslem vidíme, že pokud
bychom jej ověřovali takto často, budeme uživatele zbytečně stresovat,
i pokud plánuje vyplnit docela správný telefon. Do prázdného pole musí
totiž napsat alespoň pět číslic, než bude naše kontrolní funkce
spokojena, takže první čtyři budou považovány za chybu. Teprve po pátém
stisku klávesy začneme pole považovat za korektně vyplněné. Pokud se
uživatel podívá na monitor dříve, uvidí informaci o chybě a bude po
právu zmatený.</p>
<p>Pro takový scénář neexistuje žádná DOM událost, která by odpovídala
situaci <em>uživatel již napsal hodnotu a neplánuje ji dále měnit</em>.
S trochou JavaScriptu ji ale dokážeme poznat sami. Stačí naši úlohu
trochu přeformulovat: potřebujeme poznat, kdy se hodnota pole už nějakou
dobu nezměnila. Jakmile tato zůstala stejná po nějaký čas, můžeme
předpokládat, že uživatel již dopsal (a je čas na kontrolu). Takové
strategii se anglicky říká <strong>debounce</strong> a můžeme se s ní
setkat i mimo prostředí webových stránek.</p>
<p>Jak na to? V klientském JavaScriptu existuje funkce
<code>setTimeout</code> dovolující vykonat zadaný kód po uplynutí
nějakého časového intervalu. První návrh řešení by tedy mohl vypadat
takto:</p>
<div class="sourceCode" id="cb41"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> DEBOUNCE <span class="op">=</span> <span class="dv">500</span><span class="op">;</span></span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">checkPhone</span>() {</span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a>  <span class="co">// stejná, jako v podkapitole pro začátečníky</span></span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">onInput</span>() {</span>
<span id="cb41-8"><a href="#cb41-8" aria-hidden="true" tabindex="-1"></a>  <span class="pp">setTimeout</span>(checkInput<span class="op">,</span> DEBOUNCE)<span class="op">;</span></span>
<span id="cb41-9"><a href="#cb41-9" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb41-10"><a href="#cb41-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-11"><a href="#cb41-11" aria-hidden="true" tabindex="-1"></a>tel<span class="op">.</span><span class="fu">addEventListener</span>(<span class="st">&quot;input&quot;</span><span class="op">,</span> onInput)<span class="op">;</span></span></code></pre></div>
<p>Funkce <code>setTimeout</code> funguje podobně jako
<code>addEventListener</code>. Musíme jí dát nějakou funkci k odloženému
spuštění a také čas, za který má být vykonána. Čas jsme uložili do
konstanty <code>DEBOUNCE</code> (udává se v milisekundách). Kód výše
tedy nebude kontrolovat pole ihned po každém stisku – kontrolní funkce
se spustí až půl vteřiny od změny políčka.</p>
<p>Zkušené oko profíka ovšem vidí, že takhle to fungovat rozhodně
nebude. Jakmile uživatel začne psát, každý stisk klávesy
<em>naplánuje</em> jedno vykonání kontrolní funkce. Tento proces sice
začne se zpožděním půl vteřiny, ale poté se vrátíme k původnímu
problému, kdy uživatel během psaní vidí pole označené jako špatně
vyplněné. Nesplnili jsme totiž podmínku, že kontrolu provedeme, jen
pokud se hodnota od okamžiku naplánování nezměnila.</p>
<p>Odpovědí na tento problém je funkce <code>clearTimeout</code>. Pomocí
ní můžeme vzít zpět dříve naplánované zpožděné vykonání funkce. Naše
strategie tedy bude následující:</p>
<ol type="1">
<li><p>při změně pole naplánujeme kontrolu;</p></li>
<li><p>pokud v čase mezi změnou a kontrolou nastane další změna, první
kontrolu zrušíme a naplánujeme další.</p></li>
</ol>
<p>Abychom mohli funkci <code>clearTimeout</code> použít, musíme si
nejprve uložit návratovou hodnotu dřívějšího volání
<code>setTimeout</code>. Ta slouží jako jakýsi klíč, pomocí kterého
můžeme odložené vykonání zrušit. Zmiňovaná návratová hodnota je číslo,
ale protože ji použijeme jen pro předání do <code>clearTimeout</code>,
tak nás její datový typ vlastně vůbec nemusí zajímat. Pojďme nyní kód
rozšířit o rušení dříve naplánovaných kontrol:</p>
<div class="sourceCode" id="cb42"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> DEBOUNCE <span class="op">=</span> <span class="dv">500</span><span class="op">;</span></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> timeout<span class="op">;</span>  <span class="co">// identifikace právě naplánované kontroly</span></span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">onInput</span>() {</span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (timeout) {</span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a>    <span class="pp">clearTimeout</span>(timeout)<span class="op">;</span></span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb42-8"><a href="#cb42-8" aria-hidden="true" tabindex="-1"></a>  timeout <span class="op">=</span> <span class="pp">setTimeout</span>(checkInput<span class="op">,</span> DEBOUNCE)<span class="op">;</span></span>
<span id="cb42-9"><a href="#cb42-9" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb42-10"><a href="#cb42-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-11"><a href="#cb42-11" aria-hidden="true" tabindex="-1"></a>tel<span class="op">.</span><span class="fu">addEventListener</span>(<span class="st">&quot;input&quot;</span><span class="op">,</span> onInput)<span class="op">;</span></span></code></pre></div>
<p>Proměnná <code>timeout</code> zde hraje roli hlídacího psa, který
zařídí, že naplánovanou kontrolu můžeme mít maximálně jednu. Pokud již
nějakou máme (podmínka <code>if</code>), nejdříve ji zrušíme a teprve
poté naplánujeme další.</p>
<p>Na konci podkapitoly pojďme ještě vyjasnit případné otázky, které
mohou profíka při pohledu na tento kód napadnout.</p>
<ul>
<li><p>Pokud je návratová hodnota <code>setTimeout</code> číslo, může to
být i nula? Pokud ano, pak je náš kód nekorektní. Kdybychom od funkce
<code>setTimeout</code> dostali nulu, nebude při příští události splněna
podmínka a my naplánujeme další kontrolu bez zrušení té předchozí.
Naštěstí se to nestane, neboť <code>setTimeout</code> vrací jen kladná
čísla.</p></li>
<li><p>Představme si scénář, kdy uživatel stiskne klávesu, počká jednu
vteřinu a pak ji stiskne podruhé. Náš kód naplánuje kontrolu (proměnná
<code>timeout</code> se nastaví), za půl vteřiny ji vykoná (to je dobře)
a po dalším stisku … dojde k volání <code>clearTimeout</code>? Ano,
protože <code>timeout</code> v sobě stále drží identifikaci již vykonané
zpožděné kontroly. Nic špatného se nestane, neboť funkce
<code>clearTimeout</code> u již proběhlého timeoutu prostě nic neudělá.
Je to nicméně zbytečné volání a programátorská intuice nám možná radí,
že bychom mu měli předejít. Řešením by pak bylo ve funkci
<code>checkInput</code> proměnnou <code>timeout</code> vyprázdnit
(nastavit třeba na nulu nebo <code>undefined</code>).</p></li>
<li><p>Jak by to vypadalo, kdybychom tímto způsobem chtěli kontrolovat
více položek? Narážíme na skutečnost, že <code>timeout</code> je
globální proměnná, takže kdybychom s ní chtěli pracovat z více
posluchačů, mohlo by dojít k problémům. Co s tím? Nabízí se dvě hlavní
kategorie řešení. Buď timeouty ukládat do složitější datové struktury
(pole či slovníku), nebo pro každou formulářovou položku vyrobit vlastní
<code>timeout</code> pomocí uzávěry. Kód by pak mohl vypadat zhruba
takto:</p>
<div class="sourceCode" id="cb43"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> DEBOUNCE <span class="op">=</span> <span class="dv">500</span><span class="op">;</span></span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">debounceInput</span>(tel) {</span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> timeout<span class="op">;</span></span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-6"><a href="#cb43-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">function</span> <span class="fu">onInput</span>() {</span>
<span id="cb43-7"><a href="#cb43-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (timeout) {</span>
<span id="cb43-8"><a href="#cb43-8" aria-hidden="true" tabindex="-1"></a>      <span class="pp">clearTimeout</span>(timeout)<span class="op">;</span></span>
<span id="cb43-9"><a href="#cb43-9" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb43-10"><a href="#cb43-10" aria-hidden="true" tabindex="-1"></a>    timeout <span class="op">=</span> <span class="pp">setTimeout</span>(checkInput<span class="op">,</span> DEBOUNCE)<span class="op">;</span></span>
<span id="cb43-11"><a href="#cb43-11" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb43-12"><a href="#cb43-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-13"><a href="#cb43-13" aria-hidden="true" tabindex="-1"></a>  tel<span class="op">.</span><span class="fu">addEventListener</span>(<span class="st">&quot;input&quot;</span><span class="op">,</span> onInput)<span class="op">;</span></span>
<span id="cb43-14"><a href="#cb43-14" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb43-15"><a href="#cb43-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-16"><a href="#cb43-16" aria-hidden="true" tabindex="-1"></a><span class="fu">debounceInput</span>(tel1)<span class="op">;</span></span>
<span id="cb43-17"><a href="#cb43-17" aria-hidden="true" tabindex="-1"></a><span class="fu">debounceInput</span>(tel2)<span class="op">;</span></span>
<span id="cb43-18"><a href="#cb43-18" aria-hidden="true" tabindex="-1"></a><span class="fu">debounceInput</span>(tel3)<span class="op">;</span></span></code></pre></div></li>
</ul>
<h1 id="http-na-pozadí">HTTP na pozadí</h1>
<h2 id="úloha-3">Úloha</h2>
<p>Pro hudební fanoušky nyní chystáme webovou službu, ve které budou
moci sdílet své kulturní zážitky. Bude přístupná jen registrovaným
uživatelům, kterých očekáváme velké množství. Při registraci si vyberou
uživatelské jméno a heslo; těmito údaji se budou následně přihlašovat.
S ohledem ná plánovaný zájem je nutné uživatele v průběhu procesu
registrace zavčasu varovat, pokud je jimi zvolené uživatelské jméno již
zabráno někým jiným. Za tímto účelem jsme nechali vytvořit
<strong>backendové JSON HTTP API</strong>, které je nutno využít.</p>
<h3 id="řešení-3">Řešení</h3>
<p>U této úlohy si napřed musíme ujasnit, co se po nás vlastně chce.
V textu zadání se objevuje řada zkratek a méně zkušený čtenář by se mohl
zaleknout. Naštěstí nejde o nic složitého.</p>
<p>Podstatou úlohy je opět kontrola formuláře. Tentokrát ale není možné
jen pomocí JavaScriptu rozhodnout, zdali je požadované uživatelské jméno
dostupné. K tomu bychom museli v rámci webové stránky znát veškerá
zaregistrovaná jména, což určitě nechceme (dle slov zadání jich bude
veliké množství) ani nemůžeme (tím bychom je prozradili každému
kolemjdoucímu). Proto nezbývá, než testované uživatelské jméno poslat po
síti na server, který má k dispozici databázi uživatelů a o existenci
může rozhodnout. Co víc, pokud bude jméno zabrané, dokáže vyprodukovat
dostupnou alternativu.</p>
<p>Komunikace po síti je ve světě webových stránek v 99 % případů
realizována protokolem HTTP. Se serverovou stranou tedy budeme
komunikovat tímto způsobem; v zadání se dále píše, že data dostaneme ve
formátu JSON. To je jednoduchý, užitečný a poměrně praktický způsob, jak
zapsat libovolně komplexní data tak, aby se snadno zpracovávala
v JavaScriptu (resp. dnes už víceméně v libovolném dalším jazyce).
Poslední použitá zkratka je API – anglicky <em>Application Programming
Interface</em>. Tím se myslí, že existuje dohoda o tom, jak mají vypadat
data přenášená od klienta na server a stejně tak jak má vypadat odpověď
od serveru. Při opravdovém programování bychom se na konkrétní tvar API
šli zeptat backendového programátora (případně si jej přečetli
v dokumentaci, nebo jej dokonce sami navrhli). V této testovací úloze
budiž naše API takovéto:</p>
<ol type="1">
<li><p>data odesílaná na server budou realizována HTTP požadavkem
poslaným na adresu <code>/username-check?username=...</code></p></li>
<li><p>pokud je uživatelské jméno volné k registraci, server odpoví daty
ve formátu JSON:</p>
<div class="sourceCode" id="cb44"><pre
class="sourceCode json"><code class="sourceCode json"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="fu">{</span></span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&quot;available&quot;</span><span class="fu">:</span> <span class="kw">true</span></span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a><span class="fu">}</span></span></code></pre></div></li>
<li><p>pokud je uživatelské jméno zabrané, server odpoví daty ve formátu
JSON:</p>
<div class="sourceCode" id="cb45"><pre
class="sourceCode json"><code class="sourceCode json"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="fu">{</span></span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&quot;available&quot;</span><span class="fu">:</span> <span class="kw">false</span><span class="fu">,</span></span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&quot;suggested&quot;</span><span class="fu">:</span> <span class="st">&quot;navrzene-jmeno&quot;</span></span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a><span class="fu">}</span></span></code></pre></div></li>
</ol>
<p>S takto upřesněným zadáním se již můžeme podívat, jak lze danou úlohu
vzorově vyřešit.</p>
<div class="sourceCode" id="cb46"><pre
class="sourceCode html"><code class="sourceCode html"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="co">&lt;!-- kapitola-5.html --&gt;</span></span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a><span class="dt">&lt;</span><span class="kw">form</span><span class="dt">&gt;</span></span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&lt;</span><span class="kw">h3</span><span class="dt">&gt;</span>Registrujte se!<span class="dt">&lt;/</span><span class="kw">h3</span><span class="dt">&gt;</span></span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&lt;</span><span class="kw">p</span><span class="dt">&gt;&lt;</span><span class="kw">label</span><span class="dt">&gt;</span></span>
<span id="cb46-5"><a href="#cb46-5" aria-hidden="true" tabindex="-1"></a>    Uživatelské jméno: <span class="dt">&lt;</span><span class="kw">input</span> <span class="er">type</span><span class="ot">=</span><span class="st">&quot;text&quot;</span> <span class="er">name</span><span class="ot">=</span><span class="st">&quot;username&quot;</span> <span class="dt">/&gt;</span></span>
<span id="cb46-6"><a href="#cb46-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&lt;/</span><span class="kw">label</span><span class="dt">&gt;&lt;/</span><span class="kw">p</span><span class="dt">&gt;</span></span>
<span id="cb46-7"><a href="#cb46-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&lt;</span><span class="kw">p</span><span class="dt">&gt;&lt;</span><span class="kw">label</span><span class="dt">&gt;</span></span>
<span id="cb46-8"><a href="#cb46-8" aria-hidden="true" tabindex="-1"></a>    Heslo: <span class="dt">&lt;</span><span class="kw">input</span> <span class="er">type</span><span class="ot">=</span><span class="st">&quot;password&quot;</span> <span class="er">name</span><span class="ot">=</span><span class="st">&quot;password&quot;</span> <span class="dt">/&gt;</span></span>
<span id="cb46-9"><a href="#cb46-9" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&lt;/</span><span class="kw">label</span><span class="dt">&gt;&lt;/</span><span class="kw">p</span><span class="dt">&gt;</span></span>
<span id="cb46-10"><a href="#cb46-10" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&lt;</span><span class="kw">p</span><span class="dt">&gt;&lt;</span><span class="kw">input</span> <span class="er">type</span><span class="ot">=</span><span class="st">&quot;submit&quot;</span> <span class="er">value</span><span class="ot">=</span><span class="st">&quot;Vytvořit účet&quot;</span> <span class="dt">/&gt;&lt;/</span><span class="kw">p</span><span class="dt">&gt;</span></span>
<span id="cb46-11"><a href="#cb46-11" aria-hidden="true" tabindex="-1"></a><span class="dt">&lt;/</span><span class="kw">form</span><span class="dt">&gt;</span></span>
<span id="cb46-12"><a href="#cb46-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-13"><a href="#cb46-13" aria-hidden="true" tabindex="-1"></a><span class="dt">&lt;</span><span class="kw">script</span> <span class="er">src</span><span class="ot">=</span><span class="st">&quot;kapitola-5.js&quot;</span><span class="dt">&gt;&lt;/</span><span class="kw">script</span><span class="dt">&gt;</span></span></code></pre></div>
<div class="sourceCode" id="cb47"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="co">// kapitola-5.js</span></span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">getError</span>() {</span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> username<span class="op">.</span><span class="at">labels</span>[<span class="dv">0</span>]<span class="op">.</span><span class="fu">querySelector</span>(<span class="st">&quot;.error&quot;</span>)<span class="op">;</span></span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-6"><a href="#cb47-6" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">hideError</span>() {</span>
<span id="cb47-7"><a href="#cb47-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> error <span class="op">=</span> <span class="fu">getError</span>()<span class="op">;</span></span>
<span id="cb47-8"><a href="#cb47-8" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (error) { error<span class="op">.</span><span class="fu">remove</span>()<span class="op">;</span> }</span>
<span id="cb47-9"><a href="#cb47-9" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb47-10"><a href="#cb47-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-11"><a href="#cb47-11" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">showError</span>(suggested) {</span>
<span id="cb47-12"><a href="#cb47-12" aria-hidden="true" tabindex="-1"></a>  <span class="fu">hideError</span>()<span class="op">;</span></span>
<span id="cb47-13"><a href="#cb47-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> error <span class="op">=</span> <span class="bu">document</span><span class="op">.</span><span class="fu">createElement</span>(<span class="st">&quot;div&quot;</span>)<span class="op">;</span></span>
<span id="cb47-14"><a href="#cb47-14" aria-hidden="true" tabindex="-1"></a>  error<span class="op">.</span><span class="at">className</span> <span class="op">=</span> <span class="st">&quot;error&quot;</span><span class="op">;</span></span>
<span id="cb47-15"><a href="#cb47-15" aria-hidden="true" tabindex="-1"></a>  error<span class="op">.</span><span class="at">textContent</span> <span class="op">=</span> <span class="vs">`Jméno je zabráno, zkuste třeba &quot;</span><span class="sc">${</span>suggested<span class="sc">}</span><span class="vs">&quot;`</span><span class="op">;</span></span>
<span id="cb47-16"><a href="#cb47-16" aria-hidden="true" tabindex="-1"></a>  username<span class="op">.</span><span class="at">labels</span>[<span class="dv">0</span>]<span class="op">.</span><span class="fu">append</span>(error)<span class="op">;</span></span>
<span id="cb47-17"><a href="#cb47-17" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb47-18"><a href="#cb47-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-19"><a href="#cb47-19" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">onLoad</span>(e) {</span>
<span id="cb47-20"><a href="#cb47-20" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> data <span class="op">=</span> e<span class="op">.</span><span class="at">target</span><span class="op">.</span><span class="at">response</span><span class="op">;</span></span>
<span id="cb47-21"><a href="#cb47-21" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (data<span class="op">.</span><span class="at">available</span>) {</span>
<span id="cb47-22"><a href="#cb47-22" aria-hidden="true" tabindex="-1"></a>    <span class="fu">hideError</span>()<span class="op">;</span></span>
<span id="cb47-23"><a href="#cb47-23" aria-hidden="true" tabindex="-1"></a>  } <span class="cf">else</span> {</span>
<span id="cb47-24"><a href="#cb47-24" aria-hidden="true" tabindex="-1"></a>    <span class="fu">showError</span>(data<span class="op">.</span><span class="at">suggested</span>)<span class="op">;</span></span>
<span id="cb47-25"><a href="#cb47-25" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb47-26"><a href="#cb47-26" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb47-27"><a href="#cb47-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-28"><a href="#cb47-28" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">checkUsername</span>() {</span>
<span id="cb47-29"><a href="#cb47-29" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> xhr <span class="op">=</span> <span class="kw">new</span> <span class="bu">XMLHttpRequest</span>()<span class="op">;</span></span>
<span id="cb47-30"><a href="#cb47-30" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> u <span class="op">=</span> <span class="pp">encodeURIComponent</span>(username<span class="op">.</span><span class="at">value</span>)<span class="op">;</span></span>
<span id="cb47-31"><a href="#cb47-31" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> url <span class="op">=</span> <span class="vs">`/check-username?username=</span><span class="sc">${</span>u<span class="sc">}</span><span class="vs">`</span><span class="op">;</span></span>
<span id="cb47-32"><a href="#cb47-32" aria-hidden="true" tabindex="-1"></a>  xhr<span class="op">.</span><span class="at">responseType</span> <span class="op">=</span> <span class="st">&quot;json&quot;</span><span class="op">;</span></span>
<span id="cb47-33"><a href="#cb47-33" aria-hidden="true" tabindex="-1"></a>  xhr<span class="op">.</span><span class="fu">open</span>(<span class="st">&quot;GET&quot;</span><span class="op">,</span> url)<span class="op">;</span></span>
<span id="cb47-34"><a href="#cb47-34" aria-hidden="true" tabindex="-1"></a>  xhr<span class="op">.</span><span class="fu">send</span>()<span class="op">;</span></span>
<span id="cb47-35"><a href="#cb47-35" aria-hidden="true" tabindex="-1"></a>  xhr<span class="op">.</span><span class="fu">addEventListener</span>(<span class="st">&quot;load&quot;</span><span class="op">,</span> onLoad)<span class="op">;</span></span>
<span id="cb47-36"><a href="#cb47-36" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb47-37"><a href="#cb47-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-38"><a href="#cb47-38" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> username <span class="op">=</span> <span class="bu">document</span><span class="op">.</span><span class="fu">querySelector</span>(<span class="st">&quot;[name=username]&quot;</span>)<span class="op">;</span></span>
<span id="cb47-39"><a href="#cb47-39" aria-hidden="true" tabindex="-1"></a>username<span class="op">.</span><span class="fu">addEventListener</span>(<span class="st">&quot;blur&quot;</span><span class="op">,</span> checkUsername)<span class="op">;</span></span></code></pre></div>
<p>V tomto řešení jsme použili větší množství funkcí. Pro snazší
pochopení se na ně podíváme od konce, protože v takovém pořadí budou
volány.</p>
<p>Poslední dva řádky zařídí přidání posluchače události
<code>blur</code> (seznámili jsme se s ní v minulé podkapitole pro
zelenáče), profíci by zde možná použili kontrolu během psaní pomocí
události <code>input</code>. Staráme se pouze o pole
<code>username</code>, zbytek HTML formuláře je uveden jen pro
úplnost.</p>
<p>Funkce <code>checkUsername</code> představuje první část kontroly.
Potřebujeme v ní vykonat HTTP požadavek. V klientském JavaScriptu jsou
za tímto účelem dostupné dvě funkce: starší <code>XMLHttpRequest</code>
(často zkracována na <code>XHR</code>) a novější <code>fetch</code>. My
si zatím předvedeme XHR, na fetch narazíme později v šesté kapitole.
Nenecháme se zastrašit dlouhým názvem s pochybnou velikostí písmen;
tento objekt pochází z doby, kdy se po síti data často přenášela ve
formátu XML. To dnes tolik neplatí a <code>XMLHttpRequest</code> rádi
použijeme na přenos dat ve formátu jiném (např. JSON).</p>
<p>Proměnná <code>xhr</code> zastřešuje naplánovaný HTTP požadavek.
Nejprve mu musíme v souladu s použitým API nastavit adresu. Její
součástí je hodnota získaná z formulářového pole (proč? protože musíme
serveru sdělit, jaké že jméno se uživatel pokouší zaregistrovat).
K sestavení výsledného URL jsme použili dva triky:</p>
<ol type="1">
<li><p>Funkce <code>encodeURIComponent</code> upraví zadaný řetězec tak,
aby bylo bezpečné jej použít jako hodnotu v <em>URL query stringu</em>,
tj. v části webové adresy za otazníkem. Data v tomto prostoru používají
speciální syntaxi postavenou mj. na znacích <code>=</code>
a <code>&amp;</code>. Pokud by se takové znaky náhodou (nebo dokonce
úmyslně – pamatujme, že někteří uživatelé jsou poťouchlí) nacházely
v <code>username.value</code>, rozbilo by to strukturu výsledné adresy.
Proto tyto problémové znaky nejprve pomocí
<code>encodeURIComponent</code> převedeme na jejich bezpečnější
zápis.</p></li>
<li><p>Proměnnou <code>url</code> definujeme jako řetězec ohraničený
dvojicí <em>zpětných apostrofů</em> (anglicky <em>backtick</em>). Jedná
se o méně obvyklý znak, který se na anglické klávesnici nachází nalevo
od jedničky. Tyto řetězce mají v JavaScriptu speciální funkcionalitu:
pokud se v nich objeví znak dolaru a složené závorky, je tato
posloupnost nahrazena hodnotou uvnitř závorek. Jedná se o ideální
způsob, jak kombinovat více řetězců nebo doplňovat proměnné hodnoty na
místa v pevně definovaných šablonách. Proto se těmto řetězcům říká
<em>template literals</em>.</p></li>
</ol>
<p>Jakmile máme nachystáno cílové URL, dokončíme konfiguraci proměnné
<code>xhr</code> v těchto krocích:</p>
<ul>
<li><p>Vlastnost <code>responseType</code> říká, v jakém datovém typu
očekáváme odpověď od serveru. Výchozí hodnota <code>"text"</code> je
vhodná pro přenos textových dat; náš backend vrací data strukturovaná
pomocí JSON. Pokud budou data skutečně v tomto formátu, XMLHttpRequest
je rovnou převede na JavaScriptový slovník.</p></li>
<li><p>Metoda <code>open</code> určuje použitou HTTP metodu a cílové
URL.</p></li>
<li><p>Metoda <code>send</code> slouží především k předání dat, která
potřebujeme na server odeslat v těle požadavku. My žádná taková nemáme
(pro metodu <code>GET</code> ani mít nemůžeme), neboť poptávané
uživatelské jméno předáme již v URL.</p></li>
<li><p>Objekt XMLHttpRequest generuje DOM události, takže přidáme
posluchač na <code>load</code>. To je událost, která vznikne, jakmile
server vrátí námi vyžádaná data.</p></li>
</ul>
<p>V tomto místě je dobré se na chvíli pozastavit a všimnout si, že
vykonání HTTP požadavku je <strong>asynchronní operace</strong>. Takto
označujeme funkcionalitu, která je vykonávána <em>na pozadí</em>, tedy
paralelně s JavaScriptovým kódem, který po ní následuje. Zkušenější
programátor by možná očekával, že metoda <code>xhr.send()</code> bude
<em>synchronní</em> (někdy též <em>blokující</em>), tj. že prohlížeč
během jejího vykonávání provede zmíněný HTTP požadavek a teprve po jeho
dokončení se bude pokračovat. Jenže to by mohlo trvat velmi dlouho
a došlo by tak k pozastavení našeho kódu, který by kvuli čekání na HTTP
požadavek nemohl dělat nic dalšího. Proto je objekt XMLHttpRequest
asynchronní. Tato jeho vlastnost dokonce vedla ke vzniku hovorového
označení <strong>Ajax</strong>, které bylo kdysi módní používat právě
pro tento způsob přenosu dat (Ajax = <em>Asynchronous JavaScript and
XML</em>).</p>
<p>Následující, resp. předchozí funkce <code>onLoad</code> je tedy
posluchač události a jako taková dostává parametr s objektem události.
To je pro nás dobrý způsob, jak se v ní dostat k proměnné
<code>xhr</code> (připomeňme, že <code>e.target</code> je objekt, který
událost vyvolal). Vlastnost <code>response</code> pak odpovídá datům,
která poslal server. Pokud se cestou nic nepokazilo, bude to slovník
odpovídající vzorovým datům z úvodu kapitoly. O dalším chování pak
rozhodneme podle jeho vlastnosti <code>available</code>.</p>
<p>Když už máme data ze serveru, chceme na jejich základě uživatele
informovat o (ne)dostupnosti uživatelského jména. Za tímto účelem
zobrazíme pod formulářovým polem varovnou hlášku, pokud je jméno
zabráno. Musíme si dát ale pozor na situaci, kdy tato kontrola probíhá
opakovaně, a tak je možné, že tato hláška už ve formuláři je. Vlastně
mohou nastat celkem čtyři situace:</p>
<ol type="1">
<li><p>Žádnou hlášku nezobrazujeme a podle odpovědi serveru ani
nemusíme: v takovém případě neděláme nic.</p></li>
<li><p>Žádnou hlášku nezobrazujeme, ale podle odpovědi serveru bychom
nově měli: bude nutné ji vyrobit a zobrazit.</p></li>
<li><p>Hláška už je zobrazena, ale uživatel změnil jméno a to nové už je
v pořádku: starou hlášku budeme muset skrýt.</p></li>
<li><p>Hláška už je zobrazena a ze serveru přišla opět instrukce
k jejímu ukázání: budeme muset vyrobit novou hlášku s novým textem a tu
starou jí nahradit.</p></li>
</ol>
<p>Vzorové řešení má pro tyto případy funkce <code>hideError</code>
a <code>showError</code>, které voláme dle získaných instrukcí. Obě jsou
připraveny na situaci, že už chybový text zobrazujeme: pokud nějaký
naleznou, tak jej nejprve odstraní. K nalezení se hodí poslední pomocná
mini-funkce <code>getError</code>, v jejíž implementaci se můžeme setkat
s další drobnou novinkou z rozhraní DOM. Jedná se o vlastnost
<code>labels</code>, která je dostupná u všech formulářových prvků
a odpovídá poli HTML značek <code>&lt;label&gt;</code>, jež jsou s daným
prvkem spárovány v roli popisku.</p>
<h3 id="co-jsme-se-naučili-3">Co jsme se naučili</h3>
<p>Po vyřešení čtvrté úlohy by měl čtenář chápat a ovládat:</p>
<ul>
<li><p>koncept komunikace se serverem pomocí HTTP JSON API</p></li>
<li><p>práci s asynchronním objektem
<code>XMLHttpRequest</code></p></li>
<li><p>vlastnost <code>labels</code> u formulářových polí</p></li>
</ul>
<h2 id="zelenáči-řízení-toku-kódu-pomocí-operátorů">Zelenáči: řízení
toku kódu pomocí operátorů</h2>
<p>V našich funkcích se často rozhoduje o chování programu na základě
hodnot uložených v proměnných. Typickým představitelem takového
rozhodování je klíčové slovo <code>if</code>, resp. konstrukce
<code>if (podmínka) { ... } else { ... }</code>. Využijme tuto
podkapitolu, abychom si ukázali další možnosti, jak realizovat podmínky
a větvení kódu.</p>
<p>Budeme k tomu potřebovat <em>operátory</em>. Jsou to syntaktické
prvky, zpravidla tvořené jedním či dvěma speciálními znaky, které slouží
především k provedení nějaké operace s jednou či více veličinami. Dobrým
příkladem je operátor <code>+</code> (sčítání či řetězení), se kterým se
setkáváme od základní školy. Operátory dělíme do skupin podle toho,
s kolika hodnotami (říkáme jim <em>operandy</em>) pracují. Unární
operátory (např. <code>!</code>) mají jen jeden operand, binární dva,
ternární operátor potřebuje operandy tři.</p>
<p>A právě ternární operátor (tvoří jej znak <code>?</code> v kombinaci
se znakem <code>:</code>) nás nyní zajímá. Jeho tradiční použití vypadá
takto:</p>
<div class="sourceCode" id="cb48"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> mince <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">random</span>()<span class="op">;</span></span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> text <span class="op">=</span> (mince <span class="op">&lt;</span> <span class="fl">0.5</span> <span class="op">?</span> <span class="st">&quot;panna&quot;</span> <span class="op">:</span> <span class="st">&quot;orel&quot;</span>)<span class="op">;</span></span></code></pre></div>
<p>Funkce <code>Math.random()</code> vrátí náhodnou hodnotu mezi nulou
a jedničkou. Ternární operátor na druhém řádku jsme pro zvýšení
čitelnosti vložili do kulatých závorek, ale není to nutné. Jeho první
operand – výraz před otazníkem – je testovaná podmínka. Pokud platí,
ternární operátor vrátí svůj druhý operand, zapsaný mezi otazníkem
a dvojtečkou. V opačném případě vrátí třetí operand (uvedený za
dvojtečkou).</p>
<p>A zde je vlastnost, která se nám může hodit: jako druhý a třetí
operand nemusíme použít jen prostou hodnotu, ale libovolně složitý
JavaScriptový výraz. Hodnota celého ternárního operátoru pak bude podle
podmínky vybrána jako hodnota prvního či druhého výrazu. Pojďme zkusit
použít ternární operátor jako alternativu <code>if</code> v rámci funkce
<code>onLoad</code>. Její stávající tvar je tento:</p>
<div class="sourceCode" id="cb49"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">onLoad</span>(e) {</span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> data <span class="op">=</span> e<span class="op">.</span><span class="at">target</span><span class="op">.</span><span class="at">response</span><span class="op">;</span></span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (data<span class="op">.</span><span class="at">available</span>) {</span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">hideError</span>()<span class="op">;</span></span>
<span id="cb49-5"><a href="#cb49-5" aria-hidden="true" tabindex="-1"></a>  } <span class="cf">else</span> {</span>
<span id="cb49-6"><a href="#cb49-6" aria-hidden="true" tabindex="-1"></a>    <span class="fu">showError</span>(data<span class="op">.</span><span class="at">suggested</span>)<span class="op">;</span></span>
<span id="cb49-7"><a href="#cb49-7" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb49-8"><a href="#cb49-8" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Použitím ternárního operátoru se kód zkrátí:</p>
<div class="sourceCode" id="cb50"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">onLoad</span>(e) {</span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> data <span class="op">=</span> e<span class="op">.</span><span class="at">target</span><span class="op">.</span><span class="at">response</span><span class="op">;</span></span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a>  data<span class="op">.</span><span class="at">available</span> <span class="op">?</span> <span class="fu">hideError</span>() <span class="op">:</span> <span class="fu">showError</span>(data<span class="op">.</span><span class="at">suggested</span>)<span class="op">;</span></span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Za zmínku stojí, že návratová hodnota ternárního operátoru je v tuto
chvíli nepodstatná. Abychom ještě více rozšířili svůj programátorský
arzenál, prozkoumáme nyní dva další – tentokrát binární – operátory.
Jedná se o <code>&amp;&amp;</code> (zvaný <em>a zároveň</em>)
a <code>||</code> (zvaný <em>nebo</em>).</p>
<p>Programátoři všech úrovní znalostí se s těmito operátory setkávají
zejména při nutnosti zkombinovat více podmínek; často je potkáváme
v situacích podobných těmto příkladům:</p>
<div class="sourceCode" id="cb51"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (usernameIsOk <span class="op">&amp;&amp;</span> passwordIsOk) { <span class="co">/* dokončit registraci */</span> }</span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (amount <span class="op">==</span> <span class="dv">0</span> <span class="op">||</span> amount <span class="op">&gt;</span> <span class="dv">10</span>) { <span class="co">/* toto množství nelze objednat */</span> }</span></code></pre></div>
<p>Tato forma použití v nás může budit dojem, že výsledkem těchto
operátorů je pravdivostní hodnota <code>true/false</code> (tzv.
<em>boolean</em>). To je ovšem značně nepřesné. Lepší definice zní
takto:</p>
<ul>
<li><p>Výsledkem operátoru <code>&amp;&amp;</code> je hodnota prvního
operandu, pokud je <em>pravdivá</em>. V opačném případě je výsledkem
hodnota druhého operandu.</p></li>
<li><p>Výsledkem operátoru <code>||</code> je hodnota prvního operandu,
pokud je <em>nepravdivá</em>. V opačném případě je výsledkem hodnota
druhého operandu.</p></li>
</ul>
<p>(Termíny <em>pravdivá</em> resp. <em>nepravdivá</em> odpovídají
intuitivnímu procesu převodu libovolné hodnoty na boolean. Tušíme, že
<code>false</code> bude nula, prázdný řetězec a podobně. Vše ostatní je
<code>true</code>. Přesněji se na tyto převody podíváme hned
v následující podkapitole pro koumáky.)</p>
<p>Tyto operátory a jejich chování můžeme použít k řízení toku kódu díky
další jejich vlastnosti, která se nazývá <strong>zkrácené
vyhodnocování</strong> (anglicky <em>short-circuit evaluation</em>). Ta
říká, že pokud o hodnotě operátoru lze rozhodnout na základě prvního
operandu, ten druhý bude ignorován. Pomocí této úvahy můžeme nyní lehce
zjednodušit kód ve funkci <code>hideError</code>. Její původní
implementace vypadala takto:</p>
<div class="sourceCode" id="cb52"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">hideError</span>() {</span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> error <span class="op">=</span> <span class="fu">getError</span>()<span class="op">;</span></span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (error) { error<span class="op">.</span><span class="fu">remove</span>()<span class="op">;</span> }</span>
<span id="cb52-4"><a href="#cb52-4" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Využitím zkráceného vyhodnocování můžeme tento kód upravit:</p>
<div class="sourceCode" id="cb53"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">hideError</span>() {</span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> error <span class="op">=</span> <span class="fu">getError</span>()<span class="op">;</span></span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a>  error <span class="op">&amp;&amp;</span> error<span class="op">.</span><span class="fu">remove</span>()<span class="op">;</span></span>
<span id="cb53-4"><a href="#cb53-4" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Stejně jako v minulém příkladu, i nyní nás nezajímá výsledek
operátoru. Využíváme jen jeho vlastnosti, že druhý operand (metoda
<code>error.remove()</code>) bude vykonán jen pokud je první operand
<em>pravdivý</em>.</p>
<p>Pro operátor <code>||</code> teď žádné vhodné využití nemáme, ale
dostaneme se k němu ještě v kapitole 12.</p>
<h2
id="koumáci-falsy-values-a-operátory-s-implicitním-přetypováním">Koumáci:
<em>falsy values</em> a operátory s implicitním přetypováním</h2>
<p>Z předchozí podkapitoly jsme si odnesli nové informace o některých
operátorech, ale také koncept toho, že libovolnou hodnotu v JavaScriptu
lze – většinou pro potřeby podmínek – převést na pravdivostní hodnotu.
Děje se tak buď implicitně (např. při zápisu
<code>if (hodnota) { ... }</code>), nebo explicitně použitím
<em>unárního operátoru negace</em> zapsaného znakem vykřičníku (tento
operátor svůj operand nejprve převede na boolean a pak vrátí opak). Pro
dobré porozumění hodnotám v Java­Scriptu musíme vědět, jak tento převod
probíhá.</p>
<p>Existuje poměrně malá množina hodnot, které jsou převedeny na
<code>false</code>. Říkáme jim <em>falsy values</em> a jejich seznam je
následující:</p>
<ul>
<li><p>pravdivostní hodnota <code>false</code></p></li>
<li><p>číslo <code>0</code> a speciální číselná hodnota <code>NaN</code>
<em>(Not a Number)</em></p></li>
<li><p>prázdný řetězec</p></li>
<li><p>speciální hodnoty <code>null</code>
a <code>undefined</code></p></li>
</ul>
<p>(Mimochodem, čím že se to vlastně liší <code>null</code>
a <code>undefined?</code> Hodnotu <code>null</code> je doporučeno
používat explicitně tam, kde chceme jasně vyjádřit prázdno či
neexistenci. Hodnota <code>undefined</code> pak odpovídá těm případům,
kdy potřebná veličina chybí implicitně, neboť ji nikdo nedodal.
U proměnných bez přiřazené hodnoty, u přístupu k neexistujícímu klíči ve
slovníku, při použití parametru funkce, která jej nedostala předaný při
volání.)</p>
<p>Všechny ostatní hodnoty jsou <em>truthy values</em> a při převodu na
boolean z nich vznikne <code>true</code>.</p>
<p>Výše uvedený seznam je dostatečně krátký na to, abychom si jej
zapamatovali a dopředu dovedli odhadnout, jak dopadne implicitní
přetypování v rámci podmínky nebo zkráceného vyhodnocení operátorů
<code>&amp;&amp;</code> a <code>||</code>. JavaScript bohužel provádí
implicitní přetypování také v dalších situacích, které jsou i pro
zkušeného programátora výrazně méně předvídatelné. Zde máme na mysli
zejména operátor sčítání (znak <code>+</code>) a operátor porovnání
(znaky <code>==</code>). Pojďme si jejich specifika prohlédnout na
příkladech.</p>
<p>U sčítání narážíme na skutečnost, že tento operátor plní dvě různé
role: aritmetickou operaci pro čísla a spojení (zřetězení) pro řetězce.
Tato flexibilita s sebou nese daň v podobě komplexní logiky, kterou
operátor sčítání provádí v situaci, kdy jeho operandy nespadají do jedné
z těchto dvou kategorií:</p>
<div class="sourceCode" id="cb54"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span> <span class="op">+</span> <span class="st">&quot;1&quot;</span><span class="op">;</span>      <span class="co">// &quot;11&quot;</span></span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a><span class="kw">true</span> <span class="op">+</span> <span class="kw">true</span><span class="op">;</span>  <span class="co">// 2</span></span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true" tabindex="-1"></a>[] <span class="op">+</span> []<span class="op">;</span>      <span class="co">// &quot;&quot;</span></span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true" tabindex="-1"></a>{} <span class="op">+</span> {}<span class="op">;</span>      <span class="co">// &quot;[object Object][object Object]&quot;</span></span></code></pre></div>
<p>Pokud je čtenář některými výsledky překvapen, pak nabízíme snadný
recept, jak se jich vyvarovat: používat operátor sčítání pouze tam, kde
jsme si jisti tím, že sčítáme sčitatelné (tj. operandy jsou buď dvě
čísla, nebo dva řetězce). O něco komplikovanější je situace s operátorem
porovnání, u kterého nám v řadě situací může dávat smysl porovnávání
hodnot různých typů. Jsme kupříkladu rádi, že číslo můžeme porovnávat
s řetězcem, který obsahuje tu samou hodnotu:</p>
<div class="sourceCode" id="cb55"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;42&quot;</span> <span class="op">==</span> <span class="dv">42</span><span class="op">;</span>  <span class="co">// true</span></span></code></pre></div>
<p>V praxi se s podobným porovnáním můžeme setkat často; třeba když
bereme číselnou hodnotu z formulářového pole (neboť
<code>input.value</code> je řetězec). Ale takové pohodlí s sebou bohužel
přináší nepříjemné výsledky:</p>
<div class="sourceCode" id="cb56"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;0&quot;</span> <span class="op">==</span> <span class="dv">0</span><span class="op">;</span>    <span class="co">// true</span></span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a><span class="dv">0</span> <span class="op">==</span> <span class="st">&quot;&quot;</span><span class="op">;</span>     <span class="co">// true</span></span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;&quot;</span> <span class="op">==</span> <span class="st">&quot;0&quot;</span><span class="op">;</span>   <span class="co">// false</span></span></code></pre></div>
<p>Dávají vám jednotlivá porovnání smysl? Sama o sobě jsou logická, ale
dohromady zde máme tři hodnoty: první dvě se rovnají, druhé dvě se
rovnají a první se třetí nikoliv. Nalezli jsme příklad, kdy
<strong>operátor rovnosti není tranzitivní</strong>. Aby se s ním
pracovalo komfortně, musí obsahovat komplikovanou sadu pravidel pro
situace, kdy jeho operandy mají různý typ. A tato pravidla si málokdo
dokáže zapamatovat, což snižuje předvídatelnost operátoru.</p>
<p>Pokud nás tato flexibilita trápí, můžeme sáhnout po jednom ze dvou
řešení:</p>
<ol type="1">
<li><p>Namísto operátoru rovnosti (<code>==</code>) používat
trojrovnítkový <strong>operátor ekvivalence</strong> (<code>===</code>).
Ten funguje obdobně jako běžné porovnání, ale pokud jeho operandy mají
různý typ, ihned vrátí <code>false</code>. Neprojde skrz něj tedy žádný
ze tří testů uvedených v předchozí ukázce.</p></li>
<li><p>Používat porovnávání jen mezi proměnnými shodných datových typů,
resp. těch typů, u kterých jsme si jisti porovnávacím algoritmem. Je to
stejné doporučení, jako to před chvílí zmíněné u operátoru
sčítání.</p></li>
</ol>
<h2 id="profíci-same-origin-policy-a-cors">Profíci: <em>same-origin
policy</em> a CORS</h2>
<p>Pojďme si nyní od JavaScriptu trošku odpočinout a podívat se na téma
lehce odlišné. Ve vzorovém řešení jsme viděli, že v rámci webové stránky
lze vytvořit HTTP požadavek <em>na pozadí</em>, a dostat se tak k dalším
datům, případně data přenést na server, aniž bychom provedli
<em>navigaci</em> (tj. uživatele vzali na jinou stránku). Jde o velice
silnou techniku, a tak je zde otázka, jestli tím klientskému JavaScriptu
náhodou nedáváme do ruky nástroje, které by bylo možné zneužít.</p>
<p>Opatrnost je na místě. Webové stránky jsou, v kontrastu s běžným
programovým vybavením počítače, ve specifickém postavení. Uživatel je
často navštíví, aniž by dopředu věděl, co ho čeká. Prostřednictvím
prohlížeče vidí web, který mohl vytvořit autor nekalých úmyslů (v tomto
kontextu se často celkem přímočaře rovnou říká <em>útočník</em>).
Automaticky nelze rozhodnout o tom, zdali je účelem stránky uživateli
uškodit, takže prohlížeč namísto toho poskytuje ochranu pasivní:
nedovolí žádnou operaci, která by byla zneužitelná. Proto například
v klientském JavaScriptu nemůžeme přistupovat k souborům uživatele.</p>
<p>A jak je to tedy s HTTP požadavky? Je jasné, že útočník disponující
vlastním webovým serverem může vykonávat libovolnou síťovou komunikaci
iniciovanou <em>právě z toho jeho serveru</em>. Když ale svůj kód vyrobí
v JavaScriptu, dojde k jeho vykonání v prohlížeči uživatele; požadavky
budou tedy vycházet <em>z uživatelova počítače</em>. Zhruba tak, jako na
obrázku:</p>
<figure>
<img src="../img/csrf.svg"
alt="Útočník může komunikovat s obětí prostřednictvím nic netušícího uživatele" />
<figcaption aria-hidden="true">Útočník může komunikovat s obětí
prostřednictvím nic netušícího uživatele</figcaption>
</figure>
<p>Takové nastavení otevírá útočníkovi možnost vykonávat požadavky,
které by jinak nemohl. Konkrétně:</p>
<ol type="1">
<li><p>Požadavky na servery, které jsou ochotny provést komunikaci
s počítačem uživatele, ale nikoliv se serverem útočníka.</p></li>
<li><p>Požadavky, do kterých uživatelův prohlížeč automaticky doplňuje
nějaká <em>tajemství</em>, kterými útočník nedisponuje. Může jít o HTTP
cookies, jméno a heslo pro HTTP autorizaci, klientské certifikáty
a podobně. V roce 2024 sice v rámci omezování tzv. <em>3rd party
cookies</em> ztrácí tento útok na významu, nicméně předchozí bod stále
platí v plné šíři.</p></li>
</ol>
<p>V praxi proto prohlížeče silně omezují možnosti HTTP požadavků (jak
<code>XHR</code>, tak <code>fetch</code>). Tato ochrana se nazývá
<em>Same Origin Policy</em> (SOP) a ve skutečnosti je velice jednoduchá.
K jejímu pochopení stačí definovat termín <strong>origin webové
adresy</strong> – jedná se o tři její komponenty, konkrétně <em>schema,
hostname a port</em>. Tyto tvoří první část URL <em>až po první lomítko
za doménou</em>. Nejlépe to uvidíme na příkladu: vzorová adresa
<code>https://karel.cz/pisnicky/texty.html</code> má origin
<code>https://karel.cz</code>. SOP pak prostě předepisuje, že
JavaScriptové požadavky smíme provádět jen pokud se <strong>origin
cílového URL shoduje s originem stránky, na které se
nacházíme</strong>.</p>
<p>V řadě případů se nás SOP nijak nedotkne. Pokud je cílová adresa na
serveru, jehož stránku zobrazujeme, omezení se našeho kódu netýká. To
zejména zahrnuje všechny relativní adresy začínající lomítkem (častá
praxe), neboť ty z definice vedou na stejný origin, jako má stránka.
Kdybychom ale chtěli začít načítat data z úplně jiného serveru, budeme
muset situaci se SOP nějak vyřešit.</p>
<p>Pro zdárný přenos takovýchto dat máme jen dvě smysluplné
možnosti:</p>
<ul>
<li><p>Situace, kdy chceme provést HTTP požadavek, ale nepotřebujeme
následně pomocí JavaScriptu přistupovat k jeho odpovědi. Je to
nepravděpodobný, ale možný scénář. Zahrnuje například zobrazení obrázků
z jiné domény, vložení stylu či skriptu a podobně. Taková aktivita není
útočníkem zneužitelná, proto ji SOP nezahrnuje – tato ochrana se projeví
teprve ve chvíli, kdy bychom se zajímali o data získané
odpovědi.</p></li>
<li><p>Situace, kdy se s provozovatelem cílového originu domluvíme na
tom, že mu takový druh komunikace nevadí. Samozřejmě zde nemáme na mysli
skutečnou ústní dohodu; stačí, aby vzdálený webový server nějakým
mechanismem <strong>povolil, že mu nevadí zpracovat požadavek
pocházející z jiného originu</strong>.</p></li>
</ul>
<p>Druhá popisovaná situace je velmi častá. Zmiňovaný souhlas je
v prohlížeči realizován technikou nazvanou CORS <em>(Cross-Origin
Resource Sharing)</em>. Díky ní je možné za určitých podmínek tvrdá
omezení SOP obejít. Celá rozhodovací posloupnost pak vypadá
následovně:</p>
<ol type="1">
<li><p>Uživatel se nachází na stránce s originem <code>A</code>, její
JavaScript se pokouší provést požadavek na URL s originem
<code>B</code>. Pokud se tyto originy shodují, je vše povoleno a není co
řešit.</p></li>
<li><p>Prohlížeč provede požadavek, ale přidá k němu v HTTP hlavičce
<code>Origin</code> zmínku o tom, že autor požadavku – klientský počítač
– zobrazuje stránku na originu <code>A</code>.</p></li>
<li><p>Od serveru z originu <code>B</code> přijde odpověď. Prohlížeč se
podívá, jestli se v jejích hlavičkách nachází informace o tom, že server
souhlasí (tzv. CORS hlavička). Pokud ne, odpověď se před JavaScriptem
zatají (SOP). Pokud ano, odpověď se JavaScriptovému kódu předá.</p></li>
</ol>
<p>Toto schéma jsme záměrně trochu zjednodušili. Zvídavý čtenář se
o pokročilejších konceptech CORS (další hlavičky, technika
<em>preflight</em>) může dočíst například na MDN (<a
href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS">https://developer.mozilla.org/</a>),
nebo na webu <a href="https://enable-cors.org/">enable-cors.org</a>.</p>
<h1 id="cesta-k-spa-riziko-xss">Cesta k SPA, riziko XSS</h1>
<h2 id="úloha-4">Úloha</h2>
<p>Na našem webu, který fanouškům poskytuje texty písní Karla Gotta,
nabízíme funkci <strong>hledání:</strong> uživatel zadá do formulářového
pole hledaný text a my mu po odeslání na nové stránce zobrazíme všechny
související písně. Rádi bychom současné řešení upravili na modernější
SPA (<em>single-page application</em>), kdy při zobrazení výsledků
nedochází k načtení nové stránky. Backend bude data opět nabízet formou
HTTP JSON API.</p>
<h3 id="řešení-4">Řešení</h3>
<p>Stejně jako v minulé kapitole, i zde máme v plánu pracovat s daty,
která získáme JavaScriptovým požadavkem z backendu. Komunikace může
vypadat třeba takto:</p>
<ul>
<li><p>data odesílaná na server budou realizována HTTP požadavkem
poslaným na adresu <code>/search?query=...</code></p></li>
<li><p>server odpoví daty ve formátu JSON a bude to pole; jeho
jednotlivé položky budou vypadat takto:</p>
<div class="sourceCode" id="cb57"><pre
class="sourceCode json"><code class="sourceCode json"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a><span class="fu">{</span></span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&quot;title&quot;</span><span class="fu">:</span> <span class="st">&quot;Mám styl Čendy&quot;</span><span class="fu">,</span></span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&quot;text&quot;</span><span class="fu">:</span> <span class="st">&quot;Mezi námi je &lt;em&gt;mnoho&lt;/em&gt; chvil&quot;</span><span class="fu">,</span></span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&quot;url&quot;</span><span class="fu">:</span> <span class="st">&quot;...&quot;</span>  <span class="er">//</span> <span class="er">odkaz</span> <span class="er">na</span> <span class="er">celý</span> <span class="er">text</span> <span class="er">písně</span></span>
<span id="cb57-5"><a href="#cb57-5" aria-hidden="true" tabindex="-1"></a><span class="fu">}</span></span></code></pre></div></li>
</ul>
<p>Pod klíčem <code>text</code> je uložena část textu písně, díky které
se píseň dostala do výsledků. Konkrétně server značkou
<code>&lt;em&gt;</code> označí tu část textu, která odpovídá hledanému
termínu.</p>
<p>Mimochodem: je nezbytné, aby to dělal server, když i klient zná
hledaný termín a mohl by jej v textu najít a označit? Ano, v naprosté
většině případů je zodpovědností serveru, aby data takto připravil. Jen
on totiž ví, proč se píseň dostala do výsledků; možná že je v ní hledaný
termín v jiném pádu, bez diakritiky nebo s jinou velikostí písmen.</p>
<p>Vzorové řešení pak může vypadat takto:</p>
<div class="sourceCode" id="cb58"><pre
class="sourceCode html"><code class="sourceCode html"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a><span class="co">&lt;!-- kapitola-6.html --&gt;</span></span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a><span class="dt">&lt;</span><span class="kw">h1</span><span class="dt">&gt;</span>Hledání<span class="dt">&lt;/</span><span class="kw">h1</span><span class="dt">&gt;</span></span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a><span class="dt">&lt;</span><span class="kw">form</span><span class="dt">&gt;</span></span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&lt;</span><span class="kw">label</span><span class="dt">&gt;</span></span>
<span id="cb58-5"><a href="#cb58-5" aria-hidden="true" tabindex="-1"></a>    Hledaný výraz: <span class="dt">&lt;</span><span class="kw">input</span> <span class="er">type</span><span class="ot">=</span><span class="st">&quot;text&quot;</span> <span class="er">name</span><span class="ot">=</span><span class="st">&quot;query&quot;</span> <span class="dt">/&gt;</span></span>
<span id="cb58-6"><a href="#cb58-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&lt;/</span><span class="kw">label</span><span class="dt">&gt;</span></span>
<span id="cb58-7"><a href="#cb58-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&lt;</span><span class="kw">button</span><span class="dt">&gt;</span>🔎<span class="dt">&lt;/</span><span class="kw">button</span><span class="dt">&gt;</span></span>
<span id="cb58-8"><a href="#cb58-8" aria-hidden="true" tabindex="-1"></a><span class="dt">&lt;/</span><span class="kw">form</span><span class="dt">&gt;</span></span>
<span id="cb58-9"><a href="#cb58-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-10"><a href="#cb58-10" aria-hidden="true" tabindex="-1"></a><span class="dt">&lt;</span><span class="kw">section</span> <span class="er">id</span><span class="ot">=</span><span class="st">&quot;results&quot;</span><span class="dt">&gt;&lt;/</span><span class="kw">section</span><span class="dt">&gt;</span></span>
<span id="cb58-11"><a href="#cb58-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-12"><a href="#cb58-12" aria-hidden="true" tabindex="-1"></a><span class="dt">&lt;</span><span class="kw">script</span> <span class="er">src</span><span class="ot">=</span><span class="st">&quot;kapitola-6.js&quot;</span><span class="dt">&gt;&lt;/</span><span class="kw">script</span><span class="dt">&gt;</span></span></code></pre></div>
<div class="sourceCode" id="cb59"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a><span class="co">// kapitola-6.js</span></span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> form <span class="op">=</span> <span class="bu">document</span><span class="op">.</span><span class="fu">querySelector</span>(<span class="st">&quot;form&quot;</span>)<span class="op">;</span></span>
<span id="cb59-3"><a href="#cb59-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> results <span class="op">=</span> <span class="bu">document</span><span class="op">.</span><span class="fu">querySelector</span>(<span class="st">&quot;#results&quot;</span>)<span class="op">;</span></span>
<span id="cb59-4"><a href="#cb59-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-5"><a href="#cb59-5" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">buildSong</span>(song) {</span>
<span id="cb59-6"><a href="#cb59-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> item <span class="op">=</span> <span class="bu">document</span><span class="op">.</span><span class="fu">createElement</span>(<span class="st">&quot;li&quot;</span>)<span class="op">;</span></span>
<span id="cb59-7"><a href="#cb59-7" aria-hidden="true" tabindex="-1"></a>  item<span class="op">.</span><span class="at">innerHTML</span> <span class="op">=</span> <span class="vs">`</span></span>
<span id="cb59-8"><a href="#cb59-8" aria-hidden="true" tabindex="-1"></a><span class="vs">    &lt;a href=&quot;</span><span class="sc">${</span>song<span class="op">.</span><span class="at">url</span><span class="sc">}</span><span class="vs">&quot;&gt;</span><span class="sc">${</span>song<span class="op">.</span><span class="at">title</span><span class="sc">}</span><span class="vs">&lt;/a&gt;</span></span>
<span id="cb59-9"><a href="#cb59-9" aria-hidden="true" tabindex="-1"></a><span class="vs">    &lt;br/&gt; </span><span class="sc">${</span>song<span class="op">.</span><span class="at">text</span><span class="sc">}</span></span>
<span id="cb59-10"><a href="#cb59-10" aria-hidden="true" tabindex="-1"></a><span class="vs">  `</span><span class="op">;</span></span>
<span id="cb59-11"><a href="#cb59-11" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> item<span class="op">;</span></span>
<span id="cb59-12"><a href="#cb59-12" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb59-13"><a href="#cb59-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-14"><a href="#cb59-14" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">showResults</span>(xhr<span class="op">,</span> query) {</span>
<span id="cb59-15"><a href="#cb59-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> songs <span class="op">=</span> xhr<span class="op">.</span><span class="at">response</span><span class="op">;</span></span>
<span id="cb59-16"><a href="#cb59-16" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (songs<span class="op">.</span><span class="at">length</span> <span class="op">==</span> <span class="dv">0</span>) {</span>
<span id="cb59-17"><a href="#cb59-17" aria-hidden="true" tabindex="-1"></a>    results<span class="op">.</span><span class="fu">replaceChildren</span>(<span class="st">&quot;Dotazu nevyhovují žádné písně 🙁&quot;</span>)<span class="op">;</span></span>
<span id="cb59-18"><a href="#cb59-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span><span class="op">;</span></span>
<span id="cb59-19"><a href="#cb59-19" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb59-20"><a href="#cb59-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-21"><a href="#cb59-21" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> heading <span class="op">=</span> <span class="bu">document</span><span class="op">.</span><span class="fu">createElement</span>(<span class="st">&quot;h2&quot;</span>)<span class="op">;</span></span>
<span id="cb59-22"><a href="#cb59-22" aria-hidden="true" tabindex="-1"></a>  heading<span class="op">.</span><span class="at">textContent</span> <span class="op">=</span> <span class="vs">`Nalezené písně pro dotaz: </span><span class="sc">${</span>query<span class="sc">}</span><span class="vs">`</span><span class="op">;</span></span>
<span id="cb59-23"><a href="#cb59-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-24"><a href="#cb59-24" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> ol <span class="op">=</span> <span class="bu">document</span><span class="op">.</span><span class="fu">createElement</span>(<span class="st">&quot;ol&quot;</span>)<span class="op">;</span></span>
<span id="cb59-25"><a href="#cb59-25" aria-hidden="true" tabindex="-1"></a>  results<span class="op">.</span><span class="fu">replaceChildren</span>(heading<span class="op">,</span> ol)<span class="op">;</span></span>
<span id="cb59-26"><a href="#cb59-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-27"><a href="#cb59-27" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> (<span class="kw">let</span> i<span class="op">=</span><span class="dv">0</span><span class="op">;</span> i<span class="op">&lt;</span>songs<span class="op">.</span><span class="at">length</span><span class="op">;</span> i<span class="op">++</span>) {</span>
<span id="cb59-28"><a href="#cb59-28" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> song <span class="op">=</span> <span class="fu">buildSong</span>(songs[i])<span class="op">;</span></span>
<span id="cb59-29"><a href="#cb59-29" aria-hidden="true" tabindex="-1"></a>    ol<span class="op">.</span><span class="fu">append</span>(song)<span class="op">;</span></span>
<span id="cb59-30"><a href="#cb59-30" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb59-31"><a href="#cb59-31" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb59-32"><a href="#cb59-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-33"><a href="#cb59-33" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">onSubmit</span>(e) {</span>
<span id="cb59-34"><a href="#cb59-34" aria-hidden="true" tabindex="-1"></a>  e<span class="op">.</span><span class="fu">preventDefault</span>()<span class="op">;</span></span>
<span id="cb59-35"><a href="#cb59-35" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> xhr <span class="op">=</span> <span class="kw">new</span> <span class="bu">XMLHttpRequest</span>()<span class="op">;</span></span>
<span id="cb59-36"><a href="#cb59-36" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> query <span class="op">=</span> form<span class="op">.</span><span class="fu">querySelector</span>(<span class="st">&quot;[name=query]&quot;</span>)<span class="op">.</span><span class="at">value</span><span class="op">;</span></span>
<span id="cb59-37"><a href="#cb59-37" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> url <span class="op">=</span> <span class="vs">`/search?query=</span><span class="sc">${</span><span class="pp">encodeURIComponent</span>(query)<span class="sc">}</span><span class="vs">`</span><span class="op">;</span></span>
<span id="cb59-38"><a href="#cb59-38" aria-hidden="true" tabindex="-1"></a>  xhr<span class="op">.</span><span class="at">responseType</span> <span class="op">=</span> <span class="st">&quot;json&quot;</span><span class="op">;</span></span>
<span id="cb59-39"><a href="#cb59-39" aria-hidden="true" tabindex="-1"></a>  xhr<span class="op">.</span><span class="fu">open</span>(<span class="st">&quot;GET&quot;</span><span class="op">,</span> url)<span class="op">;</span></span>
<span id="cb59-40"><a href="#cb59-40" aria-hidden="true" tabindex="-1"></a>  xhr<span class="op">.</span><span class="fu">send</span>()<span class="op">;</span></span>
<span id="cb59-41"><a href="#cb59-41" aria-hidden="true" tabindex="-1"></a>  xhr<span class="op">.</span><span class="fu">addEventListener</span>(<span class="st">&quot;load&quot;</span><span class="op">,</span> e <span class="kw">=&gt;</span> <span class="fu">showResults</span>(xhr<span class="op">,</span> query))<span class="op">;</span></span>
<span id="cb59-42"><a href="#cb59-42" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb59-43"><a href="#cb59-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-44"><a href="#cb59-44" aria-hidden="true" tabindex="-1"></a>form<span class="op">.</span><span class="fu">addEventListener</span>(<span class="st">&quot;submit&quot;</span><span class="op">,</span> onSubmit)<span class="op">;</span></span></code></pre></div>
<p>Kód neobsahuje žádné velké novinky. Jedná se o kombinaci minulých
dvou kapitol (použití <code>XMLHttpRequest</code> a události
<code>submit</code>). Za zmínku stojí:</p>
<ul>
<li><p>Ve formuláři jsme použili HTML prvek <code>&lt;button&gt;</code>,
který ve výchozím nastavení též funguje jako odesílací
tlačítko.</p></li>
<li><p>V rámci posluchače <code>onSubmit</code> vždy voláme
<code>e.preventDefault()</code>, abychom tak zamezili odeslání.
V kontextu této úlohy to neznamená chybu uživatele, ale snahu zůstat na
stejné stránce a požadovanou funkcionalitu následně vykonat pomocí
JavaScriptu.</p></li>
<li><p>Data získaná z hledacího pole před vložením do URL opět
upravujeme funkcí <code>encodeURIComponent</code> pro případ, že by
obsahovala znaky, které do URL nepatří.</p></li>
<li><p>Posluchač události <code>load</code> je malá anonymní arrow
funkce, která uzavírá proměnné <code>xhr</code> a <code>query</code>.
Díky tomu můžeme do <code>showResults</code> předat libovolné
parametry.</p></li>
</ul>
<p>V HTML dokumentu jsme si nachystali prázdný prvek
<code>&lt;section id="results"&gt;</code>, jehož obsah následně plníme
na základě dat ze serveru. To je velmi častý postup: v HTML připravíme
jen kostru či šablonu výsledné stránky, JavaScriptem do ní později
dodáme potřebné informace. V těchto případech je dobré nezapomenout na
dva scénáře:</p>
<ol type="1">
<li><p>Co uživatel vidí, dokud se čeká na odpověď od serveru? Jestli to
je nějaká neúplná HTML struktura, měla by být skryta. V našem případě
nevidí nic.</p></li>
<li><p>Co uživatel vidí, pokud se prázdný prostor ve stránce plní
opakovaně? Při každém hledání je nutné obsah prvku <code>#results</code>
nahradit. Namísto přidávání nových uzlů proto používáme
<code>results.replaceChildren()</code>.</p></li>
</ol>
<p>V této kapitole se pojďme podívat pozorněji na funkci
<code>buildSong</code>, která slouží k výrobě HTML prvku odpovídajícímu
jednomu výsledku hledání. Poprvé se v ní setkáváme s vlastností
<code>innerHTML</code>, která patří mezi nejsilnější součásti rozhraní
DOM. Když nějakému HTML prvku přiřazujeme do vlastnosti
<code>innerHTML</code>, říkáme tím, že prohlížeč má celý obsah (potomky)
tohoto prvku nahradit novým podstromem, který vznikne parsováním
zadaného řetězce. Je to skoro stejné, jako když necháváme prohlížeč
sestavit strom dokumentu při prvním načtení stránky.</p>
<p>Jedná se o velmi pohodlný způsob tvorby složitější komponenty webové
stránky. Porovnejme, o kolik by bylo zdlouhavější výsledek hledání
vyrobit a sestavit pomocí několika volání <code>createElement</code>
a <code>append</code>. Zároveň je pro nás řešení pomocí
<code>innerHTML</code> nezbytné, protože od serveru již dostáváme malé
části HTML – vlastnost <code>text</code> s úryvkem textu písně obsahuje
značku pro zvýraznění.</p>
<p>I přes nezpochybnitelné pohodlí vlastnosti <code>innerHTML</code> si
ale musíme dát velký pozor na její použití. Jedná se totiž bohužel
o častý vstupní bod pro zranitelnost typu <strong>XSS</strong>
<em>(cross-site scripting)</em>. Abychom lépe pochopili, oč jde, můžeme
se podívat hned o pár řádků vedle, do funkce <code>showResults</code>.
Tam se vyrábí nadpis pro výsledky:</p>
<div class="sourceCode" id="cb60"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> heading <span class="op">=</span> <span class="bu">document</span><span class="op">.</span><span class="fu">createElement</span>(<span class="st">&quot;h2&quot;</span>)<span class="op">;</span></span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a>heading<span class="op">.</span><span class="at">textContent</span> <span class="op">=</span> <span class="vs">`Nalezené písně pro dotaz: </span><span class="sc">${</span>query<span class="sc">}</span><span class="vs">`</span><span class="op">;</span></span></code></pre></div>
<p>Tentokrát se namísto <code>innerHTML</code> používá
<code>textContent</code>, který taktéž nahradí danému uzlu obsah, ale
prostým textem. Zadaný řetězec není parsován jako HTML, tj. případné
HTML značky v něm obsažené se zobrazí jen jako text. A je to tak
správně, neboť při použití <code>innerHTML</code> by pak mohl záludný
uživatel do hledacího pole napsat například:</p>
<div class="sourceCode" id="cb61"><pre
class="sourceCode html"><code class="sourceCode html"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a><span class="dt">&lt;</span><span class="kw">img</span> <span class="er">src</span><span class="ot">=</span><span class="st">&quot;...&quot;</span><span class="dt">&gt;</span></span></code></pre></div>
<p>Náš kód by pak v nadpisu namísto zadaného řetězce ukázal obrázek.
A to je velká chyba, neboť uživatel svým vstupem dokázal
<strong>pozměnit strukturu dokumentu</strong>. Od toho je pak už jen
krůček k tomu, aby tímto způsobem mohl vložit vlastní skript. Jak přesně
by toho docílil a jaké nebezpečí by z toho mohlo plynout – to je mimo
rozsah této knihy. Nám bohatě stačí, že bychom tak nechali uživatele do
námi připraveného dokumentu vkládat jeho značky. To je v naprosté
většině případů základ pro bezpečnostní malér.</p>
<p>Bereme si z toho velmi důležité ponaučení: jakmile vytváříme HTML
dokument nebo jeho část, musíme uvažovat, jaká data v něm zobrazíme.
Pokud existuje možnost, že tato data nepochází z důvěryhodného zdroje
(tj. mohou obsahovat neočekávané HTML znaky), pracujeme defenzivně
a tato data vkládáme pomocí <code>textContent</code> (nebo jako
parametry do <code>append()</code>). Jen tak je zaručeno, že prohlížeč
zadaný řetězec nebude považovat za HTML. A teprve když jsme si absolutně
jisti, že v zobrazovaných proměnných jsou jen ne-HTML data, smíme použít
mocnou vlastnost <code>innerHTML</code>.</p>
<p>Pro úplnost: je výše uvedenou optikou bezpečné naše použití
<code>innerHTML</code> ve funkci <code>buildSong</code>? Záleží na tom,
odkud se berou data uložená pod klíči <code>url</code>,
<code>text</code> a <code>title</code>. Pokud bychom uvažovali variantu,
že by Karel Gott do nějakého svého textu umístil záludný kousek HTML,
museli bychom od serveru vyžadovat, aby vrácená data náležitě zabezpečil
(problémové znaky nahradil za HTML entity).</p>
<h3 id="co-jsme-se-naučili-4">Co jsme se naučili</h3>
<p>Po vyřešení páté úlohy by měl čtenář chápat a ovládat:</p>
<ul>
<li><p>podstatu zranitelností XSS</p></li>
<li><p>rozdíl mezi vlastnostmi <code>textContent</code>
a <code>innerHTML</code></p></li>
</ul>
<h2 id="zelenáči-práce-s-adresním-řádkem">Zelenáči: práce s adresním
řádkem</h2>
<p>SPA, tedy jednostránkové webové aplikace, staví na technice
<em>nahrazování obsahu JavaScriptem</em> namísto tradičního mechanismu
<em>navigace</em> mezi více různými stránkami. V porovnání s běžně
odesílaným formulářem je ale naše současné řešení ještě pořád trochu
nemotorné. Při hledání totiž nedochází ke změně URL v adresním řádku
prohlížeče. A to je škoda, protože tak přicházíme o:</p>
<ul>
<li><p>možnost uložení adresy s výsledky do záložek,</p></li>
<li><p>možnost poslání takové adresy někomu jinému,</p></li>
<li><p>možnost reloadu (opětovného načtení) stránky s výsledky,</p></li>
<li><p>pohyb v historii prohlížeče (tj. tlačítko
<em>Zpět</em>).</p></li>
</ul>
<p>Uživatel se stále nachází na té samé stránce, takže v adresním řádku
je stále jen např. <code>search.html</code>. Zobrazovaná data se ovšem
mění – dávalo by tedy smysl, aby se měnilo i zobrazované URL.</p>
<p>Řešení není komplikované, byť na něj vývojáři často a rádi
zapomínají. Sestává z těchto kroků:</p>
<ol type="1">
<li><p>Po provedení hledání musíme informaci o hledaném termínu vložit
do URL v adresním řádku. To mj. způsobí záznam do historie prohlížeče,
takže pak bude možný návrat tlačítkem <em>Zpět</em>.</p></li>
<li><p>Jakmile uživatel toto tlačítko použije, URL se změní (na
předchozí hodnotu), ale my zůstáváme na stejné stránce. Musíme proto
zobrazit obsah korespondující s novým URL.</p></li>
<li><p>Pokud uživatel načte novou stránku, v jejímž URL bude námi
poznamenaná hledaná hodnota, musíme provést hledání.</p></li>
</ol>
<p>Pojďme část vzorového řešení v tomto smyslu upravit a rozšířit.
Nejprve rozdělíme <em>odeslání formuláře</em> a <em>hledání</em> do dvou
funkcí:</p>
<div class="sourceCode" id="cb62"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">search</span>(query) {</span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> xhr <span class="op">=</span> <span class="kw">new</span> <span class="bu">XMLHttpRequest</span>()<span class="op">;</span></span>
<span id="cb62-3"><a href="#cb62-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> url <span class="op">=</span> <span class="vs">`/search?query=</span><span class="sc">${</span><span class="pp">encodeURIComponent</span>(query)<span class="sc">}</span><span class="vs">`</span><span class="op">;</span></span>
<span id="cb62-4"><a href="#cb62-4" aria-hidden="true" tabindex="-1"></a>  xhr<span class="op">.</span><span class="at">responseType</span> <span class="op">=</span> <span class="st">&quot;json&quot;</span><span class="op">;</span></span>
<span id="cb62-5"><a href="#cb62-5" aria-hidden="true" tabindex="-1"></a>  xhr<span class="op">.</span><span class="fu">open</span>(<span class="st">&quot;GET&quot;</span><span class="op">,</span> url)<span class="op">;</span></span>
<span id="cb62-6"><a href="#cb62-6" aria-hidden="true" tabindex="-1"></a>  xhr<span class="op">.</span><span class="fu">send</span>()<span class="op">;</span></span>
<span id="cb62-7"><a href="#cb62-7" aria-hidden="true" tabindex="-1"></a>  xhr<span class="op">.</span><span class="fu">addEventListener</span>(<span class="st">&quot;load&quot;</span><span class="op">,</span> e <span class="kw">=&gt;</span> <span class="fu">showResults</span>(xhr<span class="op">,</span> query))<span class="op">;</span></span>
<span id="cb62-8"><a href="#cb62-8" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb62-9"><a href="#cb62-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-10"><a href="#cb62-10" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">onSubmit</span>(e) {</span>
<span id="cb62-11"><a href="#cb62-11" aria-hidden="true" tabindex="-1"></a>  e<span class="op">.</span><span class="fu">preventDefault</span>()<span class="op">;</span></span>
<span id="cb62-12"><a href="#cb62-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> query <span class="op">=</span> form<span class="op">.</span><span class="fu">querySelector</span>(<span class="st">&quot;[name=query]&quot;</span>)<span class="op">.</span><span class="at">value</span><span class="op">;</span></span>
<span id="cb62-13"><a href="#cb62-13" aria-hidden="true" tabindex="-1"></a>  <span class="fu">search</span>(query)<span class="op">;</span></span>
<span id="cb62-14"><a href="#cb62-14" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>To odpovídá plánu, že hledání bude vyvoláno i jinými mechanismy, než
jen odesláním formuláře. Dále, po odeslání formuláře bude potřeba změnit
URL v adresním řádku:</p>
<div class="sourceCode" id="cb63"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">onSubmit</span>(e) {</span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a>  e<span class="op">.</span><span class="fu">preventDefault</span>()<span class="op">;</span></span>
<span id="cb63-3"><a href="#cb63-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> query <span class="op">=</span> form<span class="op">.</span><span class="fu">querySelector</span>(<span class="st">&quot;[name=query]&quot;</span>)<span class="op">.</span><span class="at">value</span><span class="op">;</span></span>
<span id="cb63-4"><a href="#cb63-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-5"><a href="#cb63-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> url <span class="op">=</span> <span class="kw">new</span> <span class="fu">URL</span>(location<span class="op">.</span><span class="at">href</span>)<span class="op">;</span></span>
<span id="cb63-6"><a href="#cb63-6" aria-hidden="true" tabindex="-1"></a>  url<span class="op">.</span><span class="at">searchParams</span><span class="op">.</span><span class="fu">set</span>(<span class="st">&quot;query&quot;</span><span class="op">,</span> query)<span class="op">;</span></span>
<span id="cb63-7"><a href="#cb63-7" aria-hidden="true" tabindex="-1"></a>  history<span class="op">.</span><span class="fu">pushState</span>(<span class="st">&quot;&quot;</span><span class="op">,</span> <span class="st">&quot;&quot;</span><span class="op">,</span> url)<span class="op">;</span></span>
<span id="cb63-8"><a href="#cb63-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-9"><a href="#cb63-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">search</span>(query)<span class="op">;</span></span>
<span id="cb63-10"><a href="#cb63-10" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Zde vidíme dvě novinky:</p>
<ol type="1">
<li><p>Objekt <code>URL</code> nabízí pohodlnou práci s webovými
adresami. V našem případě je nejzajímavější pod-objekt
<code>searchParams</code>, pomocí kterého můžeme snadno přistupovat
k části URL za otazníkem. Zpravidla se jí říká <em>search
parameters</em> a tradičně do ní vkládáme řetězce ve tvaru klíč-hodnota.
Jejich konkrétní formát nemusíme řešit, neboť to za nás zařídí právě
objekt <code>URL</code>.</p></li>
<li><p>Proměnnou <code>history</code>, která nám mj. dovoluje měnit
hodnotu v adresním řádku bez nutnosti navigace na nový dokument.
V uvedeném řešení k tomu používáme metodu
<code>pushState</code>.</p></li>
</ol>
<p>Tím jsme vyřešili první krok ze tří. Pro ten druhý se musíme dozvědět
o tom, že došlo k uživatelem vyvolané změně adresního řádku. K tomu
slouží událost <code>popstate</code>, která nastává na globálním objektu
<code>window</code>:</p>
<div class="sourceCode" id="cb64"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">load</span>() {</span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> url <span class="op">=</span> <span class="kw">new</span> <span class="fu">URL</span>(location<span class="op">.</span><span class="at">href</span>)<span class="op">;</span></span>
<span id="cb64-3"><a href="#cb64-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> query <span class="op">=</span> url<span class="op">.</span><span class="at">searchParams</span><span class="op">.</span><span class="fu">get</span>(<span class="st">&quot;query&quot;</span>)<span class="op">;</span></span>
<span id="cb64-4"><a href="#cb64-4" aria-hidden="true" tabindex="-1"></a>  query <span class="op">&amp;&amp;</span> <span class="fu">search</span>(query)<span class="op">;</span></span>
<span id="cb64-5"><a href="#cb64-5" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb64-6"><a href="#cb64-6" aria-hidden="true" tabindex="-1"></a><span class="bu">window</span><span class="op">.</span><span class="fu">addEventListener</span>(<span class="st">&quot;popstate&quot;</span><span class="op">,</span> e <span class="kw">=&gt;</span> <span class="fu">load</span>())<span class="op">;</span></span></code></pre></div>
<p>Jedná se o proces symetrický k odeslání formuláře. Prohlédneme
aktuální adresu, a pokud je v ní zaznamenán hledaný text, provedeme
hledání.</p>
<p>Poslední třetí krok je jen pomyslná třešnička na dortu, protože
k jeho splnění stačí novou funkci <code>load</code> zavolat po prvním
načtení stránky. Celý upravený kód proto bude vypadat takto:</p>
<div class="sourceCode" id="cb65"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">search</span>(query) {</span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> xhr <span class="op">=</span> <span class="kw">new</span> <span class="bu">XMLHttpRequest</span>()<span class="op">;</span></span>
<span id="cb65-3"><a href="#cb65-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> url <span class="op">=</span> <span class="vs">`/search?query=</span><span class="sc">${</span><span class="pp">encodeURIComponent</span>(query)<span class="sc">}</span><span class="vs">`</span><span class="op">;</span></span>
<span id="cb65-4"><a href="#cb65-4" aria-hidden="true" tabindex="-1"></a>  xhr<span class="op">.</span><span class="at">responseType</span> <span class="op">=</span> <span class="st">&quot;json&quot;</span><span class="op">;</span></span>
<span id="cb65-5"><a href="#cb65-5" aria-hidden="true" tabindex="-1"></a>  xhr<span class="op">.</span><span class="fu">open</span>(<span class="st">&quot;GET&quot;</span><span class="op">,</span> url)<span class="op">;</span></span>
<span id="cb65-6"><a href="#cb65-6" aria-hidden="true" tabindex="-1"></a>  xhr<span class="op">.</span><span class="fu">send</span>()<span class="op">;</span></span>
<span id="cb65-7"><a href="#cb65-7" aria-hidden="true" tabindex="-1"></a>  xhr<span class="op">.</span><span class="fu">addEventListener</span>(<span class="st">&quot;load&quot;</span><span class="op">,</span> e <span class="kw">=&gt;</span> <span class="fu">showResults</span>(xhr<span class="op">,</span> query))<span class="op">;</span></span>
<span id="cb65-8"><a href="#cb65-8" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb65-9"><a href="#cb65-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-10"><a href="#cb65-10" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">onSubmit</span>(e) {</span>
<span id="cb65-11"><a href="#cb65-11" aria-hidden="true" tabindex="-1"></a>  e<span class="op">.</span><span class="fu">preventDefault</span>()<span class="op">;</span></span>
<span id="cb65-12"><a href="#cb65-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> query <span class="op">=</span> form<span class="op">.</span><span class="fu">querySelector</span>(<span class="st">&quot;[name=query]&quot;</span>)<span class="op">.</span><span class="at">value</span><span class="op">;</span></span>
<span id="cb65-13"><a href="#cb65-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-14"><a href="#cb65-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> url <span class="op">=</span> <span class="kw">new</span> <span class="fu">URL</span>(location<span class="op">.</span><span class="at">href</span>)<span class="op">;</span></span>
<span id="cb65-15"><a href="#cb65-15" aria-hidden="true" tabindex="-1"></a>  url<span class="op">.</span><span class="at">searchParams</span><span class="op">.</span><span class="fu">set</span>(<span class="st">&quot;query&quot;</span><span class="op">,</span> query)<span class="op">;</span></span>
<span id="cb65-16"><a href="#cb65-16" aria-hidden="true" tabindex="-1"></a>  history<span class="op">.</span><span class="fu">pushState</span>(<span class="st">&quot;&quot;</span><span class="op">,</span> <span class="st">&quot;&quot;</span><span class="op">,</span> url)<span class="op">;</span></span>
<span id="cb65-17"><a href="#cb65-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-18"><a href="#cb65-18" aria-hidden="true" tabindex="-1"></a>  <span class="fu">search</span>(query)<span class="op">;</span></span>
<span id="cb65-19"><a href="#cb65-19" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb65-20"><a href="#cb65-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-21"><a href="#cb65-21" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">load</span>() {</span>
<span id="cb65-22"><a href="#cb65-22" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> url <span class="op">=</span> <span class="kw">new</span> <span class="fu">URL</span>(location<span class="op">.</span><span class="at">href</span>)<span class="op">;</span></span>
<span id="cb65-23"><a href="#cb65-23" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> query <span class="op">=</span> url<span class="op">.</span><span class="at">searchParams</span><span class="op">.</span><span class="fu">get</span>(<span class="st">&quot;query&quot;</span>)<span class="op">;</span></span>
<span id="cb65-24"><a href="#cb65-24" aria-hidden="true" tabindex="-1"></a>  query <span class="op">&amp;&amp;</span> <span class="fu">search</span>(query)<span class="op">;</span></span>
<span id="cb65-25"><a href="#cb65-25" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb65-26"><a href="#cb65-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-27"><a href="#cb65-27" aria-hidden="true" tabindex="-1"></a>form<span class="op">.</span><span class="fu">addEventListener</span>(<span class="st">&quot;submit&quot;</span><span class="op">,</span> onSubmit)<span class="op">;</span></span>
<span id="cb65-28"><a href="#cb65-28" aria-hidden="true" tabindex="-1"></a><span class="bu">window</span><span class="op">.</span><span class="fu">addEventListener</span>(<span class="st">&quot;popstate&quot;</span><span class="op">,</span> e <span class="kw">=&gt;</span> <span class="fu">load</span>())<span class="op">;</span></span>
<span id="cb65-29"><a href="#cb65-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-30"><a href="#cb65-30" aria-hidden="true" tabindex="-1"></a><span class="fu">load</span>()<span class="op">;</span></span></code></pre></div>
<p>Pozorného čtenáře možná napadla otázka, kdy je správná chvíle na
propsání právě hledaného termínu do URL. Jistým pohledem by dávalo smysl
tuto akci vykonat uvnitř funkce <code>search</code>, protože právě při
hledání má dojít ke změně v adresním řádku. Nabídneme dva argumenty,
proč je naše současné řešení vhodnější:</p>
<ol type="1">
<li><p>Funkce <code>search</code> zůstává určená pouze k provedení
hledání. Pokud bychom do ní vložili i změnu URL, došlo by k přílišnému
rozšíření její zodpovědnosti (byla by <em>moc chytrá</em>). Znamenalo by
to například, že není možné provést hledání bez změny URL.</p></li>
<li><p>Funkci <code>search</code> voláme i v situacích, kdy změna URL
není nutná, resp. žádoucí. Je to jednak při prvním načtení stránky
(v důsledku volání funkce <code>load</code>) a jednak při změně
v adresním řádku (v důsledku události <code>popstate</code>). V obou
těchto případech už v URL správná data jsou.</p></li>
</ol>
<p>Výše uvedené pozorování můžeme shrnout do poučky, která platí téměř
ve všech podobných situacích: <strong>Změna hodnoty v adresním řádku by
měla být vyvolána jen v důsledku uživatelovy interakce.</strong></p>
<h2 id="koumáci-funkcionální-iterace">Koumáci: funkcionální iterace</h2>
<p>Ve třetí kapitole jsme si předvedli alternativní možnosti iterace
polí. Pojďme si nyní na úloze z této kapitoly vyzkoušet refactoring kódu
pomocí funkcionální iterace.</p>
<p>Podstatou funkcionální iterace je opakované používání malých funkcí
vykonávaných automaticky nad položkami v poli. Ideálním startovním bodem
je funkce <code>showResults</code>, ve které se vytváří jednotlivé
výsledky hledání. Zajímá nás tato její část:</p>
<div class="sourceCode" id="cb66"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (<span class="kw">let</span> i<span class="op">=</span><span class="dv">0</span><span class="op">;</span> i<span class="op">&lt;</span>songs<span class="op">.</span><span class="at">length</span><span class="op">;</span> i<span class="op">++</span>) {</span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> song <span class="op">=</span> <span class="fu">buildSong</span>(songs[i])<span class="op">;</span></span>
<span id="cb66-3"><a href="#cb66-3" aria-hidden="true" tabindex="-1"></a>  ol<span class="op">.</span><span class="fu">append</span>(song)<span class="op">;</span></span>
<span id="cb66-4"><a href="#cb66-4" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Procházíme pole <code>songs</code> a pro každou jeho položku vyrobíme
HTML prvek. To je úloha pro funkcionálně-iterační metodu
<code>map</code>. Její použití nad polem vrátí nové pole, jehož každá
položka vznikla vykonáním malé iterační funkce nad položkou pole
původního. V našem případě by to mohlo vypadat takto:</p>
<div class="sourceCode" id="cb67"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> items <span class="op">=</span> songs<span class="op">.</span><span class="fu">map</span>(buildSong)<span class="op">;</span></span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a>ol<span class="op">.</span><span class="fu">append</span>(<span class="op">...</span>items)<span class="op">;</span></span></code></pre></div>
<p>Funkce <code>buildSong</code> dostává jako (první) parametr
jednotlivé položky odpovědi a vrací nově vzniklý HTML prvek
<code>&lt;li&gt;</code>. V proměnné <code>items</code> je tedy pole HTML
prvků. Ty bychom rádi naráz vložili do seznamu <code>ol</code>, ovšem
metoda <code>append</code> neumí pracovat s polem. Je nicméně
variadická, tj. umí přijmout libovolný počet parametrů. Použijeme proto
operátor tří teček <code>...</code> (nazývá se <em>spread
operator</em>), jehož úkolem je převést hodnoty pole na jednotlivé
parametry funkce. Jedná se o jakési <em>rozbalení</em> položek pole tam,
kde jsou očekávány položky oddělené čárkou.</p>
<p>Použitím funkce <code>map</code> se kód nejen zkrátil a zpřehlednil,
ale je i výkonnější: nemusíme volat metodu <code>append</code> tolikrát,
kolik vypisujeme výsledků.</p>
<p>Zatím jsme si ukázali dvě metody užitečné pro funkcionální iteraci,
<code>forEach</code> a <code>map</code>. Je to jen drobná ochutnávka
z širokého množství metod, které nám JavaScriptová pole nabízí. Pojďme
si ještě ukázat jednu další, která se často hodí: <code>filter</code>.
Jejím parametrem je opět malá funkce (někdy se jí říká
<em>predikát</em>), která bude vykonána nad každou položkou pole. Úkolem
této funkce je vrátit pravdivostní hodnotu <code>true</code> či
<code>false</code>. Výsledkem volání <code>filter</code> je potom nové
pole, které obsahuje jen ty položky původního pole, pro které byla
predikátem vrácena hodnota <code>true</code>.</p>
<p>Představme si, že backend v rámci nalezených výsledků vrátí i rok, ve
kterém píseň vznikla. Použije k tomu nový klíč <code>year</code>, jehož
hodnotou je číslo. Jedna položka odpovědi tedy vypadá takto:</p>
<div class="sourceCode" id="cb68"><pre
class="sourceCode json"><code class="sourceCode json"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a><span class="fu">{</span></span>
<span id="cb68-2"><a href="#cb68-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&quot;title&quot;</span><span class="fu">:</span> <span class="st">&quot;Mám styl Čendy&quot;</span><span class="fu">,</span></span>
<span id="cb68-3"><a href="#cb68-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&quot;text&quot;</span><span class="fu">:</span> <span class="st">&quot;Mezi námi je &lt;em&gt;mnoho&lt;/em&gt; chvil&quot;</span><span class="fu">,</span></span>
<span id="cb68-4"><a href="#cb68-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&quot;url&quot;</span><span class="fu">:</span> <span class="st">&quot;https://example.com/&quot;</span><span class="fu">,</span></span>
<span id="cb68-5"><a href="#cb68-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&quot;year&quot;</span><span class="fu">:</span> <span class="dv">1984</span></span>
<span id="cb68-6"><a href="#cb68-6" aria-hidden="true" tabindex="-1"></a><span class="fu">}</span></span></code></pre></div>
<p>Kdybychom chtěli vypsat jen ty <em>nové</em> písně, které vznikly
v roce 1984 a později, napsali bychom si nejprve malý testovací
predikát:</p>
<div class="sourceCode" id="cb69"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">isNew</span>(song) {</span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> (song<span class="op">.</span><span class="at">year</span> <span class="op">&gt;=</span> <span class="dv">1984</span>)<span class="op">;</span></span>
<span id="cb69-3"><a href="#cb69-3" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Ve výpisu bychom pak použili navíc metodu <code>filter</code>:</p>
<div class="sourceCode" id="cb70"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> items <span class="op">=</span> songs<span class="op">.</span><span class="fu">filter</span>(isNew)<span class="op">.</span><span class="fu">map</span>(buildSong)<span class="op">;</span></span>
<span id="cb70-2"><a href="#cb70-2" aria-hidden="true" tabindex="-1"></a>ol<span class="op">.</span><span class="fu">append</span>(<span class="op">...</span>items)<span class="op">;</span></span></code></pre></div>
<p>Takové řetězové volání je ve světě funkcionálního programovaní docela
běžné. Zároveň je to místo, kde můžeme s výhodou použít zkráceného
zápisu anonymních arrow funkcí:</p>
<div class="sourceCode" id="cb71"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> items <span class="op">=</span> songs<span class="op">.</span><span class="fu">filter</span>(song <span class="kw">=&gt;</span> song<span class="op">.</span><span class="at">year</span> <span class="op">&gt;=</span> <span class="dv">1984</span>)<span class="op">.</span><span class="fu">map</span>(buildSong)<span class="op">;</span></span>
<span id="cb71-2"><a href="#cb71-2" aria-hidden="true" tabindex="-1"></a>ol<span class="op">.</span><span class="fu">append</span>(<span class="op">...</span>items)<span class="op">;</span></span></code></pre></div>
<p>Nyní už samostatný predikát <code>isNew</code> nepotřebujeme. Koumáci
si po přečtení této podkapitoly možná půjdou dohledat, které další
metody pro funkcionální iteraci existují. Bez detailnějších ukázek
můžeme napovědět, že ty nejdůležitější ještě neprobrané jsou:</p>
<ul>
<li><p><code>reduce</code> sloužící k vytvoření jediného výsledku na
základě všech položek pole (např. součet, průměr, největší
hodnota…);</p></li>
<li><p><code>some</code> a <code>every</code>, které ověřují, zda
některá či všechny položky pole splňují daný predikát;</p></li>
<li><p><code>find</code>, která vrátí první položku pole splňující
nějakou podmínku.</p></li>
</ul>
<p>U funkcionální iterace si ale ukážeme ještě jednu věc: parametry,
které jsou iteračním funkcím předávány. Je zřejmé, že první a hlavní
parametr je vždy ta položka pole, kterou právě zpracováváme. Další
parametry bychom mohli sami předávat použitím uzávěry. Abychom si práci
ušetřili, většina iteračních metod automaticky předává i další dva často
užitečné parametry: index (pořadí, od nuly) položky a celé pole, které
právě zpracováváme. Kdybychom nepoužívali pro výpis nalezených výsledků
číslovaný seznam (HTML značka <code>&lt;ol&gt;</code>), mohli bychom
snadno ve funkci <code>buildSong</code> doplnit k názvu i pořadí
a celkový počet:</p>
<div class="sourceCode" id="cb72"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">buildSong</span>(song<span class="op">,</span> index<span class="op">,</span> allSongs) {</span>
<span id="cb72-2"><a href="#cb72-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> item <span class="op">=</span> <span class="bu">document</span><span class="op">.</span><span class="fu">createElement</span>(<span class="st">&quot;li&quot;</span>)<span class="op">;</span></span>
<span id="cb72-3"><a href="#cb72-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> number <span class="op">=</span> <span class="vs">`</span><span class="sc">${</span>index<span class="op">+</span><span class="dv">1</span><span class="sc">}</span><span class="vs">/</span><span class="sc">${</span>allSongs<span class="op">.</span><span class="at">length</span><span class="sc">}</span><span class="vs">`</span><span class="op">;</span></span>
<span id="cb72-4"><a href="#cb72-4" aria-hidden="true" tabindex="-1"></a>  item<span class="op">.</span><span class="at">innerHTML</span> <span class="op">=</span> <span class="vs">`</span></span>
<span id="cb72-5"><a href="#cb72-5" aria-hidden="true" tabindex="-1"></a><span class="vs">    </span><span class="sc">${</span>number<span class="sc">}</span><span class="vs">: &lt;a href=&quot;</span><span class="sc">${</span>song<span class="op">.</span><span class="at">url</span><span class="sc">}</span><span class="vs">&quot;&gt;</span><span class="sc">${</span>song<span class="op">.</span><span class="at">title</span><span class="sc">}</span><span class="vs">&lt;/a&gt;</span></span>
<span id="cb72-6"><a href="#cb72-6" aria-hidden="true" tabindex="-1"></a><span class="vs">    &lt;br/&gt; </span><span class="sc">${</span>song<span class="op">.</span><span class="at">text</span><span class="sc">}</span></span>
<span id="cb72-7"><a href="#cb72-7" aria-hidden="true" tabindex="-1"></a><span class="vs">  `</span><span class="op">;</span></span>
<span id="cb72-8"><a href="#cb72-8" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> item<span class="op">;</span></span>
<span id="cb72-9"><a href="#cb72-9" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb72-10"><a href="#cb72-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb72-11"><a href="#cb72-11" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> items <span class="op">=</span> songs<span class="op">.</span><span class="fu">map</span>(buildSong)<span class="op">;</span></span></code></pre></div>
<h2 id="profíci-fetch-promises-a-asyncawait">Profíci: fetch, Promises
a async/await</h2>
<p>V minulé kapitole jsme představili objekt <code>XMLHttpRequest</code>
a zároveň si slíbili modernější alternativu, totiž funkci
<code>fetch</code>. Její rolí je taktéž provedení HTTP požadavku, takže
hned do začátku se nabízí otázka, v čem že je vůbec použití
<code>fetch</code> lepší. Fakticky totiž žádnou funkcionalitu, kterou
bychom v <code>XMLHttpRequest</code> neměli, nenabízí. Hlavní rozdíl tak
není v tom, <strong>co</strong> pomocí fetch vykonáme, ale
<strong>jak</strong>.</p>
<p>Abychom systém práce s funkcí <code>fetch</code> dobře pochopili
a docenili, budeme se muset nejprve chvíli zabývat
<strong>asynchronními</strong> funkcemi v JavaScriptu. To jsou takové,
které jako jeden ze svých parametrů přijímají <em>další</em> funkci
proto, aby ji dříve či později samy vykonaly. Takovému parametru se
zpravidla říká <strong>callback</strong> a v této knize jsme zatím
potkali dvě místa, kde se callbacky používají:</p>
<ul>
<li><p>metodu <code>addEventListener</code>, které dáváme callback
k vykonání vždy, když nastane požadovaná událost;</p></li>
<li><p>funkci <code>setTimeout</code>, které dáváme callback k vykonání
po uplynutí daného času.</p></li>
</ul>
<p>Asynchronních funkcí je mnohem více a typicky se s nimi setkáváme
u aktivit, které trvají – vágně řečeno – <strong>dlouho</strong>. Aby se
prohlížeč při jejich vykonávání nezasekl, necháme jej vykonávat
potřebnou funkcionalitu <em>na pozadí</em> a pomocí callbacku řekneme,
co se má stát, až tato dlouhotrvající aktivita skončí. Nutnosti
předávání callbacku se říká CPS (anglicky <em>continuation passing
style</em>). Pro nováčky ve světě JavaScriptu může být takový koncept
matoucí – zejména pokud přicházejí z jazyků, ve kterých se asynchronní
funkce nevyskytují.</p>
<p>Situaci s CPS dále komplikuje skutečnost, že callback je nutné
zkombinovat také s ostatními parametry, které funkce ke svému chování
potřebuje. Například u funkce <code>setTimeout</code> máme parametry
dva: jeden callback a jednu časovou hodnotu. Jejich pořadí si po letech
práce stále pletou i velmi zkušení programátoři. Dříve nebo později si
začnou všímat, že u volání asynchronních funkcí se callback tak nějak
<em>nehodí</em>; že jeho přítomnost je v kódu rušivá a snižuje
čitelnost. Proto se v JavaScriptu mezi lety 2012 až 2015 objevil
alternativní způsob práce s CPS, zvaný <strong>Promise</strong> (česky
<em>příslib</em>). Použití Promise nepřináší do jazyka nic koncepčně
nového, jedná se jen o tzv. <em>návrhový vzor</em>, tedy doporučený
způsob, jak řešit často se opakující úlohu.</p>
<p>Při použití Promise se callback nepředává přímo do asynchronní
funkce. Namísto toho nám asynchronní funkce vrátí speciální hodnotu
(nazvanou Promise), která vyjadřuje skutečnost, že přestože funkce již
skončila, její práce ještě není hotová. Callback pak předáme k takto
získané Promise její metodou <code>then</code>. Můžeme si to prohlédnout
na hypotetickém příkladu modernější varianty funkce
<code>setTimeout</code>:</p>
<div class="sourceCode" id="cb73"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">done</span>() {</span>
<span id="cb73-2"><a href="#cb73-2" aria-hidden="true" tabindex="-1"></a>  <span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(<span class="st">&quot;hotovo!&quot;</span>)<span class="op">;</span></span>
<span id="cb73-3"><a href="#cb73-3" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb73-4"><a href="#cb73-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-5"><a href="#cb73-5" aria-hidden="true" tabindex="-1"></a><span class="co">// starý způsob</span></span>
<span id="cb73-6"><a href="#cb73-6" aria-hidden="true" tabindex="-1"></a><span class="pp">setTimeout</span>(done<span class="op">,</span> <span class="dv">500</span>)<span class="op">;</span></span>
<span id="cb73-7"><a href="#cb73-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-8"><a href="#cb73-8" aria-hidden="true" tabindex="-1"></a><span class="co">// nový způsob</span></span>
<span id="cb73-9"><a href="#cb73-9" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> promise <span class="op">=</span> <span class="fu">setTimeout2</span>(<span class="dv">500</span>)<span class="op">;</span></span>
<span id="cb73-10"><a href="#cb73-10" aria-hidden="true" tabindex="-1"></a>promise<span class="op">.</span><span class="fu">then</span>(done)<span class="op">;</span></span></code></pre></div>
<p>Tato ukázka je jen teoretická, protože <code>setTimeout2</code>
neexistuje – ale kdyby ji dnes někdo navrhl, jistě by fungovala takto.
Na první pohled to nevypadá, že bychom pomocí Promise získali nějaký
užitek. Jakmile však náš kód začne být složitější, ukáže se, že práce
s Promises jej výrazně zjednodušuje.</p>
<p>Pro lepší pochopení můžeme na objekt typu Promise nahlížet jako na
jakousi černou krabičku, která je prázdná, ale jednoho dne se v ní
objeví nějaká hodnota (opravdový výsledek té asynchronní funkce, která
Promise vrátila). Nevíme, kdy to bude, ale můžeme k této krabičce přidat
callback a ten bude vykonán, jakmile se hodnota objeví. Tím se pomalu
vracíme zpět k funkci <code>fetch</code>, která Promise používá, tedy
vrací. A to hned dvakrát, protože zpracování odpovědi od serveru je
rozděleno na dva kroky: když po síti dorazí hlavičky HTTP odpovědi
a když následně dorazí i celé tělo:</p>
<div class="sourceCode" id="cb74"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">onError</span>(e) {</span>
<span id="cb74-2"><a href="#cb74-2" aria-hidden="true" tabindex="-1"></a>  <span class="bu">console</span><span class="op">.</span><span class="fu">error</span>(<span class="st">&quot;Chyba při získávání dat&quot;</span><span class="op">,</span> e)<span class="op">;</span></span>
<span id="cb74-3"><a href="#cb74-3" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb74-4"><a href="#cb74-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-5"><a href="#cb74-5" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">onBody</span>(data) {</span>
<span id="cb74-6"><a href="#cb74-6" aria-hidden="true" tabindex="-1"></a>  <span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(data)<span class="op">;</span></span>
<span id="cb74-7"><a href="#cb74-7" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb74-8"><a href="#cb74-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-9"><a href="#cb74-9" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">onResponse</span>(response) {</span>
<span id="cb74-10"><a href="#cb74-10" aria-hidden="true" tabindex="-1"></a>  response<span class="op">.</span><span class="fu">json</span>()<span class="op">.</span><span class="fu">then</span>(onBody<span class="op">,</span> onError)<span class="op">;</span></span>
<span id="cb74-11"><a href="#cb74-11" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb74-12"><a href="#cb74-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-13"><a href="#cb74-13" aria-hidden="true" tabindex="-1"></a><span class="fu">fetch</span>(url)<span class="op">.</span><span class="fu">then</span>(onResponse<span class="op">,</span> onError)<span class="op">;</span></span></code></pre></div>
<p>Funkce <code>onResponse</code> je vykonána, jakmile dorazí hlavičky
odpovědi. Jejím parametrem je objekt odpovědi, jehož metody dovolují
přístup k získaným datům. Metodou <code>json()</code> vyžádáme tělo ve
formátu JSON, ale protože veškerá data nemusela zatím dorazit, jedná se
opět o asynchronní funkci. Její vrácené Promise pak pomocí
<code>then</code> předáme callback <code>onBody</code>, který dostane
veškerá data vrácená ze serveru.</p>
<p>Za povšimnutí stojí, že metodě <code>then</code> můžeme předat
i druhý callback (v našem případě funkci <code>onError</code>). Ten bude
vykonán, pokud asynchronní funkce nedokáže splnit svůj úkol. Platí tedy,
že v případě úspěchu bude vykonán první callback a v případě neúspěchu
ten druhý. Zde vidíme jasnou výhodu Promises v porovnání s předáváním
jednoho callbacku přímo asynchronní funkci. U něj bychom museli případný
neúspěch rozhodovat na základě parametru, se kterým bude vykonán.</p>
<p>V praxi se s takovým použitím Promises, resp. metody
<code>then</code>, ale většinou nesetkáme. Přechod od callbacků
k Promises byl dobrý evoluční krok, ale v roce 2017 se JavaScript dočkal
ještě razantnějšího vylepšení práce s CPS: klíčových slov
<code>async</code> a <code>await</code>. Jejich použití je úzce spjaté
s Promises a dovoluje nám poskládat zdrojový kód tak, aby na první
pohled působil jako synchronní. Konkrétně:</p>
<ul>
<li><p>Klíčové slovo <code>await</code> představuje alternativu k volání
metody <code>then</code>. Můžeme jej napsat jako operátor před hodnotu,
která je Promise. Vyjadřujeme tím, že následující řádky kódu chceme
vykonat až poté, co tato Promise nabude nějaké hodnoty – stejně jako
kdybychom je zabalili do malé anonymní funkce a tu předali jako callback
metodě <code>then</code>.</p></li>
<li><p>To ovšem znamená, že právě definovaná funkce (ta, ve které
použijeme <code>await</code>) bude asynchronní; některé její řádky (ty,
co následují za <code>await</code>) se vykonají až poté, co funkce
skončí. Proto ji musíme označit klíčovým slovem <code>async</code>
a díky tomu bude její hodnota automaticky převedena na Promise.</p></li>
</ul>
<p>Nejlépe to pochopíme úpravou minulé ukázky na async/await:</p>
<div class="sourceCode" id="cb75"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true" tabindex="-1"></a><span class="kw">async</span> <span class="kw">function</span> <span class="fu">search</span>(query) {</span>
<span id="cb75-2"><a href="#cb75-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">try</span> {</span>
<span id="cb75-3"><a href="#cb75-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> url <span class="op">=</span> <span class="vs">`/search?query=</span><span class="sc">${</span><span class="pp">encodeURIComponent</span>(query)<span class="sc">}</span><span class="vs">`</span><span class="op">;</span></span>
<span id="cb75-4"><a href="#cb75-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> response <span class="op">=</span> <span class="cf">await</span> <span class="fu">fetch</span>(url)<span class="op">;</span></span>
<span id="cb75-5"><a href="#cb75-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> songs <span class="op">=</span> <span class="cf">await</span> response<span class="op">.</span><span class="fu">json</span>()<span class="op">;</span></span>
<span id="cb75-6"><a href="#cb75-6" aria-hidden="true" tabindex="-1"></a>  } <span class="cf">catch</span> (e) {</span>
<span id="cb75-7"><a href="#cb75-7" aria-hidden="true" tabindex="-1"></a>    <span class="bu">console</span><span class="op">.</span><span class="fu">error</span>(<span class="st">&quot;Chyba při získávání dat&quot;</span><span class="op">,</span> e)<span class="op">;</span></span>
<span id="cb75-8"><a href="#cb75-8" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb75-9"><a href="#cb75-9" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Méně zkušený programátor by téměř nepoznal, že se jedná o asynchronní
kód, ve kterém se objevuje hned několik proměnných typu Promise.
Výsledek je snadno čitelný, ušetřili jsme několik anonymních funkcí
a zároveň dokážeme dobře zpracovat případné chyby, neboť součástí
implementace klíčového slova <code>await</code> je i korektní spolupráce
s konstrukcí <code>try-catch</code>.</p>
<p>Na závěr podkapitoly si ještě ujasněme, jak s touto funkcí
<code>search</code> pracovat. Před její definicí se objevuje klíčové
slovo <code>async</code>, což čtenáři dává garanci, že funkce vrací
Promise. Můžeme ji tedy volat těmito způsoby:</p>
<ol type="1">
<li><p>Úplně běžně, pokud nás její návratová hodnota nezajímá:</p>
<div class="sourceCode" id="cb76"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">onSubmit</span>(e) {</span>
<span id="cb76-2"><a href="#cb76-2" aria-hidden="true" tabindex="-1"></a>  e<span class="op">.</span><span class="fu">preventDefault</span>()<span class="op">;</span></span>
<span id="cb76-3"><a href="#cb76-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> query <span class="op">=</span> form<span class="op">.</span><span class="fu">querySelector</span>(<span class="st">&quot;[name=query]&quot;</span>)<span class="op">.</span><span class="at">value</span><span class="op">;</span></span>
<span id="cb76-4"><a href="#cb76-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">search</span>(query)<span class="op">;</span></span>
<span id="cb76-5"><a href="#cb76-5" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div></li>
<li><p>Pomocí metody <code>then</code>, pokud chceme vykonávat nějakou
aktivitu, až když bude hledání hotovo:</p>
<div class="sourceCode" id="cb77"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">onDone</span>() {</span>
<span id="cb77-2"><a href="#cb77-2" aria-hidden="true" tabindex="-1"></a>  <span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(<span class="st">&quot;Hledání hotovo&quot;</span>)<span class="op">;</span></span>
<span id="cb77-3"><a href="#cb77-3" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb77-4"><a href="#cb77-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb77-5"><a href="#cb77-5" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">onSubmit</span>(e) {</span>
<span id="cb77-6"><a href="#cb77-6" aria-hidden="true" tabindex="-1"></a>  e<span class="op">.</span><span class="fu">preventDefault</span>()<span class="op">;</span></span>
<span id="cb77-7"><a href="#cb77-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> query <span class="op">=</span> form<span class="op">.</span><span class="fu">querySelector</span>(<span class="st">&quot;[name=query]&quot;</span>)<span class="op">.</span><span class="at">value</span><span class="op">;</span></span>
<span id="cb77-8"><a href="#cb77-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">search</span>(query)<span class="op">.</span><span class="fu">then</span>(onDone)<span class="op">;</span></span>
<span id="cb77-9"><a href="#cb77-9" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div></li>
<li><p>Ekvivalentně pomocí <code>await</code>, což s sebou ovšem nese
povinnost označení našeho posluchače jako <code>async</code>:</p>
<div class="sourceCode" id="cb78"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true" tabindex="-1"></a><span class="kw">async</span> <span class="kw">function</span> <span class="fu">onSubmit</span>(e) {</span>
<span id="cb78-2"><a href="#cb78-2" aria-hidden="true" tabindex="-1"></a>  e<span class="op">.</span><span class="fu">preventDefault</span>()<span class="op">;</span></span>
<span id="cb78-3"><a href="#cb78-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> query <span class="op">=</span> form<span class="op">.</span><span class="fu">querySelector</span>(<span class="st">&quot;[name=query]&quot;</span>)<span class="op">.</span><span class="at">value</span><span class="op">;</span></span>
<span id="cb78-4"><a href="#cb78-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">await</span> <span class="fu">search</span>(query)<span class="op">;</span></span>
<span id="cb78-5"><a href="#cb78-5" aria-hidden="true" tabindex="-1"></a>  <span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(<span class="st">&quot;Hledání hotovo&quot;</span>)<span class="op">;</span></span>
<span id="cb78-6"><a href="#cb78-6" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div></li>
</ol>
<p>Tato poslední varianta si zaslouží speciální pozornost. Není na ní
nic špatného, ale používáním asynchronních posluchačů se vystavujeme
riziku nepozornosti, která může vyústit v zákeřnou chybu. Vzpomeňme na
úlohu z předchozí kapitoly, ve které jsme ověřovali dostupnost
uživatelského jména. Čtenář by po pročtení části
o <strong>async/await</strong> mohl chtít zmíněnou kontrolu
implementovat v rámci události <code>submit</code> takto:</p>
<div class="sourceCode" id="cb79"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a><span class="kw">async</span> <span class="kw">function</span> <span class="fu">checkUsername</span>() {</span>
<span id="cb79-2"><a href="#cb79-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ...</span></span>
<span id="cb79-3"><a href="#cb79-3" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb79-4"><a href="#cb79-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-5"><a href="#cb79-5" aria-hidden="true" tabindex="-1"></a><span class="kw">async</span> <span class="kw">function</span> <span class="fu">onSubmit</span>(e) {</span>
<span id="cb79-6"><a href="#cb79-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> available <span class="op">=</span> <span class="cf">await</span> <span class="fu">checkUsername</span>()<span class="op">;</span></span>
<span id="cb79-7"><a href="#cb79-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (<span class="op">!</span>available) { e<span class="op">.</span><span class="fu">preventDefault</span>()<span class="op">;</span> }</span>
<span id="cb79-8"><a href="#cb79-8" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb79-9"><a href="#cb79-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-10"><a href="#cb79-10" aria-hidden="true" tabindex="-1"></a>form<span class="op">.</span><span class="fu">addEventListener</span>(<span class="st">&quot;submit&quot;</span><span class="op">,</span> onSubmit)<span class="op">;</span></span></code></pre></div>
<p>Umíme vysvětlit, proč tento nevinně vypadající kód nemůže fungovat?
Pro snazší pochopení funkci <code>onSubmit</code> ekvivalentně přepíšeme
na kód bez klíčových slov <code>async</code> a <code>await</code>, tj.
pomocí <code>then</code>:</p>
<div class="sourceCode" id="cb80"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb80-1"><a href="#cb80-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">onSubmit</span>(e) {</span>
<span id="cb80-2"><a href="#cb80-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">checkUsername</span>()<span class="op">.</span><span class="fu">then</span>(available <span class="kw">=&gt;</span> {</span>
<span id="cb80-3"><a href="#cb80-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (<span class="op">!</span>available) { e<span class="op">.</span><span class="fu">preventDefault</span>()<span class="op">;</span> }</span>
<span id="cb80-4"><a href="#cb80-4" aria-hidden="true" tabindex="-1"></a>  })<span class="op">;</span></span>
<span id="cb80-5"><a href="#cb80-5" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Kdy dojde k vykonání vnitřní anonymní arrow funkce? Příliš pozdě; až
dávno po skončení posluchače <code>onSubmit</code>. Tou dobou už je
ovšem příliš pozdě volat metodu <code>e.preventDefault()</code>, tuto
možnost jsme měli jen během vykonávání posluchače. Plyne z toho poučení:
<em>Zabránit výchozímu zpracování události (např. odeslání formuláře)
můžeme jen v rámci synchronního kódu posluchače. Jakmile je naše
kontrola asynchronní, nelze pomocí ní odeslání podmíněně
ovlivňovat.</em></p>
<h1 id="spa-administrační-systém">SPA administrační systém</h1>
<h2 id="úloha-5">Úloha</h2>
<p>V rámci webových stránek nabízíme možnost přidávání komentářů.
Komentáře jsou zobrazovány až po jejich schválení správcem webu. Proto
potřebujeme administrační systém, který vypíše komentáře a k nim
jednotlivé možnosti:</p>
<ul>
<li><p>nové komentáře lze <em>schválit</em> nebo
<em>smazat</em>,</p></li>
<li><p>již schválené komentáře lze <em>smazat</em>.</p></li>
</ul>
<p>Serverová strana je již připravena. Poskytuje následující API:</p>
<ul>
<li><p>výpis komentářů: <code>GET /comments</code>, každý komentář je
objekt s vlastnostmi <code>id</code>, <code>author</code>,
<code>text</code> a <code>approved</code> (typu
<code>boolean</code>)</p></li>
<li><p>schválení komentáře:
<code>POST /comments/id-komentare/approve</code></p></li>
<li><p>smazání komentáře:
<code>DELETE /comments/id-komentare</code></p></li>
</ul>
<h3 id="řešení-5">Řešení</h3>
<div class="sourceCode" id="cb81"><pre
class="sourceCode html"><code class="sourceCode html"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true" tabindex="-1"></a><span class="co">&lt;!-- kapitola-7.html --&gt;</span></span>
<span id="cb81-2"><a href="#cb81-2" aria-hidden="true" tabindex="-1"></a><span class="dt">&lt;</span><span class="kw">h2</span><span class="dt">&gt;</span>Nové komentáře<span class="dt">&lt;/</span><span class="kw">h2</span><span class="dt">&gt;</span></span>
<span id="cb81-3"><a href="#cb81-3" aria-hidden="true" tabindex="-1"></a><span class="dt">&lt;</span><span class="kw">ul</span> <span class="er">id</span><span class="ot">=</span><span class="st">&quot;new&quot;</span><span class="dt">&gt;&lt;/</span><span class="kw">ul</span><span class="dt">&gt;</span></span>
<span id="cb81-4"><a href="#cb81-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb81-5"><a href="#cb81-5" aria-hidden="true" tabindex="-1"></a><span class="dt">&lt;</span><span class="kw">h2</span><span class="dt">&gt;</span>Schválené komentáře<span class="dt">&lt;/</span><span class="kw">h2</span><span class="dt">&gt;</span></span>
<span id="cb81-6"><a href="#cb81-6" aria-hidden="true" tabindex="-1"></a><span class="dt">&lt;</span><span class="kw">ul</span> <span class="er">id</span><span class="ot">=</span><span class="st">&quot;approved&quot;</span><span class="dt">&gt;&lt;/</span><span class="kw">ul</span><span class="dt">&gt;</span></span>
<span id="cb81-7"><a href="#cb81-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb81-8"><a href="#cb81-8" aria-hidden="true" tabindex="-1"></a><span class="dt">&lt;</span><span class="kw">script</span> <span class="er">src</span><span class="ot">=</span><span class="st">&quot;kapitola-7.js&quot;</span><span class="dt">&gt;&lt;/</span><span class="kw">script</span><span class="dt">&gt;</span></span></code></pre></div>
<div class="sourceCode" id="cb82"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true" tabindex="-1"></a><span class="co">// kapitola-7.js</span></span>
<span id="cb82-2"><a href="#cb82-2" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">deleteComment</span>(id) {</span>
<span id="cb82-3"><a href="#cb82-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="fu">fetch</span>(<span class="vs">`/comments/</span><span class="sc">${</span>id<span class="sc">}</span><span class="vs">`</span><span class="op">,</span> {<span class="dt">method</span><span class="op">:</span> <span class="st">&quot;DELETE&quot;</span>})<span class="op">;</span></span>
<span id="cb82-4"><a href="#cb82-4" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb82-5"><a href="#cb82-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-6"><a href="#cb82-6" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">approveComment</span>(id) {</span>
<span id="cb82-7"><a href="#cb82-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="fu">fetch</span>(<span class="vs">`/comments/</span><span class="sc">${</span>id<span class="sc">}</span><span class="vs">/approve`</span><span class="op">,</span> {<span class="dt">method</span><span class="op">:</span> <span class="st">&quot;POST&quot;</span>})<span class="op">;</span></span>
<span id="cb82-8"><a href="#cb82-8" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb82-9"><a href="#cb82-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-10"><a href="#cb82-10" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">buildButton</span>(label) {</span>
<span id="cb82-11"><a href="#cb82-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> button <span class="op">=</span> <span class="bu">document</span><span class="op">.</span><span class="fu">createElement</span>(<span class="st">&quot;button&quot;</span>)<span class="op">;</span></span>
<span id="cb82-12"><a href="#cb82-12" aria-hidden="true" tabindex="-1"></a>  button<span class="op">.</span><span class="at">textContent</span> <span class="op">=</span> label<span class="op">;</span></span>
<span id="cb82-13"><a href="#cb82-13" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> button<span class="op">;</span></span>
<span id="cb82-14"><a href="#cb82-14" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb82-15"><a href="#cb82-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-16"><a href="#cb82-16" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">buildComment</span>(comment) {</span>
<span id="cb82-17"><a href="#cb82-17" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> node <span class="op">=</span> <span class="bu">document</span><span class="op">.</span><span class="fu">createElement</span>(<span class="st">&quot;li&quot;</span>)<span class="op">;</span></span>
<span id="cb82-18"><a href="#cb82-18" aria-hidden="true" tabindex="-1"></a>  node<span class="op">.</span><span class="at">textContent</span> <span class="op">=</span> <span class="vs">`</span><span class="sc">${</span>comment<span class="op">.</span><span class="at">author</span><span class="sc">}</span><span class="vs">: </span><span class="sc">${</span>comment<span class="op">.</span><span class="at">text</span><span class="sc">}</span><span class="vs">`</span><span class="op">;</span></span>
<span id="cb82-19"><a href="#cb82-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-20"><a href="#cb82-20" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (<span class="op">!</span>comment<span class="op">.</span><span class="at">approved</span>) {</span>
<span id="cb82-21"><a href="#cb82-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> approveButton <span class="op">=</span> <span class="fu">buildButton</span>(<span class="st">&quot;Schválit&quot;</span>)<span class="op">;</span></span>
<span id="cb82-22"><a href="#cb82-22" aria-hidden="true" tabindex="-1"></a>    node<span class="op">.</span><span class="fu">append</span>(approveButton)<span class="op">;</span></span>
<span id="cb82-23"><a href="#cb82-23" aria-hidden="true" tabindex="-1"></a>    approveButton<span class="op">.</span><span class="fu">addEventListener</span>(<span class="st">&quot;click&quot;</span><span class="op">,</span> <span class="kw">async</span> e <span class="kw">=&gt;</span> {</span>
<span id="cb82-24"><a href="#cb82-24" aria-hidden="true" tabindex="-1"></a>      <span class="cf">await</span> <span class="fu">approveComment</span>(comment<span class="op">.</span><span class="at">id</span>)<span class="op">;</span></span>
<span id="cb82-25"><a href="#cb82-25" aria-hidden="true" tabindex="-1"></a>      <span class="fu">loadComments</span>()<span class="op">;</span></span>
<span id="cb82-26"><a href="#cb82-26" aria-hidden="true" tabindex="-1"></a>    })<span class="op">;</span></span>
<span id="cb82-27"><a href="#cb82-27" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb82-28"><a href="#cb82-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-29"><a href="#cb82-29" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> deleteButton <span class="op">=</span> <span class="fu">buildButton</span>(<span class="st">&quot;Smazat&quot;</span>)<span class="op">;</span></span>
<span id="cb82-30"><a href="#cb82-30" aria-hidden="true" tabindex="-1"></a>  node<span class="op">.</span><span class="fu">append</span>(deleteButton)<span class="op">;</span></span>
<span id="cb82-31"><a href="#cb82-31" aria-hidden="true" tabindex="-1"></a>  deleteButton<span class="op">.</span><span class="fu">addEventListener</span>(<span class="st">&quot;click&quot;</span><span class="op">,</span> <span class="kw">async</span> e <span class="kw">=&gt;</span> {</span>
<span id="cb82-32"><a href="#cb82-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">await</span> <span class="fu">deleteComment</span>(comment<span class="op">.</span><span class="at">id</span>)<span class="op">;</span></span>
<span id="cb82-33"><a href="#cb82-33" aria-hidden="true" tabindex="-1"></a>    <span class="fu">loadComments</span>()<span class="op">;</span></span>
<span id="cb82-34"><a href="#cb82-34" aria-hidden="true" tabindex="-1"></a>  })<span class="op">;</span></span>
<span id="cb82-35"><a href="#cb82-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-36"><a href="#cb82-36" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> node<span class="op">;</span></span>
<span id="cb82-37"><a href="#cb82-37" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb82-38"><a href="#cb82-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-39"><a href="#cb82-39" aria-hidden="true" tabindex="-1"></a><span class="kw">async</span> <span class="kw">function</span> <span class="fu">loadComments</span>() {</span>
<span id="cb82-40"><a href="#cb82-40" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> response <span class="op">=</span> <span class="cf">await</span> <span class="fu">fetch</span>(<span class="st">&quot;/comments&quot;</span>)<span class="op">;</span></span>
<span id="cb82-41"><a href="#cb82-41" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> comments <span class="op">=</span> <span class="cf">await</span> response<span class="op">.</span><span class="fu">json</span>()<span class="op">;</span></span>
<span id="cb82-42"><a href="#cb82-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-43"><a href="#cb82-43" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> newNodes <span class="op">=</span> comments<span class="op">.</span><span class="fu">filter</span>(c <span class="kw">=&gt;</span> <span class="op">!</span>c<span class="op">.</span><span class="at">approved</span>)<span class="op">.</span><span class="fu">map</span>(buildComment)<span class="op">;</span></span>
<span id="cb82-44"><a href="#cb82-44" aria-hidden="true" tabindex="-1"></a>  <span class="bu">document</span><span class="op">.</span><span class="fu">querySelector</span>(<span class="st">&quot;#new&quot;</span>)<span class="op">.</span><span class="fu">replaceChildren</span>(<span class="op">...</span>newNodes)<span class="op">;</span></span>
<span id="cb82-45"><a href="#cb82-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-46"><a href="#cb82-46" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> approvedNodes <span class="op">=</span> comments<span class="op">.</span><span class="fu">filter</span>(c <span class="kw">=&gt;</span> c<span class="op">.</span><span class="at">approved</span>)</span>
<span id="cb82-47"><a href="#cb82-47" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span><span class="fu">map</span>(buildComment)<span class="op">;</span></span>
<span id="cb82-48"><a href="#cb82-48" aria-hidden="true" tabindex="-1"></a>  <span class="bu">document</span><span class="op">.</span><span class="fu">querySelector</span>(<span class="st">&quot;#approved&quot;</span>)</span>
<span id="cb82-49"><a href="#cb82-49" aria-hidden="true" tabindex="-1"></a>    <span class="op">.</span><span class="fu">replaceChildren</span>(<span class="op">...</span>approvedNodes)<span class="op">;</span></span>
<span id="cb82-50"><a href="#cb82-50" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb82-51"><a href="#cb82-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-52"><a href="#cb82-52" aria-hidden="true" tabindex="-1"></a><span class="fu">loadComments</span>()<span class="op">;</span></span></code></pre></div>
<p>Vzorové řešení vzniklo kombinací technik z minulých kapitol. Se
serverem komunikujeme pomocí funkce <code>fetch</code> a používáme
úsporný zápis <em>async/await</em> (minulá podkapitola pro profíky).
Jednotlivé komentáře do stránky vypisujeme pomocí funkcionální iterace
(minulá podkapitola pro koumáky), kdy metodou <code>filter</code>
získáme správné komentáře, metodou <code>map</code> z nich vytvoříme
HTML prvky a nakonec je vložíme do stránky hromadně díky DOM-metodě
<code>replaceChildren</code>.</p>
<p>Poznamenejme, že funkce <code>fetch</code> dovoluje vytvářet
libovolné druhy HTTP požadavků. Pokud se jedná o metodu odlišnou od
výchozí <code>GET</code>, uvedeme ji v druhém parametru
<code>fetch</code>, který slouží jako konfigurační objekt.</p>
<p>Nejsložitější je funkce <code>buildComment</code>, která je
zodpovědná jak za výpis jednoho komentáře, tak za definici administrační
funkcionality. Vytváří jedno až dvě tlačítka a přidává jim požadovanou
funkcionalitu. Používá k tomu malé anonymní asynchronní arrow funkce –
běžný jev v moderním JavaScriptu.</p>
<p>Řešení je sice krátké, ale není příliš propracované. Namísto
tradičního souhrnu <em>co jsme se naučili</em> může zvídavý čtenář
promyslet tři místa, ve kterých by se dalo vylepšit:</p>
<ol type="1">
<li><p>Po provedení nějaké operace s komentářem voláme funkci
<code>loadComments</code>, abychom načetli a zobrazili nový stav. To je
bezpečný přístup (zobrazujeme vždy data v tom stavu, v jakém jsou na
serveru), ale představuje úplně zbytečný přenos většiny dat ze serveru
na klienta. Operace s jedním komentářem nemá na ty ostatní vliv,
a přesto je pokaždé načítáme a vyrábíme znova. Lepší by bylo, kdyby
smazání komentáře jen odstranilo jeho HTML reprezentaci; schválení by
jej pak mohlo přesunout z jednoho výčtu do toho druhého. Těch ostatních
se aktivita vůbec nemusí dotýkat.</p></li>
<li><p>Mazání je nevratná operace. Po kliku na tlačítko by bylo dobré
nechat správce potvrdit, že si smazání opravdu přeje. Toho můžeme
docílit snadno např. vestavěnou funkcí <code>confirm</code>, která
zobrazí potvrzovací dialog.</p></li>
<li><p>Kód neuvažuje speciální případy, které by bylo záhodno
ošetřit:</p>
<ul>
<li><p>když selže volání serveru (všechny tři metody)</p></li>
<li><p>když v rámci <code>loadComments</code> nedostaneme žádné
neschválené komentáře</p></li>
<li><p>když v rámci <code>loadComments</code> nedostaneme žádné
schválené komentáře</p></li>
</ul></li>
</ol>
<p>Implementace výše uvedených návrhů nevyžaduje žádné nové znalosti,
takže si je čtenář může zkusit za domácí úkol. My se zatím půjdeme
podívat na něco nového.</p>
<h2 id="zelenáči-event-delegation">Zelenáči: event delegation</h2>
<p>Při procházení vzorového řešení nás může napadnout, že při větším
počtu diskuzních příspěvků vytváříme značné množství JavaScriptových
funkcí. Jsou to právě ty zmiňované malé arrow funkce, které fungují jako
posluchače událostí na administračních tlačítkách. Jejich jediný účel je
držet v uzávěře ID komentáře, se kterým se má po kliknutí pracovat.
Pojďme se podívat na oblíbenou techniku, která nám dovoluje použít jen
jeden posluchač (nezávisle na počtu komentářů či tlačítek).</p>
<p>Klíčové je v tuto chvíli pozorování, že HTML prvky vytváří stromovou
strukturu a že uživatelova interakce (tj. zdroj vzniku události) se
proto může týkat více uzlů naráz. Konkrétněji, když máme například
odstavec a v něm odkaz, na který klikneme, <em>kliknuli jsme na
odstavec?</em></p>
<div class="sourceCode" id="cb83"><pre
class="sourceCode html"><code class="sourceCode html"><span id="cb83-1"><a href="#cb83-1" aria-hidden="true" tabindex="-1"></a><span class="dt">&lt;</span><span class="kw">p</span><span class="dt">&gt;</span></span>
<span id="cb83-2"><a href="#cb83-2" aria-hidden="true" tabindex="-1"></a>  Toto je odstavec. V něm je</span>
<span id="cb83-3"><a href="#cb83-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&lt;</span><span class="kw">a</span><span class="dt">&gt;</span> odkaz, <span class="dt">&lt;/</span><span class="kw">a</span><span class="dt">&gt;</span></span>
<span id="cb83-4"><a href="#cb83-4" aria-hidden="true" tabindex="-1"></a>  na který klikneme. Bylo kliknuto (také) na odstavec?</span>
<span id="cb83-5"><a href="#cb83-5" aria-hidden="true" tabindex="-1"></a><span class="dt">&lt;/</span><span class="kw">p</span><span class="dt">&gt;</span></span></code></pre></div>
<p>Na tuto otázku je odpověď jednoznačná: <strong>ano</strong>, kliknutí
na libovolný HTML prvek ve stránce zároveň znamená, že bylo kliknuto
i na jeho rodiče (a všechny jeho předky). Pokud bychom tedy v našem
administračním systému přidali posluchač události <code>click</code>
kupříkladu na prvek <code>document.body</code> (odpovídá HTML značce
<code>&lt;body&gt;</code>), bude vykonán při kliknutí na kteroukoliv
část dokumentu, tedy i tlačítka.</p>
<p>Této technice se říká <strong>event delegation</strong> (český
překlad <em>delegování událostí</em> se příliš neujal). Použijeme při ní
jediný posluchač na společném rodiči všech prvků, které nás zajímají.
Když pak nastane událost, musíme rozpoznat, co to pro nás znamená.
Zpravidla prozkoumáme objekt události (parametr posluchače), z něj
zjistíme, kde ve stránce událost nastala, a podle toho se zařídíme. Je
to ideální místo pro použití vlastnosti <code>target</code>, o které
jsme se dozvěděli ve čtvrté kapitole. Začněme tedy s úpravou vzorového
řešení:</p>
<div class="sourceCode" id="cb84"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb84-1"><a href="#cb84-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">onClick</span>(e) {</span>
<span id="cb84-2"><a href="#cb84-2" aria-hidden="true" tabindex="-1"></a>  <span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(<span class="st">&quot;Kliknuto na&quot;</span><span class="op">,</span> e<span class="op">.</span><span class="at">target</span>)<span class="op">;</span></span>
<span id="cb84-3"><a href="#cb84-3" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb84-4"><a href="#cb84-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-5"><a href="#cb84-5" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">buildComment</span>(comment) {</span>
<span id="cb84-6"><a href="#cb84-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> node <span class="op">=</span> <span class="bu">document</span><span class="op">.</span><span class="fu">createElement</span>(<span class="st">&quot;li&quot;</span>)<span class="op">;</span></span>
<span id="cb84-7"><a href="#cb84-7" aria-hidden="true" tabindex="-1"></a>  node<span class="op">.</span><span class="at">textContent</span> <span class="op">=</span> <span class="vs">`</span><span class="sc">${</span>comment<span class="op">.</span><span class="at">author</span><span class="sc">}</span><span class="vs">: </span><span class="sc">${</span>comment<span class="op">.</span><span class="at">text</span><span class="sc">}</span><span class="vs">`</span><span class="op">;</span></span>
<span id="cb84-8"><a href="#cb84-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-9"><a href="#cb84-9" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (<span class="op">!</span>comment<span class="op">.</span><span class="at">approved</span>) {</span>
<span id="cb84-10"><a href="#cb84-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> approveButton <span class="op">=</span> <span class="fu">buildButton</span>(<span class="st">&quot;Schválit&quot;</span>)<span class="op">;</span></span>
<span id="cb84-11"><a href="#cb84-11" aria-hidden="true" tabindex="-1"></a>    node<span class="op">.</span><span class="fu">append</span>(approveButton)<span class="op">;</span></span>
<span id="cb84-12"><a href="#cb84-12" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb84-13"><a href="#cb84-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-14"><a href="#cb84-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> deleteButton <span class="op">=</span> <span class="fu">buildButton</span>(<span class="st">&quot;Smazat&quot;</span>)<span class="op">;</span></span>
<span id="cb84-15"><a href="#cb84-15" aria-hidden="true" tabindex="-1"></a>  node<span class="op">.</span><span class="fu">append</span>(deleteButton)<span class="op">;</span></span>
<span id="cb84-16"><a href="#cb84-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-17"><a href="#cb84-17" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> node<span class="op">;</span></span>
<span id="cb84-18"><a href="#cb84-18" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb84-19"><a href="#cb84-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-20"><a href="#cb84-20" aria-hidden="true" tabindex="-1"></a><span class="bu">document</span><span class="op">.</span><span class="at">body</span><span class="op">.</span><span class="fu">addEventListener</span>(<span class="st">&quot;click&quot;</span><span class="op">,</span> onClick)<span class="op">;</span></span></code></pre></div>
<p>Funkce <code>buildComment</code> se příjemně zjednodušila, protože už
neobsahuje práci s událostmi. Tu bychom rádi provedli uvnitř
<code>onClick</code>, ale zatím nevíme jak. Sice poznáme, na které
tlačítko bylo kliknuto, ale:</p>
<ul>
<li><p>nevíme, o který komentář jde;</p></li>
<li><p>nevíme, jestli bylo kliknuto na schválení nebo na
smazání.</p></li>
</ul>
<p>K dispozici ovšem máme HTML prvek, na kterém událost nastala.
Kdybychom mu potřebné informace předali jako vlastnosti či atributy,
mohli bychom je z něj získat v posluchači <code>onClick</code>. Při
návrhu takového řešení budeme následovat dvě doporučení:</p>
<ol type="1">
<li><p>Přidávání nových vlastností HTML prvkům není dobrý nápad, protože
se vystavujeme riziku, že námi zvolený název bude kolidovat s nějakou
existující vlastností (co hůře: taková zatím nemusí existovat, ale časem
vznikne, a tím se náš kód zničeho nic rozbije!). Místo toho budeme
využívat atribut <code>data-*</code>, který je určený právě pro
uživatelská data. Pracovat s ním můžeme pohodlně pomocí DOM vlastnosti
<code>dataset</code>. Například JavaScriptový přístup k vlastnosti
<code>document.body.dataset.a</code> odpovídá čtení či zápisu
uživatelského HTML atributu
<code>&lt;body data-a="..."&gt;</code>.</p></li>
<li><p>Víme, že pro provedení aktivity po kliknutí musíme získat dva
údaje: ID komentáře a druh akce. Mohli bychom si oba dva uložit ke
každému tlačítku, ale tím bude ID komentáře u tlačítek uloženo
nadbytečně. S ohledem na stromovou strukturu lze ID komentáře nastavit
například jejich společnému rodiči, tedy značce
<code>&lt;li&gt;</code>.</p></li>
</ol>
<p>Funkce <code>buildButton</code> a <code>buildComment</code> proto
upravíme takto:</p>
<div class="sourceCode" id="cb85"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb85-1"><a href="#cb85-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">buildButton</span>(label<span class="op">,</span> action) {</span>
<span id="cb85-2"><a href="#cb85-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> button <span class="op">=</span> <span class="bu">document</span><span class="op">.</span><span class="fu">createElement</span>(<span class="st">&quot;button&quot;</span>)<span class="op">;</span></span>
<span id="cb85-3"><a href="#cb85-3" aria-hidden="true" tabindex="-1"></a>  button<span class="op">.</span><span class="at">textContent</span> <span class="op">=</span> label<span class="op">;</span></span>
<span id="cb85-4"><a href="#cb85-4" aria-hidden="true" tabindex="-1"></a>  button<span class="op">.</span><span class="at">dataset</span><span class="op">.</span><span class="at">action</span> <span class="op">=</span> action<span class="op">;</span></span>
<span id="cb85-5"><a href="#cb85-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> button<span class="op">;</span></span>
<span id="cb85-6"><a href="#cb85-6" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb85-7"><a href="#cb85-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb85-8"><a href="#cb85-8" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">buildComment</span>(comment) {</span>
<span id="cb85-9"><a href="#cb85-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> node <span class="op">=</span> <span class="bu">document</span><span class="op">.</span><span class="fu">createElement</span>(<span class="st">&quot;li&quot;</span>)<span class="op">;</span></span>
<span id="cb85-10"><a href="#cb85-10" aria-hidden="true" tabindex="-1"></a>  node<span class="op">.</span><span class="at">dataset</span><span class="op">.</span><span class="at">id</span> <span class="op">=</span> comment<span class="op">.</span><span class="at">id</span><span class="op">;</span></span>
<span id="cb85-11"><a href="#cb85-11" aria-hidden="true" tabindex="-1"></a>  node<span class="op">.</span><span class="at">textContent</span> <span class="op">=</span> <span class="vs">`</span><span class="sc">${</span>comment<span class="op">.</span><span class="at">author</span><span class="sc">}</span><span class="vs">: </span><span class="sc">${</span>comment<span class="op">.</span><span class="at">text</span><span class="sc">}</span><span class="vs">`</span><span class="op">;</span></span>
<span id="cb85-12"><a href="#cb85-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb85-13"><a href="#cb85-13" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (<span class="op">!</span>comment<span class="op">.</span><span class="at">approved</span>) {</span>
<span id="cb85-14"><a href="#cb85-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> approveButton <span class="op">=</span> <span class="fu">buildButton</span>(<span class="st">&quot;Schválit&quot;</span><span class="op">,</span> <span class="st">&quot;approve&quot;</span>)<span class="op">;</span></span>
<span id="cb85-15"><a href="#cb85-15" aria-hidden="true" tabindex="-1"></a>    node<span class="op">.</span><span class="fu">append</span>(approveButton)<span class="op">;</span></span>
<span id="cb85-16"><a href="#cb85-16" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb85-17"><a href="#cb85-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb85-18"><a href="#cb85-18" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> deleteButton <span class="op">=</span> <span class="fu">buildButton</span>(<span class="st">&quot;Smazat&quot;</span><span class="op">,</span> <span class="st">&quot;delete&quot;</span>)<span class="op">;</span></span>
<span id="cb85-19"><a href="#cb85-19" aria-hidden="true" tabindex="-1"></a>  node<span class="op">.</span><span class="fu">append</span>(deleteButton)<span class="op">;</span></span>
<span id="cb85-20"><a href="#cb85-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb85-21"><a href="#cb85-21" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> node<span class="op">;</span></span>
<span id="cb85-22"><a href="#cb85-22" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Vzniklé HTML je dostatečně <em>označené</em>, abychom s ním mohli
dokončit delegování událostí. Ve funkci <code>onClick</code> zjistíme,
zdali došlo ke kliknutí v prvku s atributem <code>data-action</code>
a zároveň v prvku s atributem <code>data-id</code>:</p>
<div class="sourceCode" id="cb86"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb86-1"><a href="#cb86-1" aria-hidden="true" tabindex="-1"></a><span class="kw">async</span> <span class="kw">function</span> <span class="fu">onClick</span>(e) {</span>
<span id="cb86-2"><a href="#cb86-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> idNode <span class="op">=</span> e<span class="op">.</span><span class="at">target</span><span class="op">.</span><span class="fu">closest</span>(<span class="st">&quot;[data-id]&quot;</span>)<span class="op">;</span></span>
<span id="cb86-3"><a href="#cb86-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> actionNode <span class="op">=</span> e<span class="op">.</span><span class="at">target</span><span class="op">.</span><span class="fu">closest</span>(<span class="st">&quot;[data-action]&quot;</span>)<span class="op">;</span></span>
<span id="cb86-4"><a href="#cb86-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (<span class="op">!</span>idNode <span class="op">||</span> <span class="op">!</span>actionNode) { <span class="cf">return</span><span class="op">;</span> }</span>
<span id="cb86-5"><a href="#cb86-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-6"><a href="#cb86-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> id <span class="op">=</span> idNode<span class="op">.</span><span class="at">dataset</span><span class="op">.</span><span class="at">id</span><span class="op">;</span></span>
<span id="cb86-7"><a href="#cb86-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">switch</span> (actionNode<span class="op">.</span><span class="at">dataset</span><span class="op">.</span><span class="at">action</span>) {</span>
<span id="cb86-8"><a href="#cb86-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> <span class="st">&quot;approve&quot;</span><span class="op">:</span></span>
<span id="cb86-9"><a href="#cb86-9" aria-hidden="true" tabindex="-1"></a>      <span class="cf">await</span> <span class="fu">approveComment</span>(id)<span class="op">;</span></span>
<span id="cb86-10"><a href="#cb86-10" aria-hidden="true" tabindex="-1"></a>      <span class="fu">loadComments</span>()<span class="op">;</span></span>
<span id="cb86-11"><a href="#cb86-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">break</span><span class="op">;</span></span>
<span id="cb86-12"><a href="#cb86-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">case</span> <span class="st">&quot;delete&quot;</span><span class="op">:</span></span>
<span id="cb86-13"><a href="#cb86-13" aria-hidden="true" tabindex="-1"></a>      <span class="cf">await</span> <span class="fu">deleteComment</span>(id)<span class="op">;</span></span>
<span id="cb86-14"><a href="#cb86-14" aria-hidden="true" tabindex="-1"></a>      <span class="fu">loadComments</span>()<span class="op">;</span></span>
<span id="cb86-15"><a href="#cb86-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">break</span><span class="op">;</span></span>
<span id="cb86-16"><a href="#cb86-16" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb86-17"><a href="#cb86-17" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>V takto upravené funkci je několik novinek. První je použití nové DOM
metody <code>closest</code>, která vrací prvního předka daného prvku
vyhovujícího zadanému selektoru. Příjemnou vlastností této metody je
skutečnost, že hledání začíná na prvku samém (tj. na
<code>e.target</code>), což pokryje případy kliknutí na tlačítko.
V tomto smyslu bychom mohli rovnou psát
<code>e.target.dataset.action</code>, ale tím by náš kód přestal
fungovat, jakmile bychom do tlačítka vložili další HTML obsah –
například obrázek. Pak by při kliknutí na obrázek <code>e.target</code>
odpovídal HTML značce <code>&lt;img&gt;</code> a na ní bychom atribut
<code>action</code> hledali marně.</p>
<p>Pokud nenalezneme <code>idNode</code> nebo <code>actionNode</code>,
funkci rovnou opustíme. Je to opět příkladem přístupu <em>return
early</em> a pokrýváme tak scénáře klikání kamkoliv mimo akční tlačítka.
Nově se dále setkáváme s konstrukcí <code>switch</code>, která kód větví
do několika bloků podle hodnoty testovaného výrazu.</p>
<p>Na závěr podkapitoly ještě zmiňme, že hodnoty užívané v rozhraní
<code>dataset</code> jsou vždy automaticky převáděny na řetězce. V právě
řešené úloze to nevadí (hodnoty ID na server posíláme jako součásti URL,
tj. taktéž jako řetězce), ale pokud bychom serveru posílali data
v nějakém typovaném formátu, možná by bylo nutné přetypování. Otázce
převodu řetězce na číslo se proto věnuje nadcházející podkapitola pro
profíky.</p>
<h2 id="koumáci-bublání-a-zachytávání">Koumáci: bublání
a zachytávání</h2>
<p>V minulé podkapitole jsme se přesvědčili o tom, že událost
<em>click</em> je možné zachytit i na libovolném rodiči toho HTML prvku,
na kterém bylo kliknuto. U jiných druhů událostí bohužel situace takto
snadná být nemusí. V minulosti jsme se například věnovali události
<code>submit</code>, kterou uživatel vyvolal interakcí s tlačítkem.
A taková událost nastává na HTML prvku <code>&lt;form&gt;</code> –
nikoliv na tlačítku a nikoliv na rodičích formuláře. Znamená to, že
události dělíme do dvou hlavních kategorií: ty, které krom původního
prvku nastávají i na všech rodičích (říkáme o nich, že
<em>bublají</em>), a ty odehrávající se jen na jednom HTML prvku
(říkáme, že <em>nebublají</em>). Toto pozoruhodné názvosloví snad
vyjasníme za malou chvíli, ale nejprve se podívejme na jeden další
scénář, kdy se nám bublající událost může hodit.</p>
<p>Představme si, že do stránky umístíme kontaktní formulář, který je
ovšem na začátku skrytý a uživatel jej může zobrazit kliknutím na
tlačítko. Zatím je to hračka:</p>
<div class="sourceCode" id="cb87"><pre
class="sourceCode html"><code class="sourceCode html"><span id="cb87-1"><a href="#cb87-1" aria-hidden="true" tabindex="-1"></a><span class="dt">&lt;</span><span class="kw">form</span> <span class="er">hidden</span><span class="dt">&gt;</span> ... <span class="dt">&lt;/</span><span class="kw">form</span><span class="dt">&gt;</span></span>
<span id="cb87-2"><a href="#cb87-2" aria-hidden="true" tabindex="-1"></a><span class="dt">&lt;</span><span class="kw">button</span><span class="dt">&gt;</span> Kontaktovat <span class="dt">&lt;/</span><span class="kw">button</span><span class="dt">&gt;</span></span></code></pre></div>
<div class="sourceCode" id="cb88"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb88-1"><a href="#cb88-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> form <span class="op">=</span> <span class="bu">document</span><span class="op">.</span><span class="fu">querySelector</span>(<span class="st">&quot;form&quot;</span>)<span class="op">;</span></span>
<span id="cb88-2"><a href="#cb88-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> button <span class="op">=</span> <span class="bu">document</span><span class="op">.</span><span class="fu">querySelector</span>(<span class="st">&quot;button&quot;</span>)<span class="op">;</span></span>
<span id="cb88-3"><a href="#cb88-3" aria-hidden="true" tabindex="-1"></a>button<span class="op">.</span><span class="fu">addEventListener</span>(<span class="st">&quot;click&quot;</span><span class="op">,</span> e <span class="kw">=&gt;</span> form<span class="op">.</span><span class="at">hidden</span> <span class="op">=</span> <span class="kw">false</span>)<span class="op">;</span></span></code></pre></div>
<p>Situace se může zkomplikovat, když pak dostaneme za úkol <em>skrýt
formulář, jakmile uživatel klikne mimo něj</em>. Protože událost
<code>click</code> patří mezi bublající, můžeme přidat posluchač třeba
na celý dokument. Tím se dozvíme o kliknutí <em>kdekoliv ve stránce</em>
a formulář skryjeme.</p>
<div class="sourceCode" id="cb89"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb89-1"><a href="#cb89-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">hideForm</span>(e) {</span>
<span id="cb89-2"><a href="#cb89-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">// opravdu vždy?</span></span>
<span id="cb89-3"><a href="#cb89-3" aria-hidden="true" tabindex="-1"></a>  form<span class="op">.</span><span class="at">hidden</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb89-4"><a href="#cb89-4" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb89-5"><a href="#cb89-5" aria-hidden="true" tabindex="-1"></a><span class="bu">document</span><span class="op">.</span><span class="fu">addEventListener</span>(<span class="st">&quot;click&quot;</span><span class="op">,</span> hideForm)<span class="op">;</span></span></code></pre></div>
<p>Toto řešení ovšem není funkční, neboť skrývá formulář při kliku
kamkoliv, tedy i do formuláře. Naštěstí máme dva dobré způsoby, jak tomu
zabránit:</p>
<ol type="1">
<li><p>Víme, že vlastnost <code>e.target</code> odpovídá tomu HTML
prvku, na kterém událost nastala. Pokud dokážeme ověřit, že se tento
nachází někde uvnitř formuláře (nebo je to přímo formulář), můžeme za
takové situace kliknutí ignorovat. Takový test (patrně pomocí metody
<code>closest</code>) by odpovídal příkladu z předchozí podkapitoly pro
zelenáče.</p></li>
<li><p>Prohlížeč vykonává posluchače bublajících událostí v pevně
definovaném pořadí <em>odspoda nahoru</em>, tedy od cílového prvku
směrem ke kořeni stromu dokumentu. Když klikneme na HTML prvek, nejprve
se vykoná posluchač přidaný přímo na něj (pokud nějaký je), pak na jeho
rodiči, pak na rodiči jeho rodiče… až k poslednímu místu, tj. k celé
proměnné <code>document</code>. Tento proces můžeme zastavit v rámci
posluchače, který přidáme na formulář.</p></li>
</ol>
<p>Pojďme si vyzkoušet druhé řešení. Stačí nám k němu znát novou metodu
<code>stopPropagation</code>, která je součástí objektu události. Jejím
účelem je zastavit proces bublání:</p>
<div class="sourceCode" id="cb90"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb90-1"><a href="#cb90-1" aria-hidden="true" tabindex="-1"></a><span class="bu">document</span><span class="op">.</span><span class="fu">addEventListener</span>(<span class="st">&quot;click&quot;</span><span class="op">,</span> e <span class="kw">=&gt;</span> form<span class="op">.</span><span class="at">hidden</span> <span class="op">=</span> <span class="kw">false</span>)<span class="op">;</span></span>
<span id="cb90-2"><a href="#cb90-2" aria-hidden="true" tabindex="-1"></a>form<span class="op">.</span><span class="fu">addEventListener</span>(<span class="st">&quot;click&quot;</span><span class="op">,</span> e <span class="kw">=&gt;</span> e<span class="op">.</span><span class="fu">stopPropagation</span>())<span class="op">;</span></span></code></pre></div>
<p>Takový přístup můžeme popsat slovy <em>dokument se nedozví o tom, že
bylo kliknuto na formulář</em>. Při kliku kamkoliv (do formuláře i mimo
něj) se vykoná jen jeden ze dvou výše uvedených posluchačů.</p>
<p>Na úloze se skrýváním formuláře je vidět, že <em>bublání</em> je
silná technika. Bohužel si ale vzpomínáme, že některé události
nebublají. Nemusíme se však obávat, protože zpracování posluchačů pomocí
bublání je ve skutečnosti jen polovina toho, jak prohlížeč na událost
reaguje. Před vykonáváním našich posluchačů totiž ještě nastane okamžik,
kterému se říká <em>zachytávání</em> (anglicky <em>capture</em>). Během
něj prohlížeč projde stromem dokumentu <em>shora dolů</em> od kořene až
k cílovému prvku (tedy v obráceném pořadí, než u bublání) a cestou
vykoná ty posluchače právě zpracovávané události, u kterých jsme
explicitně požádali o spuštění ve fázi zachytávání. K tomu slouží třetí,
nepovinný parametr metody <code>addEventListener</code>. Pokud máme
o zachytávání zájem, musíme jej nastavit buď na <code>true</code>, nebo
na objekt obsahující <code>capture:true</code>:</p>
<div class="sourceCode" id="cb91"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb91-1"><a href="#cb91-1" aria-hidden="true" tabindex="-1"></a><span class="co">// dvě shodné varianty</span></span>
<span id="cb91-2"><a href="#cb91-2" aria-hidden="true" tabindex="-1"></a><span class="bu">document</span><span class="op">.</span><span class="fu">addEventListener</span>(<span class="st">&quot;focus&quot;</span><span class="op">,</span> <span class="bu">console</span><span class="op">.</span><span class="fu">log</span><span class="op">,</span> <span class="kw">true</span>)<span class="op">;</span></span>
<span id="cb91-3"><a href="#cb91-3" aria-hidden="true" tabindex="-1"></a><span class="bu">document</span><span class="op">.</span><span class="fu">addEventListener</span>(<span class="st">&quot;focus&quot;</span><span class="op">,</span> <span class="bu">console</span><span class="op">.</span><span class="fu">log</span><span class="op">,</span> {<span class="dt">capture</span><span class="op">:</span><span class="kw">true</span>})<span class="op">;</span></span></code></pre></div>
<p>Celý proces zpracování události si můžeme snadněji představit pomocí
obrázku:</p>
<figure>
<img src="../img/events.svg" alt="Životní cyklus události" />
<figcaption aria-hidden="true">Životní cyklus události</figcaption>
</figure>
<p>Pojďme si shrnout důležité kroky v životě zpracovávané události.</p>
<ul>
<li><p>Jakmile nastane DOM událost, prohlížeč vytvoří objekt události
a začne vykonávat posluchače. Nejprve ve fázi zachytávání, pak ve fázi
bublání.</p></li>
<li><p>Posluchače ve fázi zachytávání musí být explicitně označeny
a jsou vykonávány v pořadí <strong>shora dolů</strong>.</p></li>
<li><p>Posluchače ve fázi bublání jsou vykonávány v pořadí
<strong>odspoda nahoru</strong>. Pokud událost nebublá, vykoná se jen
posluchač na cílovém HTML prvku a žádný další.</p></li>
<li><p>Procesy zachytávání i následného bublání lze v kterémkoliv
posluchači zastavit voláním <code>stopPropagation()</code>.</p></li>
</ul>
<p>U většiny JavaScriptových úloh si vystačíme s bubláním. Zachytávání
se nám může hodit jen ve dvou situacích:</p>
<ol type="1">
<li><p>Když potřebujeme prohodit pořadí dvou posluchačů stejné události
na různých HTML prvcích.</p></li>
<li><p>Když se potřebujeme na rodičovském prvku dozvědět o nebublající
události jeho potomka.</p></li>
</ol>
<h2 id="profíci-o-řetězcích-a-číslech">Profíci: o řetězcích
a číslech</h2>
<p>Řetězce i čísla patří mezi základní datové typy, se kterými
v JavaScriptu pracujeme. V páté kapitole jsme se ujistili v tom, že
nejlepší je, když s nimi pracujeme odděleně: řetězce porovnáváme
s řetězci a čísla s čísly. Čas od času se ale dostaneme do situace, kdy
jednu konkrétní hodnotu potřebujeme reprezentovat jednou jako číslo
a podruhé jako řetězec. Může to být příklad rozhraní
<code>dataset</code> z podkapitoly pro zelenáče, ale třeba i nastavování
hodnot HTML prvku <code>&lt;input&gt;</code> pomocí vlastnosti
<code>value</code>. V těchto situacích dochází k implicitnímu
(automatickému) převodu hodnoty na řetězec.</p>
<p>Takový proces nevyžaduje detailnějšího prozkoumávání, protože
zpravidla funguje tak, jak očekáváme. Pokud bychom potřebovali číslo na
řetězec převádět ručně, máme k tomu několik nástrojů:</p>
<ul>
<li><p>univerzální funkci <code>String</code>, která převede libovolný
datový typ na řetězec;</p></li>
<li><p>metodu <code>toString</code>, kterou mají mimo jiné všechna čísla
a u které můžeme parametrem specifikovat, jakou číselnou soustavu použít
(při neuvedení se použije desítková);</p></li>
<li><p>specializované metody <code>toFixed</code>
a <code>toPrecision</code>, které dovolují různé formy zápisu
desetinných čísel.</p></li>
</ul>
<p>Opačný převod z řetězce na číslo je trochu složitější. Souvisí to
mimo jiné s tím, že ne všechny řetězce <em>lze</em> na číslo převést,
neboť mohou obsahovat znaky, které se v reprezentaci čísel nepoužívají.
K tomuto účelu existují tři globální funkce: <code>Number</code>,
<code>parseInt</code> a <code>parseFloat</code>. Podíváme se na jejich
vlastnosti a rozdíly.</p>
<p>Především nás zajímá situace, kdy převod není možné provést, neboť
řetězec obsahuje neplatný znak. Tehdy bude výsledkem převodu (u všech
tří funkcí) speciální hodnota <code>NaN</code> (z anglického <em>not
a number</em>). Pokud nemáme jistotu, že řetězec obsahuje platné číslo,
měli bychom výsledek převodu zkontrolovat:</p>
<div class="sourceCode" id="cb92"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb92-1"><a href="#cb92-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> id <span class="op">=</span> <span class="bu">Number</span>(input<span class="op">.</span><span class="at">value</span>)<span class="op">;</span></span>
<span id="cb92-2"><a href="#cb92-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb92-3"><a href="#cb92-3" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (<span class="bu">Number</span><span class="op">.</span><span class="fu">isNaN</span>(id)) {</span>
<span id="cb92-4"><a href="#cb92-4" aria-hidden="true" tabindex="-1"></a>  <span class="bu">console</span><span class="op">.</span><span class="fu">error</span>(<span class="st">&quot;Hodnota není číslo&quot;</span>)<span class="op">;</span></span>
<span id="cb92-5"><a href="#cb92-5" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Specializovaná testovací funkce <code>isNaN</code> je zde nutná,
neboť prosté porovnání s <code>NaN</code> by selhalo. Je to způsobeno
tím, že exotická hodnota <code>NaN</code> se z definice ničemu nerovná,
ani sama sobě. V ukázce jsme použili převodní funkci
<code>Number</code>, která je ve většině případů správnou volbou. Jejím
charakteristickým rysem je, že pokud narazí na neplatný znak, okamžitě
vrátí <code>NaN</code>, i kdyby mu předcházely platné číslice.</p>
<p>Nikoliv tak zbývající dvě funkce, <code>parseInt</code>
a <code>parseFloat</code>. Ty prochází řetězec od začátku, znak po
znaku, a pokud narazí na neplatný znak, pokusí se vytvořit číslo z toho,
co doposud zpracovaly. Jejich názvy dávají tušit, že návratovou hodnotou
je celé, respektive desetinné číslo. To je trochu zavádějící, neboť
v JavaScriptu je jen jeden číselný datový typ (formálně se nazývá
<em>IEEE 754 double-precision floating-point format</em>). Pokud tedy
v řetězci zapíšeme celé číslo, výsledky se budou rovnat. Rozdíl nastane
až v okamžiku, kdy řetězec obsahuje desetinnou tečku. Funkce
<code>parseInt</code> se na ní zastaví a vrátí to celé číslo, které do
té doby zpracovala. Jinými slovy, ořízne z desetinného čísla jeho
desetinnou část. Nejlépe si hlavní rysy těchto konverzních funkcí
ukážeme na příkladech:</p>
<div class="sourceCode" id="cb93"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb93-1"><a href="#cb93-1" aria-hidden="true" tabindex="-1"></a><span class="bu">Number</span>(<span class="st">&quot;42&quot;</span>)<span class="op">;</span>                         <span class="co">// 42</span></span>
<span id="cb93-2"><a href="#cb93-2" aria-hidden="true" tabindex="-1"></a><span class="bu">Number</span>(<span class="st">&quot;42b&quot;</span>)<span class="op">;</span>                        <span class="co">// NaN</span></span>
<span id="cb93-3"><a href="#cb93-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb93-4"><a href="#cb93-4" aria-hidden="true" tabindex="-1"></a><span class="pp">parseInt</span>(<span class="st">&quot;42b&quot;</span>)<span class="op">;</span>                      <span class="co">// 42</span></span>
<span id="cb93-5"><a href="#cb93-5" aria-hidden="true" tabindex="-1"></a><span class="pp">parseInt</span>(<span class="st">&quot;b42&quot;</span>)<span class="op">;</span>                      <span class="co">// NaN</span></span>
<span id="cb93-6"><a href="#cb93-6" aria-hidden="true" tabindex="-1"></a><span class="pp">parseInt</span>(<span class="st">&quot;42&quot;</span>) <span class="op">===</span> <span class="pp">parseFloat</span>(<span class="st">&quot;42&quot;</span>)<span class="op">;</span>  <span class="co">// true</span></span>
<span id="cb93-7"><a href="#cb93-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb93-8"><a href="#cb93-8" aria-hidden="true" tabindex="-1"></a><span class="pp">parseInt</span>(<span class="st">&quot;42.9&quot;</span>)<span class="op">;</span>                     <span class="co">// 42</span></span>
<span id="cb93-9"><a href="#cb93-9" aria-hidden="true" tabindex="-1"></a><span class="pp">parseFloat</span>(<span class="st">&quot;42.9&quot;</span>)<span class="op">;</span>                   <span class="co">// 42.9</span></span></code></pre></div>
<p>Pro většinu úloh si vystačíme s funkcí <code>Number</code>. Ve
speciálních případech se ještě může hodit druhý parametr funkce
<code>parseInt</code>, kterým říkáme, v jaké číselné soustavě je
převáděný řetězec zapsán. Můžeme tak získat hodnoty zapsané například
v šestnáctkové, nebo až šestatřicítkové soustavě:</p>
<div class="sourceCode" id="cb94"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb94-1"><a href="#cb94-1" aria-hidden="true" tabindex="-1"></a><span class="pp">parseInt</span>(<span class="st">&quot;CAFE&quot;</span><span class="op">,</span> <span class="dv">16</span>)<span class="op">;</span>  <span class="co">// 51966</span></span>
<span id="cb94-2"><a href="#cb94-2" aria-hidden="true" tabindex="-1"></a><span class="pp">parseInt</span>(<span class="st">&quot;AHOJ&quot;</span><span class="op">,</span> <span class="dv">36</span>)<span class="op">;</span>  <span class="co">// 489475</span></span></code></pre></div>
<p>Tato kvalita funkce <code>parseInt</code> je ovšem zároveň i jejím
prokletím, na které může neopatrný programátor doplatit například ve
funkcionální iteraci. Představme si, že máme pole celých čísel zapsaných
jako řetězce a chceme je převést na čísla. V tomto pomyslném poměřování
máme dva závodníky. Dovedete odhadnout, jak výsledek dopadne?</p>
<div class="sourceCode" id="cb95"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb95-1"><a href="#cb95-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> numbers <span class="op">=</span> [<span class="st">&quot;10&quot;</span><span class="op">,</span> <span class="st">&quot;10&quot;</span><span class="op">,</span> <span class="st">&quot;10&quot;</span>]<span class="op">;</span></span>
<span id="cb95-2"><a href="#cb95-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb95-3"><a href="#cb95-3" aria-hidden="true" tabindex="-1"></a>numbers<span class="op">.</span><span class="fu">map</span>(<span class="bu">Number</span>)<span class="op">;</span></span>
<span id="cb95-4"><a href="#cb95-4" aria-hidden="true" tabindex="-1"></a>numbers<span class="op">.</span><span class="fu">map</span>(parseInt)<span class="op">;</span></span></code></pre></div>
<p>Aplikace funkce <code>Number</code> vrátí pole tří správných desítek.
Výsledkem druhého volání je ovšem značně nezvyklé pole
<code>[10, NaN, 2]</code> – a méně zkušený programátor si bude dlouho
lámat hlavu nad tím, proč se správně podařilo zpracovat jen první
hodnotu.</p>
<p>Odpověď můžeme nalézt v minulé kapitole, respektive její podkapitole
pro koumáky. Připomeňme, že v rámci funkcionální iterace
<code>map</code> dostává iterační funkce (zde <code>parseInt</code>)
celkem tři parametry: iterovaný prvek, jeho pořadí (index) a celé pole.
Nastanou tedy tato tři volání:</p>
<div class="sourceCode" id="cb96"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb96-1"><a href="#cb96-1" aria-hidden="true" tabindex="-1"></a><span class="pp">parseInt</span>(<span class="st">&quot;10&quot;</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> [<span class="st">&quot;10&quot;</span><span class="op">,</span> <span class="st">&quot;10&quot;</span><span class="op">,</span> <span class="st">&quot;10&quot;</span>])<span class="op">;</span>  <span class="co">// 10</span></span>
<span id="cb96-2"><a href="#cb96-2" aria-hidden="true" tabindex="-1"></a><span class="pp">parseInt</span>(<span class="st">&quot;10&quot;</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> [<span class="st">&quot;10&quot;</span><span class="op">,</span> <span class="st">&quot;10&quot;</span><span class="op">,</span> <span class="st">&quot;10&quot;</span>])<span class="op">;</span>  <span class="co">// NaN</span></span>
<span id="cb96-3"><a href="#cb96-3" aria-hidden="true" tabindex="-1"></a><span class="pp">parseInt</span>(<span class="st">&quot;10&quot;</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> [<span class="st">&quot;10&quot;</span><span class="op">,</span> <span class="st">&quot;10&quot;</span><span class="op">,</span> <span class="st">&quot;10&quot;</span>])<span class="op">;</span>  <span class="co">// 2</span></span></code></pre></div>
<p>Třetí parametr je funkcí <code>parseInt</code> ignorován, druhý
specifikuje číselnou soustavu. Nula zde funguje jako <em>nezadáno</em>,
použije se tedy výchozí desítková soustava. Na druhém řádku vyžadujeme
použití <em>jedničkové soustavy</em>, což je sice teoreticky možné, ale
v praxi zakázané – výsledek je <code>NaN</code>. A třetí řádek
představuje převod čísla ve dvojkové soustavě, kde zápis
<code>"10"</code> odpovídá desítkovému číslu <code>2</code>.</p>
<h1 id="třídy-a-objekty">Třídy a objekty</h1>
<h2 id="úloha-6">Úloha</h2>
<p>Administrační systém z minulé kapitoly se rozrostl a stávající
implementace nedovoluje snadné rozšiřování. Rozdělte kód do menších,
samostatně funkčních celků. Použijte techniky objektově orientovaného
programování.</p>
<h3 id="řešení-6">Řešení</h3>
<div class="sourceCode" id="cb97"><pre
class="sourceCode html"><code class="sourceCode html"><span id="cb97-1"><a href="#cb97-1" aria-hidden="true" tabindex="-1"></a><span class="co">&lt;!-- kapitola-8.html --&gt;</span></span>
<span id="cb97-2"><a href="#cb97-2" aria-hidden="true" tabindex="-1"></a><span class="dt">&lt;</span><span class="kw">h2</span><span class="dt">&gt;</span>Nové komentáře<span class="dt">&lt;/</span><span class="kw">h2</span><span class="dt">&gt;</span></span>
<span id="cb97-3"><a href="#cb97-3" aria-hidden="true" tabindex="-1"></a><span class="dt">&lt;</span><span class="kw">ul</span> <span class="er">id</span><span class="ot">=</span><span class="st">&quot;new&quot;</span><span class="dt">&gt;&lt;/</span><span class="kw">ul</span><span class="dt">&gt;</span></span>
<span id="cb97-4"><a href="#cb97-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb97-5"><a href="#cb97-5" aria-hidden="true" tabindex="-1"></a><span class="dt">&lt;</span><span class="kw">h2</span><span class="dt">&gt;</span>Schválené komentáře<span class="dt">&lt;/</span><span class="kw">h2</span><span class="dt">&gt;</span></span>
<span id="cb97-6"><a href="#cb97-6" aria-hidden="true" tabindex="-1"></a><span class="dt">&lt;</span><span class="kw">ul</span> <span class="er">id</span><span class="ot">=</span><span class="st">&quot;approved&quot;</span><span class="dt">&gt;&lt;/</span><span class="kw">ul</span><span class="dt">&gt;</span></span>
<span id="cb97-7"><a href="#cb97-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb97-8"><a href="#cb97-8" aria-hidden="true" tabindex="-1"></a><span class="dt">&lt;</span><span class="kw">script</span><span class="ot"> type=</span><span class="st">&quot;module&quot;</span> <span class="er">src</span><span class="ot">=</span><span class="st">&quot;kapitola-8.js&quot;</span><span class="dt">&gt;&lt;/</span><span class="kw">script</span><span class="dt">&gt;</span></span></code></pre></div>
<div class="sourceCode" id="cb98"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb98-1"><a href="#cb98-1" aria-hidden="true" tabindex="-1"></a><span class="co">// kapitola-8.js</span></span>
<span id="cb98-2"><a href="#cb98-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> <span class="bu">Comment</span> <span class="im">from</span> <span class="st">&quot;./comment.js&quot;</span><span class="op">;</span></span>
<span id="cb98-3"><a href="#cb98-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb98-4"><a href="#cb98-4" aria-hidden="true" tabindex="-1"></a><span class="im">export</span> <span class="kw">async</span> <span class="kw">function</span> <span class="fu">loadComments</span>() {</span>
<span id="cb98-5"><a href="#cb98-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> response <span class="op">=</span> <span class="cf">await</span> <span class="fu">fetch</span>(<span class="st">&quot;/comments&quot;</span>)<span class="op">;</span></span>
<span id="cb98-6"><a href="#cb98-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> comments <span class="op">=</span> <span class="cf">await</span> response<span class="op">.</span><span class="fu">json</span>()<span class="op">;</span></span>
<span id="cb98-7"><a href="#cb98-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb98-8"><a href="#cb98-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> newList <span class="op">=</span> <span class="bu">document</span><span class="op">.</span><span class="fu">querySelector</span>(<span class="st">&quot;#new&quot;</span>)<span class="op">;</span></span>
<span id="cb98-9"><a href="#cb98-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> approvedList <span class="op">=</span> <span class="bu">document</span><span class="op">.</span><span class="fu">querySelector</span>(<span class="st">&quot;#approved&quot;</span>)<span class="op">;</span></span>
<span id="cb98-10"><a href="#cb98-10" aria-hidden="true" tabindex="-1"></a>  newList<span class="op">.</span><span class="fu">replaceChildren</span>()<span class="op">;</span></span>
<span id="cb98-11"><a href="#cb98-11" aria-hidden="true" tabindex="-1"></a>  approvedList<span class="op">.</span><span class="fu">replaceChildren</span>()<span class="op">;</span></span>
<span id="cb98-12"><a href="#cb98-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb98-13"><a href="#cb98-13" aria-hidden="true" tabindex="-1"></a>  comments<span class="op">.</span><span class="fu">forEach</span>(c <span class="kw">=&gt;</span> {</span>
<span id="cb98-14"><a href="#cb98-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> comment <span class="op">=</span> <span class="kw">new</span> <span class="bu">Comment</span>(c)<span class="op">;</span></span>
<span id="cb98-15"><a href="#cb98-15" aria-hidden="true" tabindex="-1"></a>    (c<span class="op">.</span><span class="at">approved</span> <span class="op">?</span> approvedList <span class="op">:</span> newList)<span class="op">.</span><span class="fu">append</span>(comment<span class="op">.</span><span class="at">node</span>)<span class="op">;</span></span>
<span id="cb98-16"><a href="#cb98-16" aria-hidden="true" tabindex="-1"></a>  })<span class="op">;</span></span>
<span id="cb98-17"><a href="#cb98-17" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb98-18"><a href="#cb98-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb98-19"><a href="#cb98-19" aria-hidden="true" tabindex="-1"></a><span class="fu">loadComments</span>()<span class="op">;</span></span></code></pre></div>
<div class="sourceCode" id="cb99"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb99-1"><a href="#cb99-1" aria-hidden="true" tabindex="-1"></a><span class="co">// comment.js</span></span>
<span id="cb99-2"><a href="#cb99-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> { loadComments } <span class="im">from</span> <span class="st">&quot;./kapitola-8.js&quot;</span><span class="op">;</span></span>
<span id="cb99-3"><a href="#cb99-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb99-4"><a href="#cb99-4" aria-hidden="true" tabindex="-1"></a><span class="im">export</span> <span class="im">default</span> <span class="kw">class</span> <span class="bu">Comment</span> {</span>
<span id="cb99-5"><a href="#cb99-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">constructor</span>(data) {</span>
<span id="cb99-6"><a href="#cb99-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> node <span class="op">=</span> <span class="bu">document</span><span class="op">.</span><span class="fu">createElement</span>(<span class="st">&quot;li&quot;</span>)<span class="op">;</span></span>
<span id="cb99-7"><a href="#cb99-7" aria-hidden="true" tabindex="-1"></a>    node<span class="op">.</span><span class="at">textContent</span> <span class="op">=</span> <span class="vs">`</span><span class="sc">${</span>data<span class="op">.</span><span class="at">author</span><span class="sc">}</span><span class="vs">: </span><span class="sc">${</span>data<span class="op">.</span><span class="at">text</span><span class="sc">}</span><span class="vs">`</span><span class="op">;</span></span>
<span id="cb99-8"><a href="#cb99-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb99-9"><a href="#cb99-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (<span class="op">!</span>data<span class="op">.</span><span class="at">approved</span>) { node<span class="op">.</span><span class="fu">append</span>(<span class="kw">this</span><span class="op">.</span><span class="fu">buildApproveButton</span>())<span class="op">;</span> }</span>
<span id="cb99-10"><a href="#cb99-10" aria-hidden="true" tabindex="-1"></a>    node<span class="op">.</span><span class="fu">append</span>(<span class="kw">this</span><span class="op">.</span><span class="fu">buildDeleteButton</span>())<span class="op">;</span></span>
<span id="cb99-11"><a href="#cb99-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb99-12"><a href="#cb99-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">this</span><span class="op">.</span><span class="at">id</span> <span class="op">=</span> data<span class="op">.</span><span class="at">id</span><span class="op">;</span></span>
<span id="cb99-13"><a href="#cb99-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">this</span><span class="op">.</span><span class="at">node</span> <span class="op">=</span> node<span class="op">;</span></span>
<span id="cb99-14"><a href="#cb99-14" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb99-15"><a href="#cb99-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb99-16"><a href="#cb99-16" aria-hidden="true" tabindex="-1"></a>  <span class="fu">buildApproveButton</span>() {</span>
<span id="cb99-17"><a href="#cb99-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> button <span class="op">=</span> <span class="fu">buildButton</span>(<span class="st">&quot;Schválit&quot;</span>)<span class="op">;</span></span>
<span id="cb99-18"><a href="#cb99-18" aria-hidden="true" tabindex="-1"></a>    button<span class="op">.</span><span class="fu">addEventListener</span>(<span class="st">&quot;click&quot;</span><span class="op">,</span> <span class="kw">async</span> e <span class="kw">=&gt;</span> {</span>
<span id="cb99-19"><a href="#cb99-19" aria-hidden="true" tabindex="-1"></a>      <span class="cf">await</span> <span class="kw">this</span><span class="op">.</span><span class="fu">approve</span>()<span class="op">;</span></span>
<span id="cb99-20"><a href="#cb99-20" aria-hidden="true" tabindex="-1"></a>      <span class="fu">loadComments</span>()<span class="op">;</span></span>
<span id="cb99-21"><a href="#cb99-21" aria-hidden="true" tabindex="-1"></a>    })<span class="op">;</span></span>
<span id="cb99-22"><a href="#cb99-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> button<span class="op">;</span></span>
<span id="cb99-23"><a href="#cb99-23" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb99-24"><a href="#cb99-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb99-25"><a href="#cb99-25" aria-hidden="true" tabindex="-1"></a>  <span class="fu">buildDeleteButton</span>() {</span>
<span id="cb99-26"><a href="#cb99-26" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> button <span class="op">=</span> <span class="fu">buildButton</span>(<span class="st">&quot;Smazat&quot;</span>)<span class="op">;</span></span>
<span id="cb99-27"><a href="#cb99-27" aria-hidden="true" tabindex="-1"></a>    button<span class="op">.</span><span class="fu">addEventListener</span>(<span class="st">&quot;click&quot;</span><span class="op">,</span> <span class="kw">async</span> e <span class="kw">=&gt;</span> {</span>
<span id="cb99-28"><a href="#cb99-28" aria-hidden="true" tabindex="-1"></a>      <span class="cf">await</span> <span class="kw">this</span><span class="op">.</span><span class="fu">delete</span>()<span class="op">;</span></span>
<span id="cb99-29"><a href="#cb99-29" aria-hidden="true" tabindex="-1"></a>      <span class="fu">loadComments</span>()<span class="op">;</span></span>
<span id="cb99-30"><a href="#cb99-30" aria-hidden="true" tabindex="-1"></a>    })<span class="op">;</span></span>
<span id="cb99-31"><a href="#cb99-31" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> button<span class="op">;</span></span>
<span id="cb99-32"><a href="#cb99-32" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb99-33"><a href="#cb99-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb99-34"><a href="#cb99-34" aria-hidden="true" tabindex="-1"></a>  <span class="kw">delete</span>() {</span>
<span id="cb99-35"><a href="#cb99-35" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="fu">fetch</span>(<span class="vs">`/comments/</span><span class="sc">${</span><span class="kw">this</span><span class="op">.</span><span class="at">id</span><span class="sc">}</span><span class="vs">`</span><span class="op">,</span> {<span class="dt">method</span><span class="op">:</span> <span class="st">&quot;DELETE&quot;</span>})<span class="op">;</span></span>
<span id="cb99-36"><a href="#cb99-36" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb99-37"><a href="#cb99-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb99-38"><a href="#cb99-38" aria-hidden="true" tabindex="-1"></a>  <span class="fu">approve</span>(id) {</span>
<span id="cb99-39"><a href="#cb99-39" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="fu">fetch</span>(<span class="vs">`/comments/</span><span class="sc">${</span><span class="kw">this</span><span class="op">.</span><span class="at">id</span><span class="sc">}</span><span class="vs">/approve`</span><span class="op">,</span> {<span class="dt">method</span><span class="op">:</span> <span class="st">&quot;POST&quot;</span>})<span class="op">;</span></span>
<span id="cb99-40"><a href="#cb99-40" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb99-41"><a href="#cb99-41" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb99-42"><a href="#cb99-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb99-43"><a href="#cb99-43" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">buildButton</span>(label) {</span>
<span id="cb99-44"><a href="#cb99-44" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> button <span class="op">=</span> <span class="bu">document</span><span class="op">.</span><span class="fu">createElement</span>(<span class="st">&quot;button&quot;</span>)<span class="op">;</span></span>
<span id="cb99-45"><a href="#cb99-45" aria-hidden="true" tabindex="-1"></a>  button<span class="op">.</span><span class="at">textContent</span> <span class="op">=</span> label<span class="op">;</span></span>
<span id="cb99-46"><a href="#cb99-46" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> button<span class="op">;</span></span>
<span id="cb99-47"><a href="#cb99-47" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Kód z minulé kapitoly doznal značných změn, přesto je jeho
funkcionalita stejná. Provedli jsme <strong>refactoring</strong>:
přepracování kódu za účelem přípravy na další rozšiřování.</p>
<h3 id="třídy">Třídy</h3>
<p>O vykreslení komentáře a související interaktivitu se nově stará
třída <code>Comment</code>. JavaScriptové třídy jsou klasickým
mechanismem pro objektově orientované programování. Jde o koncept entit,
které spolu kombinují správu dat a logiku, jež s těmito daty pracuje.
Třída je pak jakási šablona, která popisuje, jak budou z ní odvozené
objekty (těm se říká <em>instance</em>) fungovat. Definice a chování
tříd v Java­Scriptu se blíží jiným tradičním objektově orientovaným
jazykům, jako je Java nebo C++.</p>
<p>Syntakticky je definice třídy zabalená do složených závorek a jedná
se vlastně jen o výčet jednotlivých metod, kterými budou instance této
třídy disponovat. Speciálně pojmenovaná metoda <code>constructor</code>
bude vykonána vždy při vzniku nové instance, tj. při použití zápisu
<code>new Comment</code>. Zájemcům o detailnější pochopení toho, <em>co
to vlastně třídy jsou</em>, je pak určena podkapitola pro profíky.</p>
<p>V metodách tříd se často objevuje důležité klíčové slovo
<code>this</code>. Pomocí něj můžeme odkazovat na tu instanci třídy,
jejíž metoda je právě vykonávána. Snadno tak pro konkrétní komentář
zavoláme nějakou jeho metodu (např. <code>this.approve()</code>,
<code>this.delete()</code>), nebo přistoupíme k jeho vlastnostem
(<code>this.id</code>). Klíčové slovo <code>this</code> je ve
skutečnosti výrazně komplikovanější, než se při pohledu na vzorové
řešení zdá, a je mu proto věnována podkapitola pro koumáky.</p>
<h3 id="js-moduly-1">JS moduly</h3>
<p>Druhá novinka je rozdělení JavaScriptu do dvou souborů. To je logický
krok ve chvíli, kdy objem kódu přesáhne jistou subjektivní mez. V našem
případě se jedná o hlavní soubor <code>kapitola-8.js</code> (obsahuje
logiku načítání) a dále <code>comment.js</code> (obsahuje management
komentářů). Aby bylo možné realizovat spolupráci mezi těmito soubory,
použijeme koncept JS modulů (poprvé jsme o něm slyšeli ve druhé
kapitole, v podkapitole pro profíky). To znamená tyto kroky:</p>
<ol type="1">
<li><p>V HTML prvku <code>&lt;script&gt;</code> přidáme atribut
<code>type="module"</code>. Tím je soubor <code>kapitola-8.js</code>
považován za JS modul a jím importované soubory taktéž.</p></li>
<li><p>Pokud chceme nějakou funkcionalitu v JS modulu nabídnout
k použití, přidáme před ni klíčové slovo <code>export</code>.</p></li>
<li><p>Pokud chceme v jednom souboru přistoupit k funkcionalitě
z jiného, musíme ji nejprve importovat klíčovým slovem
<code>import</code>.</p></li>
</ol>
<p>Pozor! Při používání JS modulů přistupuje prohlížeč o něco striktněji
k atributu <code>src</code> u HTML prvku <code>&lt;script&gt;</code>.
Toto URL nově podstupuje kontrolu <em>originu</em> (viz pátou kapitolu)
a musí používat protokol HTTP, tj. zejména není možné jej načítat
pseudo-protokolem <code>file://</code>. To je pro rychlý lokální vývoj
komplikace, neboť se u JS modulů neobejdeme bez opravdového HTTP
serveru, který bude soubory (HTML, JS a další) vydávat. Jakmile tedy
začneme JS moduly používat, budeme se muset seznámit s libovolným
webovým serverem. Naštěstí je takových velké množství: může to být
dedikovaná aplikace (Apache, Nginx), vývojový server vestavěný do
různých jazyků (PHP, Python Flask, Node.js) nebo třeba rozšíření do
oblíbeného IDE.</p>
<p>JS moduly mohou exportovat libovolné množství <em>pojmenovaných
věcí</em> (proměnných, funkcí, tříd, …) a také jeden tzv. <em>výchozí
(default) export</em>. Rozdíl mezi pojmenovanou a nepojmenovanou věcí je
jen v tom, jak se k nim následně přistupuje z jiného souboru. Třída
<code>Comment</code> je výchozí export (při importu pak uvádíme jen
jméno, pod kterým má být výchozí export dostupný v importujícím
souboru), funkce <code>loadComments</code> je pojmenovaný export (při
importu musíme uvést její název ve složených závorkách).</p>
<p>Všimněme si také, že naše dva soubory na sobě navzájem závisí. Soubor
<code>kapitola-8.js</code> importuje třídu <code>Comment</code>
z <code>comment.js</code> a naopak třída <code>Comment</code> volá
funkci <code>loadComments</code> z <code>kapitola-8.js</code>. Takové
situaci se říká <em>kruhová závislost</em> a může to být známkou
nevhodně navržené aplikace. V našem případě to ničemu nevadí, ale i tak
pojďme zvážit, jak bychom se mohli kruhové závislosti vyhnout.</p>
<p>Funkce <code>loadComments</code> potřebuje znát třídu
<code>Comment</code>, protože sama o sobě neumí získaná data zpracovat
(to je hlavním cílem refactoringu v této kapitole). Taková závislost je
tedy v pořádku. Abychom kruhovou závislost rozbili, mohli bychom třídu
<code>Comment</code> přepracovat tak, aby po změně komentáře nevolala
<code>loadComments</code> (pak by nemusela importovat nic ze souboru
<code>kapitola-8.js</code>). Jinými slovy, aby se v rámci posluchačů
klikání na tlačítka jen <em>dalo vědět</em>, že došlo ke změně komentáře
– a nějaká jiná komponenta by pak rozhodla, že je nutné data znovu
načíst.</p>
<p>Jedním možným přístupem by bylo vytvoření <em>vlastní události</em>,
kterou by třída <code>Comment</code> vyvolala po změně komentáře. Tuto
událost může zachytit kód v hlavním modulu a zavolat
<code>loadComments</code>. Takové řešení dobře zapadá do ekosystému DOM
událostí, ale pro naše potřeby je možná zbytečně složité. Třída
<code>Comment</code> může o změně komentáře dát vědět i jednodušším
způsobem:</p>
<div class="sourceCode" id="cb100"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb100-1"><a href="#cb100-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="bu">Comment</span> {</span>
<span id="cb100-2"><a href="#cb100-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">commentChanged</span>() {}</span>
<span id="cb100-3"><a href="#cb100-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb100-4"><a href="#cb100-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">buildApproveButton</span>() {</span>
<span id="cb100-5"><a href="#cb100-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> button <span class="op">=</span> <span class="fu">buildButton</span>(<span class="st">&quot;Schválit&quot;</span>)<span class="op">;</span></span>
<span id="cb100-6"><a href="#cb100-6" aria-hidden="true" tabindex="-1"></a>    button<span class="op">.</span><span class="fu">addEventListener</span>(<span class="st">&quot;click&quot;</span><span class="op">,</span> <span class="kw">async</span> e <span class="kw">=&gt;</span> {</span>
<span id="cb100-7"><a href="#cb100-7" aria-hidden="true" tabindex="-1"></a>      <span class="cf">await</span> <span class="kw">this</span><span class="op">.</span><span class="fu">approve</span>()<span class="op">;</span></span>
<span id="cb100-8"><a href="#cb100-8" aria-hidden="true" tabindex="-1"></a>      <span class="kw">this</span><span class="op">.</span><span class="fu">commentChanged</span>()<span class="op">;</span></span>
<span id="cb100-9"><a href="#cb100-9" aria-hidden="true" tabindex="-1"></a>    })<span class="op">;</span></span>
<span id="cb100-10"><a href="#cb100-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> button<span class="op">;</span></span>
<span id="cb100-11"><a href="#cb100-11" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb100-12"><a href="#cb100-12" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb100-13"><a href="#cb100-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb100-14"><a href="#cb100-14" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> comment <span class="op">=</span> <span class="kw">new</span> <span class="bu">Comment</span>(data)<span class="op">;</span></span>
<span id="cb100-15"><a href="#cb100-15" aria-hidden="true" tabindex="-1"></a>comment<span class="op">.</span><span class="at">commentChanged</span> <span class="op">=</span> loadComments<span class="op">;</span></span></code></pre></div>
<p>Proč definice třídy <code>Comment</code> vůbec obsahuje prázdnou
metodu <code>commentChanged?</code> Ze dvou důvodů. Za prvé tím čtenáři
našeho kódu naznačujeme existenci této metody, dále pak prázdnou (ale
existující!) metodou vyřešíme situaci, kdy by došlo ke kliknutí na
tlačítko, aniž by v instanci někdo vlastnost <code>commentChange</code>
přepsal na svou vlastní funkci.</p>
<h3 id="co-jsme-se-naučili-5">Co jsme se naučili</h3>
<p>Po vyřešení sedmé úlohy by měl čtenář chápat a ovládat:</p>
<ul>
<li><p>definici a použití JS tříd</p></li>
<li><p>dělení kódu na JS moduly</p></li>
<li><p>použití klíčových slov <code>import</code>
a <code>export</code></p></li>
</ul>
<h2 id="zelenáči-odebírání-posluchačů-událostí">Zelenáči: odebírání
posluchačů událostí</h2>
<p>S událostmi se setkáváme téměř v každé kapitole. Ve světě objektově
orientovaného programování představují jistou výzvu zejména v tom
okamžiku, kdy nás <em>existující posluchač přestal zajímat</em>, tj. kdy
o něj již nestojíme. Ve vzorovém řešení se objevuje třída
<code>Comment</code>, která poslouchá událost kliknutí na jednotlivých
tlačítkách. Během interakce s naším administračním systémem ovšem
instance třídy <code>Comment</code> vznikají (zápisem
<code>new Comment</code>) a následně zase zanikají (když v důsledku
<code>loadComments</code> vymažeme staré položky, o paměť se časem
postará garbage collector). Co se děje se všemi těmi posluchači
událostí, které již nemohou nastat?</p>
<p>Především je nutné poznat a odlišit situace, kdy posluchač zmizí sám
od sebe (prohlížeč jej odebere) a kdy musíme naopak sami prostřednictvím
metody <code>removeEventListener</code> poslouchání ukončit. Vzorová
třída <code>Comment</code> představuje vzájemnou provázanost HTML prvku
a instance JavaScriptové třídy:</p>
<ul>
<li><p>Dokud existuje HTML prvek <code>&lt;button&gt;</code>
s posluchačem události, musí existovat i instance
<code>Comment</code>.</p></li>
<li><p>Dokud existuje JS instance <code>Comment</code>, musí existovat
i jí odpovídající HTML dostupné prostřednictvím vlastnosti
<code>node</code>.</p></li>
</ul>
<p>To znamená, že garbage collector začne pracovat teprve poté, co
přestaneme používat instance třídy a zároveň z dokumentu odstraníme
relevantní HTML prvky. Instance si nikam neukládáme a při nejbližším
zavolání <code>loadComments</code> zaniknou i jim odpovídající HTML
uzly. Obě provázané entity zmizí včetně posluchačů událostí. Nemusíme
tedy dělat nic.</p>
<p>Komplikovanější situace by nastala, kdyby třída <code>Comment</code>
použila posluchač události mimo své vlastní HTML. Mohl by to být
posluchač na objektu <code>window</code> (třeba událost
<code>keydown</code> odpovídající stisku klávesy nebo událost
<code>popstate</code> z šesté kapitoly) či na objektu
<code>document</code> (třeba událost <code>paste</code> při vložení ze
schránky). Pak by garbage collector nemohl nikdy uvolnit paměť zabranou
instancí <code>Comment</code>, přestože by její vlastní HTML ze stránky
již dávno zmizelo. Mohla by totiž nastat zmiňovaná událost a v jejím
důsledku by se vykonal posluchač instanci náležící. Čím víc komentářů
bychom zobrazili, tím víc posluchačů by zůstávalo přidaných.</p>
<p>To je samozřejmě nešikovné, hned ze dvou důvodů. Jednak proto, že při
vzniku události dojde k vykonání dávno neužitečných posluchačů, a poté
proto, že tím dochází k nárůstu zabrané paměti, kterou bychom rádi
uvolnili pro užitečnější účely. Tomuto jevu se říká <strong>memory
leak</strong> a chceme se mu rozhodně vyhnout. Budeme proto muset naše
instance ve vhodnou chvíli upozornit, aby své posluchače odebraly.</p>
<p>Pokud je posluchač pojmenovaná funkce, můžeme jej odebrat DOM-metodou
<code>removeEventListener</code>:</p>
<div class="sourceCode" id="cb101"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb101-1"><a href="#cb101-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">onClick</span>(e) { <span class="op">...</span> }</span>
<span id="cb101-2"><a href="#cb101-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-3"><a href="#cb101-3" aria-hidden="true" tabindex="-1"></a><span class="bu">document</span><span class="op">.</span><span class="fu">addEventListener</span>(<span class="st">&quot;click&quot;</span><span class="op">,</span> onClick)<span class="op">;</span></span>
<span id="cb101-4"><a href="#cb101-4" aria-hidden="true" tabindex="-1"></a><span class="co">// a později:</span></span>
<span id="cb101-5"><a href="#cb101-5" aria-hidden="true" tabindex="-1"></a><span class="bu">document</span><span class="op">.</span><span class="fu">removeEventListener</span>(<span class="st">&quot;click&quot;</span><span class="op">,</span> onClick)<span class="op">;</span></span></code></pre></div>
<p>V případě objektů ale posluchače většinou vypadají jinak – jako malé
anonymní arrow funkce, které následně volají další metody objektu. Třeba
takto:</p>
<div class="sourceCode" id="cb102"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb102-1"><a href="#cb102-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="bu">Comment</span> {</span>
<span id="cb102-2"><a href="#cb102-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">constructor</span>() {</span>
<span id="cb102-3"><a href="#cb102-3" aria-hidden="true" tabindex="-1"></a>    <span class="bu">document</span><span class="op">.</span><span class="fu">addEventListener</span>(<span class="st">&quot;click&quot;</span><span class="op">,</span> e <span class="kw">=&gt;</span> <span class="kw">this</span><span class="op">.</span><span class="fu">remove</span>())<span class="op">;</span></span>
<span id="cb102-4"><a href="#cb102-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">// tak to fungovat nebude:</span></span>
<span id="cb102-5"><a href="#cb102-5" aria-hidden="true" tabindex="-1"></a>    <span class="bu">document</span><span class="op">.</span><span class="fu">removeEventListener</span>(<span class="st">&quot;click&quot;</span><span class="op">,</span> e <span class="kw">=&gt;</span> <span class="kw">this</span><span class="op">.</span><span class="fu">remove</span>())<span class="op">;</span></span>
<span id="cb102-6"><a href="#cb102-6" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb102-7"><a href="#cb102-7" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Proč výše uvedený kód nebude fungovat? Neboť pro úspěšné odebrání
posluchače musíme metodě <code>removeEventListener</code> předat tu
samou funkci, kterou jsme dříve použili pro
<code>addEventListener</code>. Naše dvě malé arrow funkce sice
<em>dělají to samé</em>, ale jsou to dvě různé funkce (nerovnají se).
Pojďme se proto podívat na dvě další možnosti, jak posluchače událostí
odebrat.</p>
<h3 id="metoda-handleevent">Metoda handleEvent</h3>
<p>Navykli jsme si, že druhý parametr pro <code>addEventListener</code>
je funkce. To ovšem není jediná možnost: může to být také objekt, který
má vlastnost <code>handleEvent</code>. Tato vlastnost je, pakliže se
jedná o funkci, volána při vzniku události. Pokud bychom tedy třídě
<code>Comment</code> takovou vlastnost přidali, stala by se třída jako
taková posluchačem. Kód by mohl vypadat takto:</p>
<div class="sourceCode" id="cb103"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb103-1"><a href="#cb103-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="bu">Comment</span> {</span>
<span id="cb103-2"><a href="#cb103-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">buildApproveButton</span>() {</span>
<span id="cb103-3"><a href="#cb103-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> button <span class="op">=</span> <span class="fu">buildButton</span>(<span class="st">&quot;Schválit&quot;</span>)<span class="op">;</span></span>
<span id="cb103-4"><a href="#cb103-4" aria-hidden="true" tabindex="-1"></a>    button<span class="op">.</span><span class="at">dataset</span><span class="op">.</span><span class="at">action</span> <span class="op">=</span> <span class="st">&quot;approve&quot;</span><span class="op">;</span></span>
<span id="cb103-5"><a href="#cb103-5" aria-hidden="true" tabindex="-1"></a>    button<span class="op">.</span><span class="fu">addEventListener</span>(<span class="st">&quot;click&quot;</span><span class="op">,</span> <span class="kw">this</span>)<span class="op">;</span></span>
<span id="cb103-6"><a href="#cb103-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> button<span class="op">;</span></span>
<span id="cb103-7"><a href="#cb103-7" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb103-8"><a href="#cb103-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb103-9"><a href="#cb103-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">buildDeleteButton</span>() {</span>
<span id="cb103-10"><a href="#cb103-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> button <span class="op">=</span> <span class="fu">buildButton</span>(<span class="st">&quot;Smazat&quot;</span>)<span class="op">;</span></span>
<span id="cb103-11"><a href="#cb103-11" aria-hidden="true" tabindex="-1"></a>    button<span class="op">.</span><span class="at">dataset</span><span class="op">.</span><span class="at">action</span> <span class="op">=</span> <span class="st">&quot;delete&quot;</span><span class="op">;</span></span>
<span id="cb103-12"><a href="#cb103-12" aria-hidden="true" tabindex="-1"></a>    button<span class="op">.</span><span class="fu">addEventListener</span>(<span class="st">&quot;click&quot;</span><span class="op">,</span> <span class="kw">this</span>)<span class="op">;</span></span>
<span id="cb103-13"><a href="#cb103-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> button<span class="op">;</span></span>
<span id="cb103-14"><a href="#cb103-14" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb103-15"><a href="#cb103-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb103-16"><a href="#cb103-16" aria-hidden="true" tabindex="-1"></a>  <span class="kw">async</span> <span class="fu">handleEvent</span>(e) {</span>
<span id="cb103-17"><a href="#cb103-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> actionNode <span class="op">=</span> e<span class="op">.</span><span class="at">target</span><span class="op">.</span><span class="fu">closest</span>(<span class="st">&quot;[data-action]&quot;</span>)<span class="op">;</span></span>
<span id="cb103-18"><a href="#cb103-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">switch</span> (actionNode<span class="op">.</span><span class="at">dataset</span><span class="op">.</span><span class="at">action</span>) {</span>
<span id="cb103-19"><a href="#cb103-19" aria-hidden="true" tabindex="-1"></a>      <span class="cf">case</span> <span class="st">&quot;delete&quot;</span><span class="op">:</span></span>
<span id="cb103-20"><a href="#cb103-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">await</span> <span class="kw">this</span><span class="op">.</span><span class="fu">delete</span>()<span class="op">;</span></span>
<span id="cb103-21"><a href="#cb103-21" aria-hidden="true" tabindex="-1"></a>        <span class="fu">loadComments</span>()<span class="op">;</span></span>
<span id="cb103-22"><a href="#cb103-22" aria-hidden="true" tabindex="-1"></a>      <span class="cf">break</span><span class="op">;</span></span>
<span id="cb103-23"><a href="#cb103-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb103-24"><a href="#cb103-24" aria-hidden="true" tabindex="-1"></a>      <span class="cf">case</span> <span class="st">&quot;approve&quot;</span><span class="op">:</span></span>
<span id="cb103-25"><a href="#cb103-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">await</span> <span class="kw">this</span><span class="op">.</span><span class="fu">approve</span>()<span class="op">;</span></span>
<span id="cb103-26"><a href="#cb103-26" aria-hidden="true" tabindex="-1"></a>        <span class="fu">loadComments</span>()<span class="op">;</span></span>
<span id="cb103-27"><a href="#cb103-27" aria-hidden="true" tabindex="-1"></a>      <span class="cf">break</span><span class="op">;</span></span>
<span id="cb103-28"><a href="#cb103-28" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb103-29"><a href="#cb103-29" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb103-30"><a href="#cb103-30" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Hodí se nám zde technika delegování událostí, protože metoda
<code>handleEvent</code> se nyní věnuje všem (oběma) interakcím, které
mohou nastat. Potřebujeme v ní proto odlišit, na co bylo kliknuto, tj.
co se má v rámci události vykonat.</p>
<p>V tuto chvíli je pak snadné posluchače odebrat. Druhý parametr známe
(je to instance <code>Comment</code>, tj. <code>this</code>)
a potřebujeme jen znát tlačítka, na které jsme posluchač přidali. Mohli
bychom tedy třídě <code>Comment</code> přidat <em>ukončovací</em>
metodu, která posluchače odebere:</p>
<div class="sourceCode" id="cb104"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb104-1"><a href="#cb104-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="bu">Comment</span> {</span>
<span id="cb104-2"><a href="#cb104-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">destroy</span>() {</span>
<span id="cb104-3"><a href="#cb104-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">const</span> s <span class="op">=</span> <span class="st">&quot;button[data-action]&quot;</span><span class="op">;</span></span>
<span id="cb104-4"><a href="#cb104-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> buttons <span class="op">=</span> <span class="bu">Array</span><span class="op">.</span><span class="fu">from</span>(<span class="kw">this</span><span class="op">.</span><span class="at">node</span><span class="op">.</span><span class="fu">querySelectorAll</span>(s))<span class="op">;</span></span>
<span id="cb104-5"><a href="#cb104-5" aria-hidden="true" tabindex="-1"></a>    buttons<span class="op">.</span><span class="fu">forEach</span>(b <span class="kw">=&gt;</span> b<span class="op">.</span><span class="fu">removeEventListener</span>(<span class="st">&quot;click&quot;</span><span class="op">,</span> <span class="kw">this</span>))<span class="op">;</span></span>
<span id="cb104-6"><a href="#cb104-6" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb104-7"><a href="#cb104-7" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Zvídavý čtenář jistě chápe, že tuto metodu je nutné někdy zavolat. Za
domácí úkol si proto může zkusit upravit funkci
<code>loadComments</code> tak, aby si vytvořené instance pamatovala
a při dalším volání ty předchozí nejprve <em>zničila</em> voláním metody
<code>destroy()</code>.</p>
<h3 id="objekt-abortcontroller">Objekt AbortController</h3>
<p>Velmi odlišný přístup k odebírání posluchačů představuje využití
relativně nového objektu <code>AbortController</code>. Můžeme si jej
představit jako krabičku s velkým červeným tlačítkem: jeho stisk slouží
k přerušení některých operací. Typicky jej používáme k přerušení HTTP
požadavků a nebo právě posluchačů událostí.</p>
<p>Při práci s objektem <code>AbortController</code> pak posluchače
neodebíráme metodou <code>removeEventListener</code>, ale pomyslným
stiskem onoho tlačítka. Tím lze přerušit celou řadu aktivit či
posluchačů – všechny, které jsme předtím k tlačítku připojili.</p>
<p>V praxi to můžeme zkusit třeba takto:</p>
<div class="sourceCode" id="cb105"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb105-1"><a href="#cb105-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="bu">Comment</span> {</span>
<span id="cb105-2"><a href="#cb105-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">constructor</span>() {</span>
<span id="cb105-3"><a href="#cb105-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">this</span><span class="op">.</span><span class="at">abortController</span> <span class="op">=</span> <span class="kw">new</span> <span class="fu">AbortController</span>()<span class="op">;</span></span>
<span id="cb105-4"><a href="#cb105-4" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb105-5"><a href="#cb105-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb105-6"><a href="#cb105-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">buildApproveButton</span>() {</span>
<span id="cb105-7"><a href="#cb105-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> signal <span class="op">=</span> <span class="kw">this</span><span class="op">.</span><span class="at">abortController</span><span class="op">.</span><span class="at">signal</span><span class="op">;</span></span>
<span id="cb105-8"><a href="#cb105-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb105-9"><a href="#cb105-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> button <span class="op">=</span> <span class="fu">buildButton</span>(<span class="st">&quot;Schválit&quot;</span>)<span class="op">;</span></span>
<span id="cb105-10"><a href="#cb105-10" aria-hidden="true" tabindex="-1"></a>    button<span class="op">.</span><span class="fu">addEventListener</span>(<span class="st">&quot;click&quot;</span><span class="op">,</span> <span class="kw">async</span> e <span class="kw">=&gt;</span> {</span>
<span id="cb105-11"><a href="#cb105-11" aria-hidden="true" tabindex="-1"></a>      <span class="cf">await</span> <span class="kw">this</span><span class="op">.</span><span class="fu">approve</span>()<span class="op">;</span></span>
<span id="cb105-12"><a href="#cb105-12" aria-hidden="true" tabindex="-1"></a>      <span class="fu">loadComments</span>()<span class="op">;</span></span>
<span id="cb105-13"><a href="#cb105-13" aria-hidden="true" tabindex="-1"></a>    }<span class="op">,</span> {signal})<span class="op">;</span></span>
<span id="cb105-14"><a href="#cb105-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> button<span class="op">;</span></span>
<span id="cb105-15"><a href="#cb105-15" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb105-16"><a href="#cb105-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb105-17"><a href="#cb105-17" aria-hidden="true" tabindex="-1"></a>  <span class="fu">destroy</span>() {</span>
<span id="cb105-18"><a href="#cb105-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">this</span><span class="op">.</span><span class="at">abortController</span><span class="op">.</span><span class="fu">abort</span>()<span class="op">;</span></span>
<span id="cb105-19"><a href="#cb105-19" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb105-20"><a href="#cb105-20" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Instance <code>abortController</code> je naše červené tlačítko; jeho
vlastnost <code>signal</code> je pak ten neviditelný drát, kterým je
spojeno s jedním či více posluchači. K tomu jsme metodě
<code>addEventListener</code> museli přidat třetí parametr. Je jím
konfigurační objekt (už jsme o něm slyšeli v minulé kapitole,
v podkapitole o zachytávání událostí).</p>
<p>V ukázce výše jsme použili <strong>šikovnou syntaktickou
zkratku,</strong> která mohla důkladné čtenáře zmást. Jedná se o zápis
<code>{signal}</code>. Jde o běžnou tvorbu objektu, ve kterém definujeme
klíč se stejným názvem a hodnotou, jako je uvedená proměnná. Pokud často
tvoříme takové slovníky, můžeme vhodně pojmenovanými proměnnými ušetřit
místo:</p>
<div class="sourceCode" id="cb106"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb106-1"><a href="#cb106-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> age <span class="op">=</span> <span class="dv">42</span><span class="op">;</span></span>
<span id="cb106-2"><a href="#cb106-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> name <span class="op">=</span> <span class="st">&quot;Jiří&quot;</span><span class="op">;</span></span>
<span id="cb106-3"><a href="#cb106-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> person <span class="op">=</span> {age<span class="op">,</span> name}<span class="op">;</span></span>
<span id="cb106-4"><a href="#cb106-4" aria-hidden="true" tabindex="-1"></a><span class="co">// stejné jako {age:age, name:name}</span></span></code></pre></div>
<p>Použití <code>AbortController</code> je velmi výhodné tam, kde chceme
naráz odebrat více posluchačů. Nemusíme si totiž nikde pamatovat ani
předané posluchače (funkce či objekt s metodou
<code>handleEvent</code>), ani HTML prvky, na které jsme je přidali
(tlačítka). Stačí mít jen po ruce jedinou instanci
<code>AbortController</code> a zavolat její metodu
<code>abort()</code>.</p>
<h2 id="koumáci-klíčové-slovo-this">Koumáci: klíčové slovo this</h2>
<p>Naše setkání s klíčovým slovem <code>this</code> v rámci třídy bylo
přímočaré. Prohlédněme si ovšem tento kód:</p>
<div class="sourceCode" id="cb107"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb107-1"><a href="#cb107-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="bu">Comment</span> {</span>
<span id="cb107-2"><a href="#cb107-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">constructor</span>(data) {</span>
<span id="cb107-3"><a href="#cb107-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">this</span><span class="op">.</span><span class="at">id</span> <span class="op">=</span> data<span class="op">.</span><span class="at">id</span><span class="op">;</span></span>
<span id="cb107-4"><a href="#cb107-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">this</span><span class="op">.</span><span class="at">node</span> <span class="op">=</span> <span class="bu">document</span><span class="op">.</span><span class="fu">createElement</span>(<span class="st">&quot;button&quot;</span>)<span class="op">;</span></span>
<span id="cb107-5"><a href="#cb107-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">this</span><span class="op">.</span><span class="at">node</span><span class="op">.</span><span class="fu">addEventListener</span>(<span class="st">&quot;click&quot;</span><span class="op">,</span> <span class="kw">this</span><span class="op">.</span><span class="at">onClick</span>)<span class="op">;</span></span>
<span id="cb107-6"><a href="#cb107-6" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb107-7"><a href="#cb107-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-8"><a href="#cb107-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">onClick</span>(e) {</span>
<span id="cb107-9"><a href="#cb107-9" aria-hidden="true" tabindex="-1"></a>    <span class="fu">alert</span>(<span class="kw">this</span><span class="op">.</span><span class="at">id</span>)<span class="op">;</span></span>
<span id="cb107-10"><a href="#cb107-10" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb107-11"><a href="#cb107-11" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Při kliknutí na tlačítko zjistíme, že vypisovaná hodnota
<code>this.id</code> je <code>undefined</code> – a že <code>this</code>
neodpovídá instanci <code>Comment</code>, ale tlačítku samotnému. Čím
to?</p>
<p>V JavaScriptu je hodnota <code>this</code> uvnitř funkce určena nejen
tím, jak funkci definujeme, ale především tím, jak ji voláme. Jedná se
fakticky o další, implicitní lokální proměnnou, která je dostupná ve
většině funkcí a metod. Její hodnota je ve chvíli volání určena řadou
pravidel. Můžeme je rozdělit do několika kategorií:</p>
<ol type="1">
<li><p><strong>Funkce volaná jako metoda objektu</strong>, tj. při
volání je vlevo od jejího názvu objekt oddělený tečkou: hodnotou
<code>this</code> bude objekt vlevo od tečky. To odpovídá přístupu
v jiných objektově orientovaných jazycích.</p></li>
<li><p><strong>Funkce předaná jako callback</strong>, tj. vykonaná
v rámci jiné funkce. Zde je hodnota <code>this</code> v kompetenci toho,
kdo callback volá. Za zmínku stojí tyto případy:</p>
<ul>
<li><p>Pokud je funkce posluchač události, lokální proměnná
<code>this</code> v ní bude objekt (zpravidla HTML prvek), na který jsme
posluchač přidali – ten vlevo od tečky při volání
<code>addEventListener</code>. K této hodnotě se můžeme dostat také
pomocí vlastnosti <code>currentTarget</code> objektu události (pozor na
drobný rozdíl v porovnání s <code>target</code>, který odpovídá prvku,
na kterém událost <em>vznikla</em>, nikoliv na kterém byla
zachycena).</p></li>
<li><p>Pokud je funkce použitá v rámci funkcionální iterace (tedy je
prvním parametrem pro <code>forEach</code>, <code>map</code>,
<code>filter</code> a další), můžeme její hodnotu <code>this</code>
určit jako druhý parametr iterační metody.</p></li>
</ul></li>
<li><p><strong>Speciální případy</strong>:</p>
<ul>
<li><p>Pokud je funkce vykonána prostřednictvím nepřímého volání
metodami <code>call</code>, <code>apply</code> nebo <code>bind</code>,
bude <code>this</code> rovno prvnímu parametru těchto metod. Tento
mechanismus pochází z historických dob JavaScriptu a dnes se příliš
nepoužívá.</p></li>
<li><p>Pokud je funkce vykonána prostřednictvím klíčového slova
<code>new</code>, bude <code>this</code> nově vytvářená instance. V této
kapitole si klíčové slovo <code>new</code> ukazujeme v rámci tříd, ale
nadcházející podkapitola vysvětlí, že třídy jsou ve skutečnosti
funkce.</p></li>
<li><p>Arrow funkce jsou z těchto pravidel zcela vyjmuty: lokální
proměnná <code>this</code> v nich neexistuje. Pokud v arrow funkci
<code>this</code> použijeme, bude to <code>this</code> převzaté
z okolního scope (stejně jako jakákoliv jiná proměnná dostupná
prostřednictvím uzávěry).</p></li>
</ul></li>
</ol>
<p>Když funkci voláme jen zapsáním jejího názvu a kulatých závorek,
nedává použití <code>this</code> v jejím těle smysl. I pro tento případ
je ovšem chování <code>this</code> specifikováno: bude to buď
<code>undefined</code>, nebo globální objekt (v prohlížeči
<code>window</code>). Rozhoduje se o tom podle toho, zdali se nacházíme
v tzv. <em>striktním režimu</em> (např. v rámci JS modulů – více o tom
ve čtrnácté kapitole), či nikoliv.</p>
<p>V praxi je pro nás <code>this</code> užitečné zejména v první
kategorii, kde s ním pracujeme intuitivně jako s instancí, k jejímž
metodám a vlastnostem přistupujeme. Docela dobře si však vystačíme
i s obyčejnými objekty:</p>
<div class="sourceCode" id="cb108"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb108-1"><a href="#cb108-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">logThis</span>() {</span>
<span id="cb108-2"><a href="#cb108-2" aria-hidden="true" tabindex="-1"></a>  <span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(<span class="kw">this</span>)<span class="op">;</span></span>
<span id="cb108-3"><a href="#cb108-3" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb108-4"><a href="#cb108-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-5"><a href="#cb108-5" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> a <span class="op">=</span> { logThis }<span class="op">;</span></span>
<span id="cb108-6"><a href="#cb108-6" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> b <span class="op">=</span> { logThis }<span class="op">;</span></span>
<span id="cb108-7"><a href="#cb108-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-8"><a href="#cb108-8" aria-hidden="true" tabindex="-1"></a>a<span class="op">.</span><span class="at">logThis</span> <span class="op">==</span> b<span class="op">.</span><span class="at">logThis</span><span class="op">;</span>  <span class="co">// true</span></span>
<span id="cb108-9"><a href="#cb108-9" aria-hidden="true" tabindex="-1"></a>a<span class="op">.</span><span class="fu">logThis</span>()<span class="op">;</span>             <span class="co">// a</span></span>
<span id="cb108-10"><a href="#cb108-10" aria-hidden="true" tabindex="-1"></a>b<span class="op">.</span><span class="fu">logThis</span>()<span class="op">;</span>             <span class="co">// b</span></span>
<span id="cb108-11"><a href="#cb108-11" aria-hidden="true" tabindex="-1"></a><span class="fu">logThis</span>()<span class="op">;</span>               <span class="co">// window / undefined</span></span></code></pre></div>
<p>Objekty (slovníky) <code>a</code> i <code>b</code> mají jen jednu
vlastnost (<code>"logThis"</code>), jejíž hodnotou je funkce. Jedná se
o tu samou funkci, kterou oba objekty sdílí. Hodnota <code>this</code>
je následně určena při volání.</p>
<p>Hlavní komplikace pak plynou ze situací z druhé kategorie, tj.
z případů, kdy je funkce předána jako callback. Její součástí (při
předání) není hodnota <code>this</code>, takže se pak můžeme dočkat
nepříjemných překvapení:</p>
<div class="sourceCode" id="cb109"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb109-1"><a href="#cb109-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="bu">Comment</span> {</span>
<span id="cb109-2"><a href="#cb109-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">constructor</span>(data) {</span>
<span id="cb109-3"><a href="#cb109-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">this</span><span class="op">.</span><span class="at">id</span> <span class="op">=</span> data<span class="op">.</span><span class="at">id</span><span class="op">;</span></span>
<span id="cb109-4"><a href="#cb109-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb109-5"><a href="#cb109-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> node <span class="op">=</span> <span class="bu">document</span><span class="op">.</span><span class="fu">createElement</span>(<span class="st">&quot;li&quot;</span>)<span class="op">;</span></span>
<span id="cb109-6"><a href="#cb109-6" aria-hidden="true" tabindex="-1"></a>    node<span class="op">.</span><span class="fu">addEventListener</span>(<span class="st">&quot;click&quot;</span><span class="op">,</span> <span class="kw">this</span><span class="op">.</span><span class="at">onClick</span>)<span class="op">;</span></span>
<span id="cb109-7"><a href="#cb109-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb109-8"><a href="#cb109-8" aria-hidden="true" tabindex="-1"></a>    <span class="pp">setTimeout</span>(<span class="kw">this</span><span class="op">.</span><span class="at">onTimeout</span><span class="op">,</span> <span class="dv">5000</span>)<span class="op">;</span></span>
<span id="cb109-9"><a href="#cb109-9" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb109-10"><a href="#cb109-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb109-11"><a href="#cb109-11" aria-hidden="true" tabindex="-1"></a>  <span class="fu">onClick</span>() { <span class="fu">alert</span>(<span class="kw">this</span><span class="op">.</span><span class="at">id</span>)<span class="op">;</span> }</span>
<span id="cb109-12"><a href="#cb109-12" aria-hidden="true" tabindex="-1"></a>  <span class="fu">onTimeout</span>() { <span class="fu">alert</span>(<span class="kw">this</span><span class="op">.</span><span class="at">id</span>)<span class="op">;</span> }</span>
<span id="cb109-13"><a href="#cb109-13" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>V ukázce výše nebude fungovat ani <code>onClick</code>, ani
<code>onTimeout</code>. Při kliknutí bude <code>this</code> rovno HTML
prvku <code>&lt;li&gt;</code>, za pět vteřin bude
<code>this == undefined</code>. Skutečnost, že callback není
s <code>this</code> žádným způsobem svázán, můžeme pochopit například
takovouto úvahou:</p>
<div class="sourceCode" id="cb110"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb110-1"><a href="#cb110-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="bu">Comment</span> {</span>
<span id="cb110-2"><a href="#cb110-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">constructor</span>(data) {</span>
<span id="cb110-3"><a href="#cb110-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">this</span><span class="op">.</span><span class="at">id</span> <span class="op">=</span> data<span class="op">.</span><span class="at">id</span><span class="op">;</span></span>
<span id="cb110-4"><a href="#cb110-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb110-5"><a href="#cb110-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> f <span class="op">=</span> <span class="kw">this</span><span class="op">.</span><span class="at">onTimeout</span><span class="op">;</span></span>
<span id="cb110-6"><a href="#cb110-6" aria-hidden="true" tabindex="-1"></a>    <span class="fu">f</span>()<span class="op">;</span>                  <span class="co">// this = undefined</span></span>
<span id="cb110-7"><a href="#cb110-7" aria-hidden="true" tabindex="-1"></a>    <span class="pp">setTimeout</span>(f<span class="op">,</span> <span class="dv">5000</span>)<span class="op">;</span>  <span class="co">// this = undefined</span></span>
<span id="cb110-8"><a href="#cb110-8" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb110-9"><a href="#cb110-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb110-10"><a href="#cb110-10" aria-hidden="true" tabindex="-1"></a>  <span class="fu">onTimeout</span>() { <span class="fu">alert</span>(<span class="kw">this</span><span class="op">.</span><span class="at">id</span>)<span class="op">;</span> }</span>
<span id="cb110-11"><a href="#cb110-11" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Typickým způsobem, jak předat hodnotu <code>this</code> zároveň
s callbackem, je vytvoření uzávěry. Můžeme to udělat buď ručně, nebo
pomocí arrow funkcí, jejichž specifické pravidlo s <code>this</code> je
pro nás užitečné:</p>
<div class="sourceCode" id="cb111"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb111-1"><a href="#cb111-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="bu">Comment</span> {</span>
<span id="cb111-2"><a href="#cb111-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">constructor</span>(data) {</span>
<span id="cb111-3"><a href="#cb111-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">this</span><span class="op">.</span><span class="at">id</span> <span class="op">=</span> id<span class="op">;</span></span>
<span id="cb111-4"><a href="#cb111-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb111-5"><a href="#cb111-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// varianta 1: vlastní uzávěra</span></span>
<span id="cb111-6"><a href="#cb111-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> that <span class="op">=</span> <span class="kw">this</span><span class="op">;</span></span>
<span id="cb111-7"><a href="#cb111-7" aria-hidden="true" tabindex="-1"></a>    <span class="pp">setTimeout</span>(<span class="kw">function</span>() { that<span class="op">.</span><span class="fu">onTimeout</span>()<span class="op">;</span> }<span class="op">,</span> <span class="dv">5000</span>)<span class="op">;</span></span>
<span id="cb111-8"><a href="#cb111-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb111-9"><a href="#cb111-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// varianta 2: arrow funkce nemají vlastní `this`</span></span>
<span id="cb111-10"><a href="#cb111-10" aria-hidden="true" tabindex="-1"></a>    <span class="pp">setTimeout</span>( () <span class="kw">=&gt;</span> <span class="kw">this</span><span class="op">.</span><span class="fu">onTimeout</span>()<span class="op">,</span> <span class="dv">5000</span> )<span class="op">;</span></span>
<span id="cb111-11"><a href="#cb111-11" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb111-12"><a href="#cb111-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb111-13"><a href="#cb111-13" aria-hidden="true" tabindex="-1"></a>  <span class="fu">onTimeout</span>() { <span class="fu">alert</span>(<span class="kw">this</span><span class="op">.</span><span class="at">id</span>)<span class="op">;</span> }</span>
<span id="cb111-14"><a href="#cb111-14" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<h2 id="profíci-prototypová-dědičnost">Profíci: prototypová
dědičnost</h2>
<p>Při objektově orientovaném programování modelujeme řešenou úlohu
pomocí <em>objektů</em> – entit, které spolu sdružují data a zároveň
funkce, jež s těmito daty pracují. Na příkladu třídy
<code>Comment</code> vidíme data uložená ve vlastnostech
<code>node</code> a <code>id</code>, zatímco metody (tedy funkce)
odpovídají například vlastnostem <code>approve</code> nebo
<code>buildDeleteButton</code>. K vytvoření objektu s vlastnostmi
a funkcemi ale třídy nepotřebujeme. Úplně nejjednodušeji bychom mohli
objekt vytvořit třeba takto:</p>
<div class="sourceCode" id="cb112"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb112-1"><a href="#cb112-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">createCommentObject</span>(data) {</span>
<span id="cb112-2"><a href="#cb112-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> node <span class="op">=</span> <span class="bu">document</span><span class="op">.</span><span class="fu">createElement</span>(<span class="st">&quot;li&quot;</span>)<span class="op">;</span></span>
<span id="cb112-3"><a href="#cb112-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb112-4"><a href="#cb112-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> obj <span class="op">=</span> {</span>
<span id="cb112-5"><a href="#cb112-5" aria-hidden="true" tabindex="-1"></a>    node<span class="op">,</span>  <span class="co">// zkrácený zápis, viz podkapitolu pro zelenáče</span></span>
<span id="cb112-6"><a href="#cb112-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">id</span><span class="op">:</span> data<span class="op">.</span><span class="at">id</span><span class="op">,</span></span>
<span id="cb112-7"><a href="#cb112-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb112-8"><a href="#cb112-8" aria-hidden="true" tabindex="-1"></a>    <span class="fu">approve</span>() {</span>
<span id="cb112-9"><a href="#cb112-9" aria-hidden="true" tabindex="-1"></a>      <span class="co">// ...</span></span>
<span id="cb112-10"><a href="#cb112-10" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb112-11"><a href="#cb112-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb112-12"><a href="#cb112-12" aria-hidden="true" tabindex="-1"></a>    <span class="fu">buildDeleteButton</span>() {</span>
<span id="cb112-13"><a href="#cb112-13" aria-hidden="true" tabindex="-1"></a>      <span class="co">// ...</span></span>
<span id="cb112-14"><a href="#cb112-14" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb112-15"><a href="#cb112-15" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb112-16"><a href="#cb112-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb112-17"><a href="#cb112-17" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> obj<span class="op">;</span></span>
<span id="cb112-18"><a href="#cb112-18" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Byli bychom s takovouto realizací objektově orientovaného
programování spokojeni? Máme zde proměnnou, která v sobě drží potřebná
data a zároveň s nimi dokáže pracovat pomocí metod. Moc dobrý objekt to
ale není. Naše hlavní výhrady jsou dvě:</p>
<ol type="1">
<li><p>Když budeme takových objektů vytvářet více (což chceme, neboť ze
serveru získáme data s mnoha komentáři), musíme pro každý znovu
definovat jeho metody. To je pracné a hlavně zbytečné, protože všechny
naše komentáře mají metody identické. Proto bychom raději, kdyby objekty
své metody sdílely.</p></li>
<li><p>Nemáme k dispozici žádný mechanismus <em>dědičnosti</em>, tj.
způsob, jak pomocí existujícího objektu vystavit nový s přidanou
funkcionalitou.</p></li>
</ol>
<p>V JavaScriptu se pro řešení obou výhrad historicky používá koncept,
který pochází z jazyka Self a říká se mu <strong>prototypová
dědičnost</strong>. Jeho podstata je triviální a lze ji shrnout do
krátké definice: <em>Nově vytvořenou proměnnou můžeme svázat
s existujícím objektem. Pokud v této proměnné přistoupíme k neexistující
vlastnosti, namísto hodnoty <code>undefined</code> se vrátí stejně
pojmenovaná vlastnost z provázaného objektu</em>. Znamená to, že tento
objekt představuje jakousi zálohu pro případ, že v odvozené proměnné
potřebná vlastnost schází. Na jednoduchém příkladu:</p>
<div class="sourceCode" id="cb113"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb113-1"><a href="#cb113-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> data1 <span class="op">=</span> {</span>
<span id="cb113-2"><a href="#cb113-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">name</span><span class="op">:</span> <span class="st">&quot;Jiří&quot;</span><span class="op">,</span></span>
<span id="cb113-3"><a href="#cb113-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">age</span><span class="op">:</span> <span class="dv">42</span></span>
<span id="cb113-4"><a href="#cb113-4" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb113-5"><a href="#cb113-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb113-6"><a href="#cb113-6" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> data2 <span class="op">=</span> <span class="bu">Object</span><span class="op">.</span><span class="fu">create</span>(data1)<span class="op">;</span></span>
<span id="cb113-7"><a href="#cb113-7" aria-hidden="true" tabindex="-1"></a>data2<span class="op">.</span><span class="at">name</span><span class="op">;</span>  <span class="co">// &quot;Jiří&quot;</span></span>
<span id="cb113-8"><a href="#cb113-8" aria-hidden="true" tabindex="-1"></a>data2<span class="op">.</span><span class="at">age</span><span class="op">;</span>   <span class="co">// 42</span></span>
<span id="cb113-9"><a href="#cb113-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb113-10"><a href="#cb113-10" aria-hidden="true" tabindex="-1"></a>data1<span class="op">.</span><span class="at">name</span> <span class="op">=</span> <span class="st">&quot;Eva&quot;</span><span class="op">;</span></span>
<span id="cb113-11"><a href="#cb113-11" aria-hidden="true" tabindex="-1"></a>data2<span class="op">.</span><span class="at">age</span> <span class="op">=</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb113-12"><a href="#cb113-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb113-13"><a href="#cb113-13" aria-hidden="true" tabindex="-1"></a>data2<span class="op">.</span><span class="at">age</span><span class="op">;</span>   <span class="co">// 10</span></span>
<span id="cb113-14"><a href="#cb113-14" aria-hidden="true" tabindex="-1"></a>data2<span class="op">.</span><span class="at">name</span><span class="op">;</span>  <span class="co">// &quot;Eva&quot;</span></span></code></pre></div>
<p>Funkce <code>Object.create</code> je zde klíčová. Pomocí ní můžeme
vytvořit zmiňovanou <em>prototypovou vazbu</em>, která říká, že
neexistující vlastnosti v <code>data2</code> budou dohledány
v <code>data1</code>. Pro úplnost dodejme, že objekt <code>data1</code>
označujeme jako <em>prototyp</em> objektu <code>data2</code>. Připomíná
jeho <em>šablonu</em> či <em>vzor</em>.</p>
<p>V ukázce výše si povšimněme těchto dvou míst:</p>
<ul>
<li><p>Objekt <code>data2</code> sice zprvu vlastnost <code>age</code>
nemá, ale jakmile mu ji nastavíme (zde na hodnotu <code>10</code>), tak
při dalším použití už se použije tato.</p></li>
<li><p>Objekt <code>data2</code> vznikl v době, kdy objekt
<code>data1</code> obsahoval jméno <code>Eva</code>. Objekt
<code>data1</code> jsme pak pozměnili a tato úprava se projevila zpětně
i v objektu <code>data2</code>. Je tedy vidět, že <code>data2</code>
není obyčejná kopie <code>data1</code>, ale že jsou spolu skutečně
provázány.</p></li>
</ul>
<p>Využijeme toto chování k vylepšení našich komentářů, zatím stále bez
tříd:</p>
<div class="sourceCode" id="cb114"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb114-1"><a href="#cb114-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> commentPrototype <span class="op">=</span> {</span>
<span id="cb114-2"><a href="#cb114-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">approve</span>() {</span>
<span id="cb114-3"><a href="#cb114-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span>
<span id="cb114-4"><a href="#cb114-4" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb114-5"><a href="#cb114-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-6"><a href="#cb114-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">buildDeleteButton</span>() {</span>
<span id="cb114-7"><a href="#cb114-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span>
<span id="cb114-8"><a href="#cb114-8" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb114-9"><a href="#cb114-9" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb114-10"><a href="#cb114-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-11"><a href="#cb114-11" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">createCommentObject</span>(data) {</span>
<span id="cb114-12"><a href="#cb114-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> node <span class="op">=</span> <span class="bu">document</span><span class="op">.</span><span class="fu">createElement</span>(<span class="st">&quot;li&quot;</span>)<span class="op">;</span></span>
<span id="cb114-13"><a href="#cb114-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> obj <span class="op">=</span> <span class="bu">Object</span><span class="op">.</span><span class="fu">create</span>(commentPrototype)<span class="op">;</span></span>
<span id="cb114-14"><a href="#cb114-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-15"><a href="#cb114-15" aria-hidden="true" tabindex="-1"></a>  obj<span class="op">.</span><span class="at">node</span> <span class="op">=</span> node<span class="op">;</span></span>
<span id="cb114-16"><a href="#cb114-16" aria-hidden="true" tabindex="-1"></a>  obj<span class="op">.</span><span class="at">id</span> <span class="op">=</span> data<span class="op">.</span><span class="at">id</span><span class="op">;</span></span>
<span id="cb114-17"><a href="#cb114-17" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> obj<span class="op">;</span></span>
<span id="cb114-18"><a href="#cb114-18" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Metody objektu komentáře jsou nyní obsaženy v proměnné
<code>commentPrototype</code>, a jsou tedy definovány jen jednou
(a prostřednictvím prototypové dědičnosti sdíleny všemi objekty, které
vrátí funkce <code>createCommentObject</code>). Zároveň jsme otevřeli
dveře ke zmíněné implementaci dědičnosti. Pokud chceme vytvořit
rozšířený komentář, připravíme si nejprve jeho prototypový objekt a do
něj vložíme rozšířenou funkcionalitu (zde například metoda pro kontrolu
pravopisu):</p>
<div class="sourceCode" id="cb115"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb115-1"><a href="#cb115-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> betterCommentPrototype <span class="op">=</span> <span class="bu">Object</span><span class="op">.</span><span class="fu">create</span>(commentPrototype)<span class="op">;</span></span>
<span id="cb115-2"><a href="#cb115-2" aria-hidden="true" tabindex="-1"></a>betterCommentPrototype<span class="op">.</span><span class="at">checkSpelling</span> <span class="op">=</span> <span class="kw">function</span>() {</span>
<span id="cb115-3"><a href="#cb115-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ...</span></span>
<span id="cb115-4"><a href="#cb115-4" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb115-5"><a href="#cb115-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb115-6"><a href="#cb115-6" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">createBetterCommentObject</span>(data) {</span>
<span id="cb115-7"><a href="#cb115-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> node <span class="op">=</span> <span class="bu">document</span><span class="op">.</span><span class="fu">createElement</span>(<span class="st">&quot;li&quot;</span>)<span class="op">;</span></span>
<span id="cb115-8"><a href="#cb115-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> betterObj <span class="op">=</span> <span class="bu">Object</span><span class="op">.</span><span class="fu">create</span>(betterCommentPrototype)<span class="op">;</span></span>
<span id="cb115-9"><a href="#cb115-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb115-10"><a href="#cb115-10" aria-hidden="true" tabindex="-1"></a>  betterObj<span class="op">.</span><span class="at">node</span> <span class="op">=</span> node<span class="op">;</span></span>
<span id="cb115-11"><a href="#cb115-11" aria-hidden="true" tabindex="-1"></a>  betterObj<span class="op">.</span><span class="at">id</span> <span class="op">=</span> data<span class="op">.</span><span class="at">id</span><span class="op">;</span></span>
<span id="cb115-12"><a href="#cb115-12" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> betterObj<span class="op">;</span></span>
<span id="cb115-13"><a href="#cb115-13" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<figure>
<img src="../img/proto1.svg"
alt="Dědičnost pomocí prototypové vazby (čárkovaně)" />
<figcaption aria-hidden="true">Dědičnost pomocí prototypové vazby
(čárkovaně)</figcaption>
</figure>
<p>Všimněme si, že takto vylepšený komentář nabízí kontrolu pravopisu,
ale zároveň i všechny metody běžného komentáře. To proto, že jeho
neexistující vlastnost (třeba <code>approve</code>) je nejprve neúspěšně
hledána v <code>betterCommentPrototype</code>, kde neexistuje, a proto
je dále hledána v prototypu tohoto objektu (a úspěšně nalezena
v <code>commentPrototype</code>). Vytvořili jsme dvě prototypové vazby
za sebou, tzv. <em>prototype chain</em>.</p>
<p>S takovým objektově orientovaným přístupem ovšem ještě nejsme zcela
spokojeni. Poslední věc k vyřešení je otázka konstrukce objektů. V této
fázi průzkumu prototypové dědičnosti nové objekty vytváříme pomocí
speciální (tzv. <em>tovární</em>) funkce. V příkladu uvedeném výše jsou
přítomny dvě, <code>createCommentObject</code>
a <code>createBetterCommentObject</code>. Nevýhodou je, že z takové
funkce prostým pohledem nepoznáme, jaký má její volání vliv na prototyp
výsledného objektu. Také je trochu nešikovné, že obě dvě vzorové tovární
funkce dělají skoro to samé – tedy že
v <code>createBetterCommentObject</code> nemůžeme zavolat
<code>createCommentObject</code>. Proto si představíme poslední součást
systému prototypové dědičnosti – klíčové slovo <code>new</code>.</p>
<p>Zápisem <code>new X()</code> dojde ke třem hlavním krokům:</p>
<ol type="1">
<li><p>vznikne nový objekt</p></li>
<li><p>tento objekt má prototypovou vazbu vedoucí do
<code>X.prototype</code></p></li>
<li><p>funkce <code>X</code> je zavolána s <code>this</code> nastaveným
na nově vzniklý objekt</p></li>
</ol>
<p>Vlastnost <code>prototype</code> je specifická pro JavaScriptové
funkce (každá funkce ji má definovanou ve chvíli svého vzniku). Slouží
k jedinému účelu: kdyby se někdo pokusil funkci vykonat pomocí operátoru
<code>new</code> (tehdy by se použila jako prototypový vzor, viz popis
výše). Funkce, které vytváříme za tímto účelem, často pojmenováváme
s prvním velkým písmenem a říkáme jim <strong>konstruktory</strong>.
Tímto způsobem teď můžeme vylepšit existující prototypový kód:</p>
<div class="sourceCode" id="cb116"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb116-1"><a href="#cb116-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">Comment</span>(data) {</span>
<span id="cb116-2"><a href="#cb116-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> node <span class="op">=</span> <span class="bu">document</span><span class="op">.</span><span class="fu">createElement</span>(<span class="st">&quot;li&quot;</span>)<span class="op">;</span></span>
<span id="cb116-3"><a href="#cb116-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">this</span><span class="op">.</span><span class="at">node</span> <span class="op">=</span> node<span class="op">;</span></span>
<span id="cb116-4"><a href="#cb116-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">this</span><span class="op">.</span><span class="at">id</span> <span class="op">=</span> data<span class="op">.</span><span class="at">id</span><span class="op">;</span></span>
<span id="cb116-5"><a href="#cb116-5" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb116-6"><a href="#cb116-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb116-7"><a href="#cb116-7" aria-hidden="true" tabindex="-1"></a><span class="bu">Comment</span><span class="op">.</span><span class="at">prototype</span><span class="op">.</span><span class="at">approve</span> <span class="op">=</span> <span class="kw">function</span>() {</span>
<span id="cb116-8"><a href="#cb116-8" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ...</span></span>
<span id="cb116-9"><a href="#cb116-9" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb116-10"><a href="#cb116-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb116-11"><a href="#cb116-11" aria-hidden="true" tabindex="-1"></a><span class="bu">Comment</span><span class="op">.</span><span class="at">prototype</span><span class="op">.</span><span class="at">buildDeleteButton</span> <span class="op">=</span> <span class="kw">function</span>() {</span>
<span id="cb116-12"><a href="#cb116-12" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ...</span></span>
<span id="cb116-13"><a href="#cb116-13" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb116-14"><a href="#cb116-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb116-15"><a href="#cb116-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb116-16"><a href="#cb116-16" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">BetterComment</span>(data) {</span>
<span id="cb116-17"><a href="#cb116-17" aria-hidden="true" tabindex="-1"></a>  <span class="bu">Comment</span><span class="op">.</span><span class="fu">call</span>(<span class="kw">this</span><span class="op">,</span> data)<span class="op">;</span></span>
<span id="cb116-18"><a href="#cb116-18" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb116-19"><a href="#cb116-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb116-20"><a href="#cb116-20" aria-hidden="true" tabindex="-1"></a>BetterComment<span class="op">.</span><span class="at">prototype</span> <span class="op">=</span> <span class="bu">Object</span><span class="op">.</span><span class="fu">create</span>(<span class="bu">Comment</span><span class="op">.</span><span class="at">prototype</span>)<span class="op">;</span></span>
<span id="cb116-21"><a href="#cb116-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb116-22"><a href="#cb116-22" aria-hidden="true" tabindex="-1"></a>BetterComment<span class="op">.</span><span class="at">prototype</span><span class="op">.</span><span class="at">checkSpelling</span> <span class="op">=</span> <span class="kw">function</span>() {</span>
<span id="cb116-23"><a href="#cb116-23" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ...</span></span>
<span id="cb116-24"><a href="#cb116-24" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb116-25"><a href="#cb116-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb116-26"><a href="#cb116-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb116-27"><a href="#cb116-27" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> betterComment <span class="op">=</span> <span class="kw">new</span> <span class="fu">BetterComment</span>(data)<span class="op">;</span></span></code></pre></div>
<figure>
<img src="../img/proto2.svg"
alt="Prototypová vazba vs. vlastnost prototype" />
<figcaption aria-hidden="true">Prototypová vazba vs. vlastnost
prototype</figcaption>
</figure>
<p>Na obrázku vidíme prototypovou dědičnost v plné parádě. Zápis
<code>Comment.call</code> v konstruktoru <code>BetterComment</code> je
nezbytný, protože tím funkci <code>Comment</code> nastavujeme správně
hodnotu <code>this</code> (kdybychom napsali jen
<code>Comment(data)</code>, hodnota <code>this</code> by byla
<code>undefined</code>).</p>
<p>V moderním JavaScriptovém kódu se ovšem s takovouto definicí objektů
a konstruktorů nesetkáme. Ukázalo se, že jejich syntaxe a fungování jsou
pro vývojáře často matoucí. Proto se od roku 2015 objevila možnost
zápisu tříd klíčovým slovem <code>class</code> s funkcionalitou, která
je shodná s prototypovou dědičností. To proto, že třídy reprezentují ten
samý mechanismus prototypové dědičnosti, jen pro ni používají jinou
syntaxi. Skutečně, naše třída <code>Comment</code> z vzorového řešení
obsahuje vlastnost <code>prototype</code> a v ní jsou umístěny všechny
metody, které jsme definovali uvnitř bloku <code>class Comment</code>.
Akorát jsme k tomu nepotřebovali zdlouhavý a hůře pochopitelný zápis
<code>Comment.prototype.x = ...</code>.</p>
<p>Získané vědomosti o prototypové dědičnosti se nám nicméně mohou
hodit, i když pro definici objektů upřednostníme třídy. Vzpomeňme si na
to, že díky prototypové vazbě můžeme měnit (či vylepšovat) chování
objektů i poté, co byly vytvořeny – tím, že měníme obsah jejich
prototypu. To platí nejen pro naše vlastní objekty, ale i pro běžné
datové typy. Každý řetězec je totiž instancí funkce <code>String</code>
(tj. má prototypovou vazbu do <code>String.prototype</code>), stejně tak
každé pole je instancí funkce <code>Array</code>. To nám dovoluje
obohacovat chování těchto datových typů. Představme si například, že
bychom chtěli mít možnost výběru náhodného prvku z pole. V JavaScriptu
je ovšem jen funkce <code>Math.random()</code>, která vrací desetinné
číslo větší nebo rovno nule a menší než jedna. To je dobrý základ:</p>
<div class="sourceCode" id="cb117"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb117-1"><a href="#cb117-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> jmena <span class="op">=</span> [<span class="st">&quot;Jiří&quot;</span><span class="op">,</span> <span class="st">&quot;Eva&quot;</span><span class="op">,</span> <span class="st">&quot;Petr&quot;</span><span class="op">,</span> <span class="st">&quot;Marie&quot;</span>]<span class="op">;</span></span>
<span id="cb117-2"><a href="#cb117-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb117-3"><a href="#cb117-3" aria-hidden="true" tabindex="-1"></a><span class="bu">Array</span><span class="op">.</span><span class="at">prototype</span><span class="op">.</span><span class="at">random</span> <span class="op">=</span> <span class="kw">function</span>() {</span>
<span id="cb117-4"><a href="#cb117-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> index <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">floor</span>(<span class="bu">Math</span><span class="op">.</span><span class="fu">random</span>() <span class="op">*</span> <span class="kw">this</span><span class="op">.</span><span class="at">length</span>)<span class="op">;</span></span>
<span id="cb117-5"><a href="#cb117-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="kw">this</span>[index]<span class="op">;</span></span>
<span id="cb117-6"><a href="#cb117-6" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb117-7"><a href="#cb117-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb117-8"><a href="#cb117-8" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> jmeno <span class="op">=</span> jmena<span class="op">.</span><span class="fu">random</span>()<span class="op">;</span>  <span class="co">// ?</span></span></code></pre></div>
<p>Přidáním do objektu <code>Array.prototype</code> jsme každé pole
<em>naučili</em> novému chování. Jen pozor – takovou úpravou vestavěných
objektů se vystavujeme riziku kolize. Mohlo by se stát, že v budoucnu
v rámci rozšiřování jazyka vznikne oficiální metoda <code>random</code>,
která by se od té naší mohla lišit. Na druhou stranu je ale vylepšování
existujících prototypů skvělým způsobem, jak naše proměnné naučit
standardizovanou funkcionalitu, která je příliš nová a v prohlížeči
ještě neimplementovaná. Více si o tom povíme v desáté kapitole.</p>
<h1 id="web-components">Web Components</h1>
<h2 id="úloha-7">Úloha</h2>
<p>V šesté kapitole jsme vytvořili single-page aplikaci, která zobrazuje
výsledky hledání bez opakovaného načítání stránky. Upravte tento kód
opět dle pravidel objektově orientovaného programování, ale tentokrát
pomocí konceptu Web Components.</p>
<h3 id="řešení-7">Řešení</h3>
<p>Označení Web Components používáme tam, kde se rozhodneme naše třídy
definovat jako potomky existujících HTML značek. Znamená to, že takto
dokážeme vytvářet vlastní HTML značky, kterým pomocí JavaScriptu dodáme
specifickou funkcionalitu (a pomocí CSS specifický vzhled). Myšlenka Web
Components je značně obsáhlá a vydala by na samostatnou knihu; vzorové
řešení této kapitoly je pro nás proto jen drobnou ochutnávkou této
techniky.</p>
<p>HTML, které potřebujeme vytvořit, sestává ze tří částí: hledacího
formuláře, prostoru pro výsledky a jednotlivých položek nalezených
písní. My zkusíme vytvořit vlastní HTML značku pro formulář (ta bude
obsahovat logiku související s HTTP požadavky) a dále pro každý výsledek
hledání.</p>
<div class="sourceCode" id="cb118"><pre
class="sourceCode html"><code class="sourceCode html"><span id="cb118-1"><a href="#cb118-1" aria-hidden="true" tabindex="-1"></a><span class="co">&lt;!-- kapitola-9.html --&gt;</span></span>
<span id="cb118-2"><a href="#cb118-2" aria-hidden="true" tabindex="-1"></a><span class="dt">&lt;</span><span class="kw">link</span> <span class="er">rel</span><span class="ot">=</span><span class="st">&quot;stylesheet&quot;</span> <span class="er">href</span><span class="ot">=</span><span class="st">&quot;song-result.css&quot;</span> <span class="dt">/&gt;</span></span>
<span id="cb118-3"><a href="#cb118-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb118-4"><a href="#cb118-4" aria-hidden="true" tabindex="-1"></a><span class="dt">&lt;</span><span class="kw">h1</span><span class="dt">&gt;</span>Hledání<span class="dt">&lt;/</span><span class="kw">h1</span><span class="dt">&gt;</span></span>
<span id="cb118-5"><a href="#cb118-5" aria-hidden="true" tabindex="-1"></a><span class="dt">&lt;</span><span class="kw">song-search</span><span class="dt">&gt;&lt;/</span><span class="kw">song-search</span><span class="dt">&gt;</span></span>
<span id="cb118-6"><a href="#cb118-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb118-7"><a href="#cb118-7" aria-hidden="true" tabindex="-1"></a><span class="dt">&lt;</span><span class="kw">script</span> <span class="er">src</span><span class="ot">=</span><span class="st">&quot;song-search.js&quot;</span><span class="dt">&gt;&lt;/</span><span class="kw">script</span><span class="dt">&gt;</span></span>
<span id="cb118-8"><a href="#cb118-8" aria-hidden="true" tabindex="-1"></a><span class="dt">&lt;</span><span class="kw">script</span> <span class="er">src</span><span class="ot">=</span><span class="st">&quot;song-result.js&quot;</span><span class="dt">&gt;&lt;/</span><span class="kw">script</span><span class="dt">&gt;</span></span></code></pre></div>
<div class="sourceCode" id="cb119"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb119-1"><a href="#cb119-1" aria-hidden="true" tabindex="-1"></a><span class="co">// song-search.js</span></span>
<span id="cb119-2"><a href="#cb119-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> SongSearch <span class="kw">extends</span> <span class="bu">HTMLElement</span> {</span>
<span id="cb119-3"><a href="#cb119-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">connectedCallback</span>() {</span>
<span id="cb119-4"><a href="#cb119-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">this</span><span class="op">.</span><span class="at">innerHTML</span> <span class="op">=</span> HTML<span class="op">;</span></span>
<span id="cb119-5"><a href="#cb119-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">this</span><span class="op">.</span><span class="fu">querySelector</span>(<span class="st">&quot;form&quot;</span>)<span class="op">.</span><span class="fu">addEventListener</span>(<span class="st">&quot;submit&quot;</span><span class="op">,</span> <span class="kw">this</span>)<span class="op">;</span></span>
<span id="cb119-6"><a href="#cb119-6" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb119-7"><a href="#cb119-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb119-8"><a href="#cb119-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">async</span> <span class="fu">handleEvent</span>(e) {</span>
<span id="cb119-9"><a href="#cb119-9" aria-hidden="true" tabindex="-1"></a>    e<span class="op">.</span><span class="fu">preventDefault</span>()<span class="op">;</span></span>
<span id="cb119-10"><a href="#cb119-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> query <span class="op">=</span> <span class="kw">this</span><span class="op">.</span><span class="fu">querySelector</span>(<span class="st">&quot;[name=query]&quot;</span>)<span class="op">.</span><span class="at">value</span><span class="op">;</span></span>
<span id="cb119-11"><a href="#cb119-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> url <span class="op">=</span> <span class="vs">`/search?query=</span><span class="sc">${</span><span class="pp">encodeURIComponent</span>(query)<span class="sc">}</span><span class="vs">`</span><span class="op">;</span></span>
<span id="cb119-12"><a href="#cb119-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> response <span class="op">=</span> <span class="cf">await</span> <span class="fu">fetch</span>(url)<span class="op">;</span></span>
<span id="cb119-13"><a href="#cb119-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> songs <span class="op">=</span> <span class="cf">await</span> response<span class="op">.</span><span class="fu">json</span>()<span class="op">;</span></span>
<span id="cb119-14"><a href="#cb119-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">this</span><span class="op">.</span><span class="fu">showResults</span>(songs<span class="op">,</span> query)<span class="op">;</span></span>
<span id="cb119-15"><a href="#cb119-15" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb119-16"><a href="#cb119-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb119-17"><a href="#cb119-17" aria-hidden="true" tabindex="-1"></a>  <span class="fu">showResults</span>(songs<span class="op">,</span> query) {</span>
<span id="cb119-18"><a href="#cb119-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> parent <span class="op">=</span> <span class="kw">this</span><span class="op">.</span><span class="fu">querySelector</span>(<span class="st">&quot;.results&quot;</span>)<span class="op">;</span></span>
<span id="cb119-19"><a href="#cb119-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (songs<span class="op">.</span><span class="at">length</span> <span class="op">==</span> <span class="dv">0</span>) {</span>
<span id="cb119-20"><a href="#cb119-20" aria-hidden="true" tabindex="-1"></a>      parent<span class="op">.</span><span class="fu">replaceChildren</span>(<span class="st">&quot;Dotazu nevyhovují žádné písně 🙁&quot;</span>)<span class="op">;</span></span>
<span id="cb119-21"><a href="#cb119-21" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span><span class="op">;</span></span>
<span id="cb119-22"><a href="#cb119-22" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb119-23"><a href="#cb119-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb119-24"><a href="#cb119-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> heading <span class="op">=</span> <span class="bu">document</span><span class="op">.</span><span class="fu">createElement</span>(<span class="st">&quot;h2&quot;</span>)<span class="op">;</span></span>
<span id="cb119-25"><a href="#cb119-25" aria-hidden="true" tabindex="-1"></a>    heading<span class="op">.</span><span class="at">textContent</span> <span class="op">=</span> <span class="vs">`Nalezené písně pro dotaz: </span><span class="sc">${</span>query<span class="sc">}</span><span class="vs">`</span><span class="op">;</span></span>
<span id="cb119-26"><a href="#cb119-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb119-27"><a href="#cb119-27" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> ol <span class="op">=</span> <span class="bu">document</span><span class="op">.</span><span class="fu">createElement</span>(<span class="st">&quot;ol&quot;</span>)<span class="op">;</span></span>
<span id="cb119-28"><a href="#cb119-28" aria-hidden="true" tabindex="-1"></a>    parent<span class="op">.</span><span class="fu">replaceChildren</span>(heading<span class="op">,</span> ol)<span class="op">;</span></span>
<span id="cb119-29"><a href="#cb119-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb119-30"><a href="#cb119-30" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> results <span class="op">=</span> songs<span class="op">.</span><span class="fu">map</span>(item <span class="kw">=&gt;</span> {</span>
<span id="cb119-31"><a href="#cb119-31" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> result <span class="op">=</span> <span class="bu">document</span><span class="op">.</span><span class="fu">createElement</span>(<span class="st">&quot;song-result&quot;</span>)<span class="op">;</span></span>
<span id="cb119-32"><a href="#cb119-32" aria-hidden="true" tabindex="-1"></a>      result<span class="op">.</span><span class="fu">setData</span>(item)<span class="op">;</span></span>
<span id="cb119-33"><a href="#cb119-33" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> result<span class="op">;</span></span>
<span id="cb119-34"><a href="#cb119-34" aria-hidden="true" tabindex="-1"></a>    })<span class="op">;</span></span>
<span id="cb119-35"><a href="#cb119-35" aria-hidden="true" tabindex="-1"></a>    ol<span class="op">.</span><span class="fu">replaceChildren</span>(<span class="op">...</span>results)<span class="op">;</span></span>
<span id="cb119-36"><a href="#cb119-36" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb119-37"><a href="#cb119-37" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb119-38"><a href="#cb119-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb119-39"><a href="#cb119-39" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> HTML <span class="op">=</span> <span class="vs">`&lt;form&gt;</span></span>
<span id="cb119-40"><a href="#cb119-40" aria-hidden="true" tabindex="-1"></a><span class="vs">  &lt;label&gt;</span></span>
<span id="cb119-41"><a href="#cb119-41" aria-hidden="true" tabindex="-1"></a><span class="vs">    Hledaný výraz: &lt;input type=&quot;text&quot; name=&quot;query&quot; /&gt;</span></span>
<span id="cb119-42"><a href="#cb119-42" aria-hidden="true" tabindex="-1"></a><span class="vs">  &lt;/label&gt;</span></span>
<span id="cb119-43"><a href="#cb119-43" aria-hidden="true" tabindex="-1"></a><span class="vs">  &lt;label&gt;&lt;button&gt;🔎&lt;/button&gt;&lt;/label&gt;</span></span>
<span id="cb119-44"><a href="#cb119-44" aria-hidden="true" tabindex="-1"></a><span class="vs">&lt;/form&gt;</span></span>
<span id="cb119-45"><a href="#cb119-45" aria-hidden="true" tabindex="-1"></a><span class="vs">&lt;div class=&quot;results&quot;&gt;&lt;/div&gt;`</span><span class="op">;</span></span>
<span id="cb119-46"><a href="#cb119-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb119-47"><a href="#cb119-47" aria-hidden="true" tabindex="-1"></a>customElements<span class="op">.</span><span class="fu">define</span>(<span class="st">&quot;song-search&quot;</span><span class="op">,</span> SongSearch)<span class="op">;</span></span></code></pre></div>
<div class="sourceCode" id="cb120"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb120-1"><a href="#cb120-1" aria-hidden="true" tabindex="-1"></a><span class="co">// song-result.js</span></span>
<span id="cb120-2"><a href="#cb120-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> SongResult <span class="kw">extends</span> <span class="bu">HTMLElement</span> {</span>
<span id="cb120-3"><a href="#cb120-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">setData</span>(song) {</span>
<span id="cb120-4"><a href="#cb120-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">this</span><span class="op">.</span><span class="at">innerHTML</span> <span class="op">=</span> <span class="vs">`</span></span>
<span id="cb120-5"><a href="#cb120-5" aria-hidden="true" tabindex="-1"></a><span class="vs">      &lt;a href=&quot;</span><span class="sc">${</span>song<span class="op">.</span><span class="at">url</span><span class="sc">}</span><span class="vs">&quot;&gt;</span><span class="sc">${</span>song<span class="op">.</span><span class="at">title</span><span class="sc">}</span><span class="vs">&lt;/a&gt;</span></span>
<span id="cb120-6"><a href="#cb120-6" aria-hidden="true" tabindex="-1"></a><span class="vs">      &lt;br/&gt; </span><span class="sc">${</span>song<span class="op">.</span><span class="at">text</span><span class="sc">}</span></span>
<span id="cb120-7"><a href="#cb120-7" aria-hidden="true" tabindex="-1"></a><span class="vs">    `</span><span class="op">;</span></span>
<span id="cb120-8"><a href="#cb120-8" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb120-9"><a href="#cb120-9" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb120-10"><a href="#cb120-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb120-11"><a href="#cb120-11" aria-hidden="true" tabindex="-1"></a>customElements<span class="op">.</span><span class="fu">define</span>(<span class="st">&quot;song-result&quot;</span><span class="op">,</span> SongResult)<span class="op">;</span></span></code></pre></div>
<div class="sourceCode" id="cb121"><pre
class="sourceCode css"><code class="sourceCode css"><span id="cb121-1"><a href="#cb121-1" aria-hidden="true" tabindex="-1"></a><span class="co">/* song-result.css */</span></span>
<span id="cb121-2"><a href="#cb121-2" aria-hidden="true" tabindex="-1"></a>song-result {</span>
<span id="cb121-3"><a href="#cb121-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">display</span>: <span class="dv">list-item</span><span class="op">;</span></span>
<span id="cb121-4"><a href="#cb121-4" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Definice vlastních HTML značek se příliš neliší od běžných tříd, se
kterými jsme se seznámili v předchozí kapitole. Aby se s naší třídou
dalo pracovat jako s HTML značkou, musíme vykonat tyto dva povinné
kroky:</p>
<ol type="1">
<li><p>Definovat svou třídu jako potomka některé HTML značky. Typicky
toho docílíme zápisem <code>extends HTMLElement</code>, tedy děděním
z obecné HTML značky.</p></li>
<li><p>Zaregistrovat vzniklou třídu jako definici pro HTML parser.
V tomto kroku také dodáme název HTML značky, kterou chceme používat.
K tomu slouží globální objekt <code>customElements</code> a jeho metoda
<code>define</code>, pomocí které spárujeme třídu a název. Za zmínku
stojí, že v názvu musí být obsažena pomlčka. To garantuje tzv.
<em>dopřednou kompatibilitu</em>: protože standardní HTML značky ve svém
názvu nikdy pomlčku neobsahují, nestane se v budoucnu, že by došlo ke
vzniku nového HTML prvku, který by názvem kolidoval s tím naším
vlastním.</p></li>
</ol>
<p>Třída <code>SongResult</code> je malinká a dovede jedinou věc:
převést data jednoho výsledku hledání na HTML. K této nové HTML značce
rovnou dodáme také definici stylu, ve které zápisem
<code>display: list-item</code> zařídíme, aby se naše
<code>&lt;song-result&gt;</code> korektně zobrazila jako položka
seznamu. To proto, že ji máme v plánu umístit do odrážkového seznamu
vytvořeného v <code>&lt;song-search&gt;</code>.</p>
<p>Optikou objektově orientovaného programování je nezvyklé, že potřebná
data nepředáváme konstruktoru třídy <code>SongResult</code> a namísto
toho tak činíme pomocí metody <code>setData</code>. Důvod je ten, že
tvorba instancí <code>SongResult</code> probíhá zápisem
<code>document.createElement("song-result")</code> uvnitř třídy
<code>SongSearch</code>, při kterém nelze žádná data předávat.</p>
<p>Tím se dostáváme k objemnější komponentě
<code>&lt;song-search&gt;</code>. Většina její implementace je převzata
z šesté kapitoly a neobsahuje nic nového. Ani zde nevidíme konstruktor;
namísto toho jsme inicializaci (tvorbu formuláře a přidání posluchače)
odložili do metody <code>connectedCallback</code>. Ta patří k několika
tzv. <em>lifecycle callbackům</em>; funkcím, které volá prohlížeč, když
HTML prvek vkládá do stromu stránky, mění jeho atributy či jej odebírá.
Je dobrým zvykem vlastní HTML značky takto inicializovat právě
v okamžiku jejich připnutí do dokumentu.</p>
<p>Výsledné HTML je pak triviální a hezky ukazuje, jak jsme
funkcionalitu hledacího formuláře skryli, resp. zapouzdřili do
implementace komponenty <code>SongSearch</code>.</p>
<p>Děděním z třídy <code>HTMLElement</code> jsme získali praktické
schopnosti rozhraní DOM (<code>this.innerHTML</code>,
<code>this.querySelector</code>). Taktéž jsme získali možnost na naší
vlastní značce poslouchat a zejména vytvářet vlastní události – více si
o tom povíme v podkapitole pro profíky.</p>
<h3 id="co-jsme-se-naučili-6">Co jsme se naučili</h3>
<p>Po vyřešení osmé úlohy by měl čtenář chápat a ovládat:</p>
<ul>
<li><p>definici vlastní HTML značky rozšířením třídy
<code>HTMLElement</code></p></li>
<li><p>registraci názvu vlastní HTML značky</p></li>
</ul>
<h2 id="zelenáči-gettery-a-settery">Zelenáči: gettery a settery</h2>
<p>Třída <code>SongResult</code> pro své fungování potřebuje data, která
jí předáváme dedikovanou metodou <code>setData</code> (a nikoliv
v konstruktoru, protože ten je zpravidla volán bez parametrů). Při
objektově orientovaném programování se často setkáváme s podobnými
metodami, jejichž účelem je poskytovat či nastavovat data, se kterými
objekt pracuje. Vhodné pojmenování v češtině nenalezneme, takže jim
říkáme anglicky <strong>gettery</strong> a <strong>settery</strong>.
V JavaScriptu existuje speciální syntaxe, pomocí které můžeme pro každou
vlastnost ve třídě (či obecném objektu) nadefinovat její vlastní getter
a setter – funkci volanou při čtení a zápisu hodnoty dané
vlastnosti.</p>
<p>Naši metodu <code>setData</code> bychom mohli převést na setter
takto:</p>
<div class="sourceCode" id="cb122"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb122-1"><a href="#cb122-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> SongResult <span class="kw">extends</span> <span class="bu">HTMLElement</span> {</span>
<span id="cb122-2"><a href="#cb122-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">set</span> <span class="fu">data</span>(song) {</span>
<span id="cb122-3"><a href="#cb122-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">this</span><span class="op">.</span><span class="at">innerHTML</span> <span class="op">=</span> <span class="vs">`</span></span>
<span id="cb122-4"><a href="#cb122-4" aria-hidden="true" tabindex="-1"></a><span class="vs">      &lt;a href=&quot;</span><span class="sc">${</span>song<span class="op">.</span><span class="at">url</span><span class="sc">}</span><span class="vs">&quot;&gt;</span><span class="sc">${</span>song<span class="op">.</span><span class="at">title</span><span class="sc">}</span><span class="vs">&lt;/a&gt;</span></span>
<span id="cb122-5"><a href="#cb122-5" aria-hidden="true" tabindex="-1"></a><span class="vs">      &lt;br/&gt; </span><span class="sc">${</span>song<span class="op">.</span><span class="at">text</span><span class="sc">}</span></span>
<span id="cb122-6"><a href="#cb122-6" aria-hidden="true" tabindex="-1"></a><span class="vs">    `</span><span class="op">;</span></span>
<span id="cb122-7"><a href="#cb122-7" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb122-8"><a href="#cb122-8" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Všimněme si klíčového slova <code>set</code> uvedeného před samotnou
metodou. Jeho přítomnost říká, že tato metoda bude volána při každém
přiřazení do vlastnosti <code>data</code>. S vzniklým HTML prvkem pak
budeme pracovat následovně:</p>
<div class="sourceCode" id="cb123"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb123-1"><a href="#cb123-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> songResult <span class="op">=</span> <span class="bu">document</span><span class="op">.</span><span class="fu">createElement</span>(<span class="st">&quot;song-result&quot;</span>)<span class="op">;</span></span>
<span id="cb123-2"><a href="#cb123-2" aria-hidden="true" tabindex="-1"></a>songResult<span class="op">.</span><span class="at">data</span> <span class="op">=</span> data<span class="op">;</span>  <span class="co">// z odpovědi HTTP požadavku</span></span></code></pre></div>
<p>Při čtení výše uvedeného kódu není na první pohled patrné, že pouhým
přiřazením vykonáme nějakou logiku. To je cílem setterů: skrýt před
okolním světem skutečnost, že nastavení vlastnosti <code>data</code>
způsobí další kroky, jako např. vykreslení dalšího HTML ve stránce.</p>
<p>Symetricky je možné definovat i getter. Bývá to obvyklé, i když
nikoliv nezbytné. Naše třída <code>SongResult</code> ve své současné
podobě getter pro vlastnost <code>data</code> mít ani nemůže, neboť si
získaná data nepamatuje (a proto je nemůže vrátit). Museli bychom ji to
naučit takto:</p>
<div class="sourceCode" id="cb124"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb124-1"><a href="#cb124-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> SongResult <span class="kw">extends</span> <span class="bu">HTMLElement</span> {</span>
<span id="cb124-2"><a href="#cb124-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">get</span> <span class="fu">data</span>() { <span class="cf">return</span> <span class="kw">this</span><span class="op">.</span><span class="at">_song</span><span class="op">;</span> }</span>
<span id="cb124-3"><a href="#cb124-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb124-4"><a href="#cb124-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">set</span> <span class="fu">data</span>(song) {</span>
<span id="cb124-5"><a href="#cb124-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">this</span><span class="op">.</span><span class="at">_song</span> <span class="op">=</span> song<span class="op">;</span></span>
<span id="cb124-6"><a href="#cb124-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">this</span><span class="op">.</span><span class="at">innerHTML</span> <span class="op">=</span> <span class="vs">`</span></span>
<span id="cb124-7"><a href="#cb124-7" aria-hidden="true" tabindex="-1"></a><span class="vs">      &lt;a href=&quot;</span><span class="sc">${</span>song<span class="op">.</span><span class="at">url</span><span class="sc">}</span><span class="vs">&quot;&gt;</span><span class="sc">${</span>song<span class="op">.</span><span class="at">title</span><span class="sc">}</span><span class="vs">&lt;/a&gt;</span></span>
<span id="cb124-8"><a href="#cb124-8" aria-hidden="true" tabindex="-1"></a><span class="vs">      &lt;br/&gt; </span><span class="sc">${</span>song<span class="op">.</span><span class="at">text</span><span class="sc">}</span></span>
<span id="cb124-9"><a href="#cb124-9" aria-hidden="true" tabindex="-1"></a><span class="vs">    `</span><span class="op">;</span></span>
<span id="cb124-10"><a href="#cb124-10" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb124-11"><a href="#cb124-11" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb124-12"><a href="#cb124-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb124-13"><a href="#cb124-13" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> songResult <span class="op">=</span> <span class="bu">document</span><span class="op">.</span><span class="fu">createElement</span>(<span class="st">&quot;song-result&quot;</span>)<span class="op">;</span></span>
<span id="cb124-14"><a href="#cb124-14" aria-hidden="true" tabindex="-1"></a>songResult<span class="op">.</span><span class="at">data</span> <span class="op">=</span> data<span class="op">;</span>        <span class="co">// setter</span></span>
<span id="cb124-15"><a href="#cb124-15" aria-hidden="true" tabindex="-1"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(songResult<span class="op">.</span><span class="at">data</span>)<span class="op">;</span>  <span class="co">// getter</span></span></code></pre></div>
<p><code>SongResult</code> má nyní pro vlastnost <code>data</code>
getter i setter. Objekt s výsledkem hledání ukládáme do vlastnosti
<code>_song</code>. Podtržítko na začátku nemá žádný speciální význam,
ale v praxi jeho použitím čtenáři naznačujeme, že tato vlastnost je
implementační detail třídy a zvenčí by k ní neměl přistupovat (právě
proto jsme mu za tímto účelem naimplementovali getter). Je to tedy
jakási alternativa <em>privátních vlastností</em>, které se objevují
v jiných jazycích. V JavaScriptu privátní vlastnosti tříd také existují
(stačí, aby jejich název začínal znakem mřížky <code>#</code>), ale
nejsou tak populární, protože je nelze použít v rámci dědičnosti.</p>
<p>Zvídavé čtenáře možná napadne, zdali bychom si předaná data mohli
uložit do <code>this.data?</code> Kód by vypadal takto:</p>
<div class="sourceCode" id="cb125"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb125-1"><a href="#cb125-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> SongResult <span class="kw">extends</span> <span class="bu">HTMLElement</span> {</span>
<span id="cb125-2"><a href="#cb125-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">set</span> <span class="fu">data</span>(song) {</span>
<span id="cb125-3"><a href="#cb125-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">this</span><span class="op">.</span><span class="at">data</span> <span class="op">=</span> song<span class="op">;</span></span>
<span id="cb125-4"><a href="#cb125-4" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb125-5"><a href="#cb125-5" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Takový zápis ovšem nedává smysl, respektive vede na tzv.
<em>nekonečnou rekurzi</em>: v rámci přiřazení <code>this.data</code> je
opět volán setter, takže skončíme v nekonečné smyčce a následně narazíme
na výjimku způsobenou příliš hlubokým zanořením zásobníku volání.</p>
<h2 id="koumáci-předávání-hodnotou-a-odkazem">Koumáci: předávání
hodnotou a odkazem</h2>
<p>Při předávání dat třídě se ještě zastavíme u otázky, jaká data se
dostanou dovnitř volané funkce (ať už je to setter z předchozí
podkapitoly, nebo běžná metoda <code>setData</code> z původního řešení).
Budou to jistě ta samá data, která jsme dostali od serveru. Dostane ale
objekt <code>SongResult</code> jejich kopii, nebo je bude sdílet
s objektem <code>SongSearch</code>? A lze toto chování nějak
ovlivnit?</p>
<p>Odpověď na tyto otázky je přímočará:</p>
<ol type="1">
<li><p>Primitivní datové typy (čísla, řetězce, pravdivostní hodnoty,
undefined, null) jsou <strong>předávány hodnotou</strong>. Do funkce se
dostane kopie hodnoty, resp. uvnitř funkce následně nedokážeme ovlivnit
hodnotu mimo funkci.</p></li>
<li><p>Složité datové typy (zejména objekty, pole, funkce) jsou
<strong>předávány odkazem</strong>. Parametr ve funkci nabývá té samé
hodnoty jako proměnná předaná při volání (můžeme si jej představit jako
odkaz, referenci, ukazatel… podle toho, jaká terminologie nám vyhovuje).
Pokud pak ve funkci nějak předaný parametr upravíme (změníme jeho
vlastnost, přidáme novou), projeví se to i vně funkce.</p></li>
</ol>
<p>Tato pravidla jsou pevná a nelze je upravit. Zejména druhý bod stojí
za povšimnutí. Díky tomuto způsobu předávání šetříme paměť (i kdyz
proměnná obsahuje veliké množství dat, při jejím předání do funkce se
nemusí nikam kopírovat), ale zároveň se vystavujeme riziku, že předáním
dat dojde k jejich změně, aniž bychom to čekali.</p>
<p>Představme si například úlohu, při které dostaneme od serveru pole
uživatelů (u každého bude uvedeno jméno a věk). Máme je následně vypsat
a taktéž sdělit, kolik let je nejmladšímu z nich:</p>
<div class="sourceCode" id="cb126"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb126-1"><a href="#cb126-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> users <span class="op">=</span> [</span>
<span id="cb126-2"><a href="#cb126-2" aria-hidden="true" tabindex="-1"></a>  {<span class="dt">name</span><span class="op">:</span><span class="st">&quot;Eva&quot;</span><span class="op">,</span> <span class="dt">age</span><span class="op">:</span> <span class="dv">30</span>}<span class="op">,</span></span>
<span id="cb126-3"><a href="#cb126-3" aria-hidden="true" tabindex="-1"></a>  {<span class="dt">name</span><span class="op">:</span><span class="st">&quot;Jana&quot;</span><span class="op">,</span> <span class="dt">age</span><span class="op">:</span> <span class="dv">50</span>}<span class="op">,</span></span>
<span id="cb126-4"><a href="#cb126-4" aria-hidden="true" tabindex="-1"></a>  {<span class="dt">name</span><span class="op">:</span><span class="st">&quot;Mirek&quot;</span><span class="op">,</span> <span class="dt">age</span><span class="op">:</span> <span class="dv">10</span>}</span>
<span id="cb126-5"><a href="#cb126-5" aria-hidden="true" tabindex="-1"></a>]<span class="op">;</span></span>
<span id="cb126-6"><a href="#cb126-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb126-7"><a href="#cb126-7" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> minAge <span class="op">=</span> <span class="fu">getMinAge</span>(users)<span class="op">;</span></span>
<span id="cb126-8"><a href="#cb126-8" aria-hidden="true" tabindex="-1"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(<span class="st">&quot;Nejnižší věk: &quot;</span><span class="op">,</span> minAge)<span class="op">;</span></span>
<span id="cb126-9"><a href="#cb126-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb126-10"><a href="#cb126-10" aria-hidden="true" tabindex="-1"></a>users<span class="op">.</span><span class="fu">forEach</span>(<span class="bu">console</span><span class="op">.</span><span class="fu">log</span>)<span class="op">;</span></span></code></pre></div>
<p>Jak naimplementovat funkci <code>getMinAge</code>? Nejsnazší řešení
je seřadit uživatele dle věku vzestupně, a pak se podívat na prvního
z nich. Každé JavaScriptové pole disponuje metodou <code>sort</code>,
které stačí předat vhodnou <strong>porovnávací funkci</strong> (protože
řazení čehokoliv je vlastně jen opakované porovnávání). Porovnávací
funkce dostane dva vzorky a jejím úkolem je vrátit číselnou hodnotu,
která vyjadřuje jejich vzájemný poměr:</p>
<ul>
<li><p>nulu, když jsou stejné</p></li>
<li><p>kladné číslo, když je první vzorek větší</p></li>
<li><p>záporné číslo, když je první vzorek menší</p></li>
</ul>
<p>V našem případě pak implementace <code>getMinAge</code> může vypadat
takto:</p>
<div class="sourceCode" id="cb127"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb127-1"><a href="#cb127-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">compareUsers</span>(u1<span class="op">,</span> u2) {</span>
<span id="cb127-2"><a href="#cb127-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> u1<span class="op">.</span><span class="at">age</span> <span class="op">-</span> u2<span class="op">.</span><span class="at">age</span><span class="op">;</span></span>
<span id="cb127-3"><a href="#cb127-3" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb127-4"><a href="#cb127-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb127-5"><a href="#cb127-5" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">getMinAge</span>(users) {</span>
<span id="cb127-6"><a href="#cb127-6" aria-hidden="true" tabindex="-1"></a>  users<span class="op">.</span><span class="fu">sort</span>(compareUsers)<span class="op">;</span></span>
<span id="cb127-7"><a href="#cb127-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> users[<span class="dv">0</span>]<span class="op">.</span><span class="at">age</span><span class="op">;</span></span>
<span id="cb127-8"><a href="#cb127-8" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Jenže pozor! Metoda <code>sort</code> pole pozměnila (seřadila).
Stalo se tak uvnitř funkce <code>getMinAge</code>, nicméně parametr
<code>users</code> je složitý datový typ, takže změny na něm prováděné
uvnitř <code>getMinAge</code> se projeví i mimo funkci. Jakmile pak
uživatele (globální proměnnou <code>users</code>) vypíšeme cyklem
<code>forEach</code>, zjistíme, že je vypisujeme seřazené – což v zadání
rozhodně nebylo.</p>
<p>Co s tím? Nechtěné změně můžeme předcházet na straně volajícího (ten,
kdo chce zavolat <code>getMinAge</code>, ji musí předat nějaká data,
u kterých nevadí změna) i na straně volaného (funkce
<code>getMinAge</code> se zaváže, že předaná data nebude měnit). V praxi
bývá zvykem druhý přístup, neboť v naprosté většině případů se od funkcí
neočekává, že by měnily data, se kterými mají pracovat. Je tedy nutné
upravit <code>getMinAge</code>, aby se chovala zodpovědněji. Toho můžeme
docílit dvěma způsoby:</p>
<ol type="1">
<li><p>Univerzální řešení je, aby si <code>getMinAge</code> před
seřazením vytvořila duplikát dat. Toho nedocílíme prostým přiřazením
(bystrý čtenář uhodne, proč je hypotetické řešení
<code>let users2 = users; users2.sort()</code> k ničemu), takže je nutné
použít některý z dostupných mechanismů na klonování. V úvahu připadá
relativně moderní funkce <code>structuredClone</code> (ta vytváří
hluboké kopie běžných datových struktur), ale v tomto případě si
vystačíme i s jednodušším řešením. Proměnná <code>users</code> je pole
objektů, takže můžeme snadno vytvořit jeho kopii metodou
<code>slice</code>, která vrací podmnožinu. Bez zadání parametrů
(odkud-kam) vytvoří duplikát:</p>
<div class="sourceCode" id="cb128"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb128-1"><a href="#cb128-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> users2 <span class="op">=</span> users<span class="op">.</span><span class="fu">slice</span>()</span></code></pre></div></li>
<li><p>Alternativně můžeme hledat takovou metodu na seřazení pole, která
zadaný parametr nezmění, ale vrátí nové (seřazené) pole. Taková se do
JavaScriptu dostala jako žhavá novinka v roce 2023 a lze ji volat
takto:</p>
<div class="sourceCode" id="cb129"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb129-1"><a href="#cb129-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> sortedUsers <span class="op">=</span> users<span class="op">.</span><span class="fu">toSorted</span>(compareUsers)<span class="op">;</span></span></code></pre></div></li>
</ol>
<p>Z příkladu v této podkapitole si bereme ponaučení, že bychom měli
naše funkce vést k zodpovědnému chování, pokud jako parametry dostávají
složité datové typy. Volající bude v naprosté většině případů očekávat,
že jeho data žádným způsobem nepozměníme.</p>
<h2 id="profíci-vlastní-události">Profíci: vlastní události</h2>
<p>Použitím techniky <em>Custom Elements</em> vytváříme takové třídy,
které dovedou zpracovávat naše data a přitom zůstávají běžnými obyvateli
HTML dokumentu. Děděním z <code>HTMLElement</code> dostávají vlastnosti
a metody, které jsme doposud vídali jen u vestavěných HTML značek.
Metodu <code>addEventListener</code> nemusíme představovat, ale pro
plnohodnotné využití systému událostí si ukážeme druhou stranu této
mince: možnost události vytvářet a vyvolávat.</p>
<p>Zatím taková potřeba nebyla, neboť téměř veškeré události v knize
probírané vznikaly na základě uživatelovy interakce, tj. za jejich
vytvoření byl zodpovědný prohlížeč. Pokud ale přistoupíme na skladbu
aplikace, při které jsou jednotlivé komponenty realizovány HTML
značkami, můžou se nám události hodit jako notifikační mechanismus.</p>
<p>Na událost můžeme nahlížet jako na zprávu, která má právě jednoho
odesílatele (HTML prvek, na kterém vznikla) a libovolné množství čtenářů
(posluchačů). Odesílatel přitom o čtenářích neví, nestará se o jejich
počet ani existenci. Je to velmi blízké návrhovému vzoru <em>PubSub
(Publisher-Subscriber)</em>. V minulé kapitole jsme uvažovali, jak by
moderovaný diskuzní příspěvek mohl dát svému okolí najevo, že je nutné
příspěvky znovu načíst – vlastní události by posloužily jako funkční
řešení.</p>
<p>V této podkapitole máme třídu <code>SongResult</code>, která
reprezentuje výsledek hledání. Představme si, že bychom chtěli dát
uživateli možnost zpětné vazby, při které by jednotlivé výsledky mohl
označovat jako <em>dobré</em> a <em>špatné</em>. Tuto informaci bychom
prostřednictvím HTTP požadavku předali serveru (aby mohl zlepšovat své
vyhledávací algoritmy) a zároveň bychom špatné výsledky rovnou nahradili
nějakými dalšími.</p>
<p>Takové hodnocení výsledků bude jistě iniciováno uživatelskou
interakcí, tj. kliknutím na tlačítko. Která z našich dvou tříd by měla
realizovat takový posluchač? Argumenty máme pro obě dvě:</p>
<ul>
<li><p>Poslouchat by měla třída <code>SongResult</code>, neboť po
kliknutí budeme muset server informovat o uživatelově hodnocení tohoto
konkrétního výsledku.</p></li>
<li><p>Poslouchat by měla třída <code>SongSearch</code>, neboť pokud
půjde o označení <em>špatného</em> výsledku, bude pak muset vyvolat nové
hledání.</p></li>
</ul>
<p>Klíčový argument je ovšem ve prospěch třídy <code>SongResult</code>.
Skladbu HTML výsledku hledání jsme <em>zapouzdřili</em> do této třídy
jako její vlastní implementační detail a ostatní objekty o její vnitřní
struktuře nemají ponětí. Tlačítko a jeho události si proto bude
spravovat výhradně majitel, tedy třída <code>SongResult</code>. Abychom
pak dali rodičovské třídě <code>SongSearch</code> vědět o nutnosti
doplnění dalších výsledků, necháme <code>SongResult</code> prostě
vygenerovat vlastní událost, jakmile dokončíme komunikaci se serverem.
Začneme obohacením setteru z první podkapitoly:</p>
<div class="sourceCode" id="cb130"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb130-1"><a href="#cb130-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> SongResult <span class="kw">extends</span> <span class="bu">HTMLElement</span> {</span>
<span id="cb130-2"><a href="#cb130-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">set</span> <span class="fu">data</span>(song) {</span>
<span id="cb130-3"><a href="#cb130-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">this</span><span class="op">.</span><span class="at">_song</span> <span class="op">=</span> song<span class="op">;</span></span>
<span id="cb130-4"><a href="#cb130-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">this</span><span class="op">.</span><span class="at">innerHTML</span> <span class="op">=</span> <span class="vs">`</span></span>
<span id="cb130-5"><a href="#cb130-5" aria-hidden="true" tabindex="-1"></a><span class="vs">      &lt;a href=&quot;</span><span class="sc">${</span>song<span class="op">.</span><span class="at">url</span><span class="sc">}</span><span class="vs">&quot;&gt;</span><span class="sc">${</span>song<span class="op">.</span><span class="at">title</span><span class="sc">}</span><span class="vs">&lt;/a&gt;</span></span>
<span id="cb130-6"><a href="#cb130-6" aria-hidden="true" tabindex="-1"></a><span class="vs">      &lt;br/&gt; </span><span class="sc">${</span>song<span class="op">.</span><span class="at">text</span><span class="sc">}</span></span>
<span id="cb130-7"><a href="#cb130-7" aria-hidden="true" tabindex="-1"></a><span class="vs">    `</span><span class="op">;</span></span>
<span id="cb130-8"><a href="#cb130-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb130-9"><a href="#cb130-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> ok <span class="op">=</span> <span class="bu">document</span><span class="op">.</span><span class="fu">createElement</span>(<span class="st">&quot;button&quot;</span>)<span class="op">;</span></span>
<span id="cb130-10"><a href="#cb130-10" aria-hidden="true" tabindex="-1"></a>    ok<span class="op">.</span><span class="at">textContent</span> <span class="op">=</span> <span class="st">&quot;👍&quot;</span><span class="op">;</span></span>
<span id="cb130-11"><a href="#cb130-11" aria-hidden="true" tabindex="-1"></a>    ok<span class="op">.</span><span class="fu">addEventListener</span>(<span class="st">&quot;click&quot;</span><span class="op">,</span> () <span class="kw">=&gt;</span> <span class="kw">this</span><span class="op">.</span><span class="fu">sendRating</span>(<span class="st">&quot;ok&quot;</span>))<span class="op">;</span></span>
<span id="cb130-12"><a href="#cb130-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb130-13"><a href="#cb130-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> ko <span class="op">=</span> <span class="bu">document</span><span class="op">.</span><span class="fu">createElement</span>(<span class="st">&quot;button&quot;</span>)<span class="op">;</span></span>
<span id="cb130-14"><a href="#cb130-14" aria-hidden="true" tabindex="-1"></a>    ko<span class="op">.</span><span class="at">textContent</span> <span class="op">=</span> <span class="st">&quot;👎&quot;</span><span class="op">;</span></span>
<span id="cb130-15"><a href="#cb130-15" aria-hidden="true" tabindex="-1"></a>    ko<span class="op">.</span><span class="fu">addEventListener</span>(<span class="st">&quot;click&quot;</span><span class="op">,</span> () <span class="kw">=&gt;</span> <span class="kw">this</span><span class="op">.</span><span class="fu">sendRating</span>(<span class="st">&quot;ko&quot;</span>))<span class="op">;</span></span>
<span id="cb130-16"><a href="#cb130-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb130-17"><a href="#cb130-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">this</span><span class="op">.</span><span class="fu">append</span>(ok<span class="op">,</span> ko)<span class="op">;</span></span>
<span id="cb130-18"><a href="#cb130-18" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb130-19"><a href="#cb130-19" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Samotná implementace hodnocení není zajímavá. Bude se jistě jednat
o asynchronní funkci, neboť potřebuje komunikovat se serverem. Nás ale
zajímá jen ta část, kdy po dokončení komunikace vytvoříme a pošleme
vlastní událost:</p>
<div class="sourceCode" id="cb131"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb131-1"><a href="#cb131-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> SongResult <span class="kw">extends</span> <span class="bu">HTMLElement</span> {</span>
<span id="cb131-2"><a href="#cb131-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">async</span> <span class="fu">sendRating</span>(rating) {</span>
<span id="cb131-3"><a href="#cb131-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// await fetch(...)</span></span>
<span id="cb131-4"><a href="#cb131-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb131-5"><a href="#cb131-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="bu">event</span> <span class="op">=</span> <span class="kw">new</span> <span class="bu">CustomEvent</span>(<span class="st">&quot;rating&quot;</span><span class="op">,</span> {</span>
<span id="cb131-6"><a href="#cb131-6" aria-hidden="true" tabindex="-1"></a>      <span class="dt">detail</span><span class="op">:</span> {rating}<span class="op">,</span></span>
<span id="cb131-7"><a href="#cb131-7" aria-hidden="true" tabindex="-1"></a>      <span class="dt">bubbles</span><span class="op">:</span> <span class="kw">true</span></span>
<span id="cb131-8"><a href="#cb131-8" aria-hidden="true" tabindex="-1"></a>    })<span class="op">;</span></span>
<span id="cb131-9"><a href="#cb131-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">this</span><span class="op">.</span><span class="fu">dispatchEvent</span>(<span class="bu">event</span>)<span class="op">;</span></span>
<span id="cb131-10"><a href="#cb131-10" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb131-11"><a href="#cb131-11" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Třída <code>CustomEvent</code> vytvoří objekt události, který jsme
navyklí přijímat jako parametr posluchače. První parametr
<code>CustomEvent</code> je název události, druhý je volitelný
konfigurační objekt. Z jeho klíčů je pro nás zajímavá hodnota
<code>bubbles</code> (zdali událost bublá, nebo je na ostatních HTML
prvcích dostupná jen prostřednictvím zachytávání) a pak
<code>detail</code>, do kterého můžeme vložit libovolná data. Činíme tak
proto, aby posluchač události poznal, k jakému hodnocení došlo. Nakonec
událost vyvoláme metodou <code>dispatchEvent</code>, což způsobí volání
dříve přidaných posluchačů.</p>
<p>Ve třídě <code>SongSearch</code> pak budeme tuto událost poslouchat.
Posluchače na ni bychom mohli přidávat individuálně na každý vzniklý
<code>&lt;song-result&gt;</code> (pak by událost nemusela bublat), ale
stejně dobře jej můžeme přidat například na prvek <code>.results</code>,
nebo přímo na celý <code>&lt;song-search&gt;</code>. V takové situaci
stačí posluchač přidat jen jednou, nezávisle na tom, kdy a kolik
výsledků zobrazujeme:</p>
<div class="sourceCode" id="cb132"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb132-1"><a href="#cb132-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> SongSearch <span class="kw">extends</span> <span class="bu">HTMLElement</span> {</span>
<span id="cb132-2"><a href="#cb132-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">connectedCallback</span>() {</span>
<span id="cb132-3"><a href="#cb132-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">this</span><span class="op">.</span><span class="at">innerHTML</span> <span class="op">=</span> HTML<span class="op">;</span></span>
<span id="cb132-4"><a href="#cb132-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">this</span><span class="op">.</span><span class="fu">querySelector</span>(<span class="st">&quot;form&quot;</span>)<span class="op">.</span><span class="fu">addEventListener</span>(<span class="st">&quot;submit&quot;</span><span class="op">,</span> <span class="kw">this</span>)<span class="op">;</span></span>
<span id="cb132-5"><a href="#cb132-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">this</span><span class="op">.</span><span class="fu">addEventListener</span>(<span class="st">&quot;rating&quot;</span><span class="op">,</span> <span class="kw">this</span>)<span class="op">;</span></span>
<span id="cb132-6"><a href="#cb132-6" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb132-7"><a href="#cb132-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb132-8"><a href="#cb132-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">handleEvent</span>(e) {</span>
<span id="cb132-9"><a href="#cb132-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">switch</span> (e<span class="op">.</span><span class="at">type</span>) {</span>
<span id="cb132-10"><a href="#cb132-10" aria-hidden="true" tabindex="-1"></a>      <span class="cf">case</span> <span class="st">&quot;submit&quot;</span><span class="op">:</span></span>
<span id="cb132-11"><a href="#cb132-11" aria-hidden="true" tabindex="-1"></a>        <span class="co">// existující kód související s provedením hledání</span></span>
<span id="cb132-12"><a href="#cb132-12" aria-hidden="true" tabindex="-1"></a>      <span class="cf">break</span><span class="op">;</span></span>
<span id="cb132-13"><a href="#cb132-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb132-14"><a href="#cb132-14" aria-hidden="true" tabindex="-1"></a>      <span class="cf">case</span> <span class="st">&quot;rating&quot;</span><span class="op">:</span></span>
<span id="cb132-15"><a href="#cb132-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (e<span class="op">.</span><span class="at">detail</span><span class="op">.</span><span class="at">rating</span> <span class="op">==</span> <span class="st">&quot;ko&quot;</span>) {</span>
<span id="cb132-16"><a href="#cb132-16" aria-hidden="true" tabindex="-1"></a>          <span class="co">// donačtení nových výsledků</span></span>
<span id="cb132-17"><a href="#cb132-17" aria-hidden="true" tabindex="-1"></a>        }</span>
<span id="cb132-18"><a href="#cb132-18" aria-hidden="true" tabindex="-1"></a>      <span class="cf">break</span><span class="op">;</span></span>
<span id="cb132-19"><a href="#cb132-19" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb132-20"><a href="#cb132-20" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<p>Práce s vlastními událostmi nabízí ideální mechanismus pro podobné
notifikace o komponentách napříč naší aplikací. Využíváme k tomu přitom
infrastrukturu, kterou už velmi dobře známe z událostí typu
<code>click</code> a podobně. Pro úplnost ještě dodejme, že pokud bychom
chtěli dát našim třídám možnost pracovat s událostmi (to znamená metody
<code>addEventListener</code> a <code>dispatchEvent</code>), nemusíme je
kvůli tomu nutně definovat jako Custom Elements (tedy potomky
<code>HTMLElement</code>). Stačí, aby byly potomkem jednodušší třídy
<code>EventTarget</code>. To je k práci s událostmi dostačující, i když
tím přijdeme o možnost propagace událostí stromem stránky – toto chování
je dostupné jen HTML značkám.</p>
<h1 id="intl-storage-polyfilly-a-další-api">Intl, Storage, polyfilly
a další API</h1>
<h2 id="úloha-8">Úloha</h2>
<p>V rámci webu věnovaného písním Karla Gotta připravujeme část
s e-shopem. Na prodej budou originály textů jeho písní s podpisem
textaře. Vypište tyto položky; každá bude obsahovat název písně, datum
jejího vzniku a cenu v korunách.</p>
<h3 id="řešení-8">Řešení</h3>
<p>Soupis písní bude opět pocházet z backendu, jehož rozhraní není pro
tuto úlohu podstatné. Zajímá nás jen tvar dat jednotlivých položek,
které budeme vykreslovat.</p>
<p>Název (řetězec) a cena (číslo) nejsou příliš zajímavé. Datum již
představuje jistou výzvu, neboť jeho reprezentace napříč různými
informačními systémy bývá různorodá. Zejména v případě formátu JSON
(pracujeme s ním pravidelně od páté kapitoly) je nutné formát data
s autory backendové komponenty dobře domluvit, protože JSON žádný datový
typ pro datum neobsahuje. Možností je celá řada; nejčastěji se v praxi
setkáváme se dvěma:</p>
<ol type="1">
<li><p>Datum zapsané ve formátu řetězce s pevnou strukturou. Standardní
zápis bývá sestupně dle velikosti jednotky, tj. např.
<code>1960-05-24</code>. Tímto způsobem může řetězec obsáhnout několik
hodnot naráz (rok, měsíc, den), a pokud by to bylo nutné, můžeme přidat
i časovou informaci v rámce dne (hodiny, minuty, …).</p></li>
<li><p>Datum zapsané jedním číslem, které vyjadřuje počet časových
jednotek uplynulých od vhodně zvoleného počátku. Této formě se říká
<strong>timestamp</strong> (časové razítko) a pro správné fungování je
nutná dohoda na jednotkách (častá volba jsou sekundy či milisekundy)
a počátku (v naprosté většině případů se používá datum 1. 1. 1970).
S jediným číslem se pracuje snadno a elegantně, ovšem pro reprezentaci
dne v roce to není nejlepší volba. Mimo jiné proto, že pro jedno datum
(jeden den) existuje spousta různých hodnot pro timestamp.</p></li>
</ol>
<p>Pojďme naši implementaci postavit tak, že vstupní data budou v poli
struktur s těmito klíči:</p>
<ul>
<li><p><code>id</code> je unikátní identifikátor písně v databázi
(string),</p></li>
<li><p><code>name</code> je název písně (string),</p></li>
<li><p><code>price</code> je cena (číslo),</p></li>
<li><p><code>date</code> je datum ve formátu <code>rok-měsíc-den</code>
(řetězec), nebo timestamp ve vteřinách (číslo).</p></li>
</ul>
<div class="sourceCode" id="cb133"><pre
class="sourceCode html"><code class="sourceCode html"><span id="cb133-1"><a href="#cb133-1" aria-hidden="true" tabindex="-1"></a><span class="co">&lt;!-- kapitola-10.html --&gt;</span></span>
<span id="cb133-2"><a href="#cb133-2" aria-hidden="true" tabindex="-1"></a><span class="dt">&lt;</span><span class="kw">h1</span><span class="dt">&gt;</span>Písně k zakoupení<span class="dt">&lt;/</span><span class="kw">h1</span><span class="dt">&gt;</span></span>
<span id="cb133-3"><a href="#cb133-3" aria-hidden="true" tabindex="-1"></a><span class="dt">&lt;</span><span class="kw">ul</span><span class="dt">&gt;&lt;/</span><span class="kw">ul</span><span class="dt">&gt;</span></span>
<span id="cb133-4"><a href="#cb133-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb133-5"><a href="#cb133-5" aria-hidden="true" tabindex="-1"></a><span class="dt">&lt;</span><span class="kw">script</span> <span class="er">src</span><span class="ot">=</span><span class="st">&quot;kapitola-10.js&quot;</span><span class="dt">&gt;&lt;/</span><span class="kw">script</span><span class="dt">&gt;</span></span></code></pre></div>
<div class="sourceCode" id="cb134"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb134-1"><a href="#cb134-1" aria-hidden="true" tabindex="-1"></a><span class="co">// kapitola-10.js</span></span>
<span id="cb134-2"><a href="#cb134-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> DATA <span class="op">=</span> [</span>
<span id="cb134-3"><a href="#cb134-3" aria-hidden="true" tabindex="-1"></a>  {<span class="dt">name</span><span class="op">:</span> <span class="st">&quot;Kávu si osladím&quot;</span><span class="op">,</span> <span class="dt">date</span><span class="op">:</span> <span class="dv">63111600</span><span class="op">,</span> <span class="dt">price</span><span class="op">:</span> <span class="dv">123</span>}<span class="op">,</span></span>
<span id="cb134-4"><a href="#cb134-4" aria-hidden="true" tabindex="-1"></a>  {<span class="dt">name</span><span class="op">:</span> <span class="st">&quot;Lady Carneval&quot;</span><span class="op">,</span> <span class="dt">date</span><span class="op">:</span> <span class="st">&quot;1968-10-07&quot;</span><span class="op">,</span> <span class="dt">price</span><span class="op">:</span> <span class="dv">345</span>}<span class="op">,</span></span>
<span id="cb134-5"><a href="#cb134-5" aria-hidden="true" tabindex="-1"></a>  {<span class="dt">name</span><span class="op">:</span> <span class="st">&quot;Trezor&quot;</span><span class="op">,</span> <span class="dt">date</span><span class="op">:</span> <span class="st">&quot;1965-04-27&quot;</span><span class="op">,</span> <span class="dt">price</span><span class="op">:</span> <span class="dv">456</span>}</span>
<span id="cb134-6"><a href="#cb134-6" aria-hidden="true" tabindex="-1"></a>]<span class="op">;</span></span>
<span id="cb134-7"><a href="#cb134-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb134-8"><a href="#cb134-8" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> priceOptions <span class="op">=</span> {<span class="dt">style</span><span class="op">:</span><span class="st">&quot;currency&quot;</span><span class="op">,</span> <span class="dt">currency</span><span class="op">:</span><span class="st">&quot;CZK&quot;</span>}<span class="op">;</span></span>
<span id="cb134-9"><a href="#cb134-9" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> priceFormat <span class="op">=</span> <span class="kw">new</span> <span class="bu">Intl</span><span class="op">.</span><span class="fu">NumberFormat</span>(<span class="kw">undefined</span><span class="op">,</span> priceOptions)<span class="op">;</span></span>
<span id="cb134-10"><a href="#cb134-10" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> dateOptions <span class="op">=</span> {<span class="dt">dateStyle</span><span class="op">:</span><span class="st">&quot;long&quot;</span>}<span class="op">;</span></span>
<span id="cb134-11"><a href="#cb134-11" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> dateFormat <span class="op">=</span> <span class="kw">new</span> <span class="bu">Intl</span><span class="op">.</span><span class="fu">DateTimeFormat</span>(<span class="kw">undefined</span><span class="op">,</span> dateOptions)<span class="op">;</span></span>
<span id="cb134-12"><a href="#cb134-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb134-13"><a href="#cb134-13" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">buildItem</span>(item) {</span>
<span id="cb134-14"><a href="#cb134-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> li <span class="op">=</span> <span class="bu">document</span><span class="op">.</span><span class="fu">createElement</span>(<span class="st">&quot;li&quot;</span>)<span class="op">;</span></span>
<span id="cb134-15"><a href="#cb134-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb134-16"><a href="#cb134-16" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> dateIsNumber <span class="op">=</span> (<span class="kw">typeof</span>(item<span class="op">.</span><span class="at">date</span>) <span class="op">==</span> <span class="st">&quot;number&quot;</span>)<span class="op">;</span></span>
<span id="cb134-17"><a href="#cb134-17" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> date <span class="op">=</span> (dateIsNumber</span>
<span id="cb134-18"><a href="#cb134-18" aria-hidden="true" tabindex="-1"></a>          <span class="op">?</span> <span class="kw">new</span> <span class="bu">Date</span>(item<span class="op">.</span><span class="at">date</span><span class="op">*</span><span class="dv">1000</span>)</span>
<span id="cb134-19"><a href="#cb134-19" aria-hidden="true" tabindex="-1"></a>          <span class="op">:</span> <span class="kw">new</span> <span class="bu">Date</span>(item<span class="op">.</span><span class="at">date</span>)</span>
<span id="cb134-20"><a href="#cb134-20" aria-hidden="true" tabindex="-1"></a>        )<span class="op">;</span></span>
<span id="cb134-21"><a href="#cb134-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb134-22"><a href="#cb134-22" aria-hidden="true" tabindex="-1"></a>  li<span class="op">.</span><span class="at">innerHTML</span> <span class="op">=</span> <span class="vs">`</span></span>
<span id="cb134-23"><a href="#cb134-23" aria-hidden="true" tabindex="-1"></a><span class="vs">    &lt;h3&gt;&lt;/h3&gt;</span></span>
<span id="cb134-24"><a href="#cb134-24" aria-hidden="true" tabindex="-1"></a><span class="vs">    &lt;span&gt;Datum: </span><span class="sc">${</span>dateFormat<span class="op">.</span><span class="fu">format</span>(date)<span class="sc">}</span><span class="vs">&lt;/span&gt;</span></span>
<span id="cb134-25"><a href="#cb134-25" aria-hidden="true" tabindex="-1"></a><span class="vs">    &lt;span&gt;Cena: </span><span class="sc">${</span>priceFormat<span class="op">.</span><span class="fu">format</span>(item<span class="op">.</span><span class="at">price</span>)<span class="sc">}</span><span class="vs">&lt;/span&gt;</span></span>
<span id="cb134-26"><a href="#cb134-26" aria-hidden="true" tabindex="-1"></a><span class="vs">  `</span><span class="op">;</span></span>
<span id="cb134-27"><a href="#cb134-27" aria-hidden="true" tabindex="-1"></a>  li<span class="op">.</span><span class="at">children</span>[<span class="dv">0</span>]<span class="op">.</span><span class="at">textContent</span> <span class="op">=</span> item<span class="op">.</span><span class="at">name</span><span class="op">;</span>  <span class="co">// textContent kvůli XSS</span></span>
<span id="cb134-28"><a href="#cb134-28" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> li<span class="op">;</span></span>
<span id="cb134-29"><a href="#cb134-29" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb134-30"><a href="#cb134-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb134-31"><a href="#cb134-31" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> items <span class="op">=</span> DATA<span class="op">.</span><span class="fu">map</span>(buildItem)<span class="op">;</span></span>
<span id="cb134-32"><a href="#cb134-32" aria-hidden="true" tabindex="-1"></a><span class="bu">document</span><span class="op">.</span><span class="fu">querySelector</span>(<span class="st">&quot;ul&quot;</span>)<span class="op">.</span><span class="fu">replaceChildren</span>(<span class="op">...</span>items)<span class="op">;</span></span></code></pre></div>
<p>Při přečtení zadání této úlohy nás možná napadne, že bychom k jejímu
řešení mohli prostě použít to, co jsme se naučili v minulých kapitolách.
Ale pro potřeby výpisu ceny a data by to bylo zbytečně pracné. Je
praktičtější se nejprve podívat, jestli nám JavaScript nebo prohlížeč
nenabízí nějakou vestavěnou funkcionalitu, díky které bychom mohli
ušetřit čas a práci. V tomto případě se jedná o rozhraní
<code>Intl</code>, jehož název je zkratkou z anglického
<em>internationalization</em> – funkce související se zobrazováním
a zpracováním dat s ohledem na místní zvyklosti. Skutečně, cena i datum
jsou příkladem veličin, které se v různých kulturách a jazycích
zobrazují různě (a často docela komplikovaně). I kdybychom své stránky
cílili výhradně na české uživatele, oceníme, když za nás naše regionální
speciality vyřeší někdo jiný.</p>
<p>Globální proměnná <code>Intl</code> obsahuje několik tříd určených
pro zpracovávání a formátování různých druhů dat, vždy s ohledem na
pravidla zadaného jazyka. Ty nejdůležitější jsou:</p>
<ul>
<li><p><code>Intl.Collator</code> pro (abecední) porovnávání
řetězců</p></li>
<li><p><code>Intl.DateTimeFormat</code> pro formátování dat
a časů</p></li>
<li><p><code>Intl.DisplayNames</code> pro zobrazování názvů zemí, jazyků
a měn</p></li>
<li><p><code>Intl.ListFormat</code> pro formátování posloupností
hodnot</p></li>
<li><p><code>Intl.NumberFormat</code> pro zobrazování různých číselných
hodnot</p></li>
<li><p><code>Intl.PluralRules</code> pro správnou volbu názvu
v závislosti na počtu</p></li>
</ul>
<p>V naší úloze používáme dva z těchto objektů.</p>
<h3 id="numberformat">NumberFormat</h3>
<p>Pro zobrazení ceny si nejprve nachystáme <em>formátovací objekt</em>,
tj. instanci třídy <code>Intl.NumberFormat</code>. Jejím prvním
parametrem je identifikátor jazyka, ve kterém chceme čísla zobrazovat.
My předáváme hodnotu <code>undefined</code>, která znamená, že prohlížeč
má použít svůj výchozí jazyk. To je praktické, neboť uživatelé v různých
zemích uvidí naše data vždy dle svých regionálních preferencí.</p>
<p>V druhém parametru (konfiguračním objektu <code>priceOptions</code>)
uvádíme, jakou číselnou hodnotu zobrazujeme (a v jaké měně). Třída
<code>NumberFormat</code> dovoluje formátování cen, fyzikálních veličin,
procent a obecných čísel. Vzniklý formátovací objekt pak metodou
<code>format</code> aplikujeme na konkrétní číselná data a zpět
dostáváme řetězce určené k zobrazení.</p>
<p>Pro úplnost uveďme několik příkladů tohoto rozhraní:</p>
<div class="sourceCode" id="cb135"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb135-1"><a href="#cb135-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> style <span class="op">=</span> <span class="st">&quot;currency&quot;</span><span class="op">;</span></span>
<span id="cb135-2"><a href="#cb135-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb135-3"><a href="#cb135-3" aria-hidden="true" tabindex="-1"></a><span class="kw">new</span> <span class="bu">Intl</span><span class="op">.</span><span class="fu">NumberFormat</span>(<span class="st">&quot;cs&quot;</span><span class="op">,</span> {style<span class="op">,</span> <span class="dt">currency</span><span class="op">:</span><span class="st">&quot;CZK&quot;</span>})<span class="op">.</span><span class="fu">format</span>(<span class="fl">1234.56</span>)<span class="op">;</span></span>
<span id="cb135-4"><a href="#cb135-4" aria-hidden="true" tabindex="-1"></a><span class="co">// &quot;1 234,65 Kč&quot;</span></span>
<span id="cb135-5"><a href="#cb135-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb135-6"><a href="#cb135-6" aria-hidden="true" tabindex="-1"></a><span class="kw">new</span> <span class="bu">Intl</span><span class="op">.</span><span class="fu">NumberFormat</span>(<span class="st">&quot;en&quot;</span><span class="op">,</span> {style<span class="op">,</span> <span class="dt">currency</span><span class="op">:</span><span class="st">&quot;CZK&quot;</span>})<span class="op">.</span><span class="fu">format</span>(<span class="fl">1234.65</span>)<span class="op">;</span></span>
<span id="cb135-7"><a href="#cb135-7" aria-hidden="true" tabindex="-1"></a><span class="co">// &quot;CZK 1,234.65&quot;</span></span>
<span id="cb135-8"><a href="#cb135-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb135-9"><a href="#cb135-9" aria-hidden="true" tabindex="-1"></a><span class="kw">new</span> <span class="bu">Intl</span><span class="op">.</span><span class="fu">NumberFormat</span>(<span class="st">&quot;cs&quot;</span><span class="op">,</span> {style<span class="op">,</span> <span class="dt">currency</span><span class="op">:</span><span class="st">&quot;USD&quot;</span>})<span class="op">.</span><span class="fu">format</span>(<span class="dv">123</span>)<span class="op">;</span></span>
<span id="cb135-10"><a href="#cb135-10" aria-hidden="true" tabindex="-1"></a><span class="co">// &quot;123,00 US$&quot;</span></span>
<span id="cb135-11"><a href="#cb135-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb135-12"><a href="#cb135-12" aria-hidden="true" tabindex="-1"></a><span class="kw">new</span> <span class="bu">Intl</span><span class="op">.</span><span class="fu">NumberFormat</span>(<span class="st">&quot;en&quot;</span><span class="op">,</span> {style<span class="op">,</span> <span class="dt">currency</span><span class="op">:</span><span class="st">&quot;USD&quot;</span>})<span class="op">.</span><span class="fu">format</span>(<span class="dv">123</span>)<span class="op">;</span></span>
<span id="cb135-13"><a href="#cb135-13" aria-hidden="true" tabindex="-1"></a><span class="co">// &quot;$123.00&quot;</span></span></code></pre></div>
<p>Všimněme si například různých oddělovačů tisíců, nebo desetinné tečky
(v angličtině) vs. desetinné čárky (v češtině). Implementovat tyto
rozdíly ručně by bylo velmi pracné.</p>
<h3 id="datetimeformat">DateTimeFormat</h3>
<p>S formátovacím objektem typu <code>DateTimeFormat</code> se pracuje
stejně, jen mu hodnotu musíme předat jako instanci JavaScriptové třídy
<code>Date</code>. JavaScript totiž má, na rozdíl od JSONu, vestavěný
datový typ pro datum a čas. Objekty <code>Date</code> reprezentují bod
v čase, a fakticky tak nabízí podobnou funkcionalitu jako zmiňovaný
timestamp. V porovnání s číslem ovšem nabízí užitečné metody na čtení
a změnu jednotlivých součástí (rok, měsíc, den, hodina, minuta, …).</p>
<p>Formátování data tím pádem provedeme ve dvou krocích: nejprve ze
získané hodnoty (JSON) vytvoříme objekt <code>Date</code>, poté
provedeme formátování pomocí <code>Intl.DateTimeFormat</code>. Víme, že
v datech ze serveru může přijít buď řetězec, nebo číslo. Funkce
<code>Date</code> dokáže přijmout obě tyto hodnoty, ovšem u čísla
předpokládá, že timestamp je v milisekundách. Proto příchozí číslo
nejprve vynásobíme tisícem.</p>
<p>První parametr pro <code>DateTimeFormat</code> je opět identifikátor
jazyka, který znovu neuvedeme, aby se použil ten, který je v prohlížeči
výchozí. V konfiguračním objektu pak můžeme řadou vlastností upřesnit,
které všechny komponenty z data a času chceme vypsat (a s jakou mírou
podrobnosti). Nás zajímá jen datum, proto uvádíme klíč
<code>dateStyle</code> (pro čas bychom přidali ještě
<code>timeStyle</code>). Ze zvědavosti se podíváme, jaké hodnoty
připadají v úvahu:</p>
<div class="sourceCode" id="cb136"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb136-1"><a href="#cb136-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> date <span class="op">=</span> <span class="kw">new</span> <span class="bu">Date</span>(<span class="st">&quot;1982-10-19&quot;</span>)<span class="op">;</span></span>
<span id="cb136-2"><a href="#cb136-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb136-3"><a href="#cb136-3" aria-hidden="true" tabindex="-1"></a><span class="kw">new</span> <span class="bu">Intl</span><span class="op">.</span><span class="fu">DateTimeFormat</span>(<span class="st">&quot;cs&quot;</span><span class="op">,</span> {<span class="dt">dateStyle</span><span class="op">:</span><span class="st">&quot;full&quot;</span>})<span class="op">.</span><span class="fu">format</span>(date)<span class="op">;</span></span>
<span id="cb136-4"><a href="#cb136-4" aria-hidden="true" tabindex="-1"></a><span class="co">// &quot;úterý 19. října 1982&quot;</span></span>
<span id="cb136-5"><a href="#cb136-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb136-6"><a href="#cb136-6" aria-hidden="true" tabindex="-1"></a><span class="kw">new</span> <span class="bu">Intl</span><span class="op">.</span><span class="fu">DateTimeFormat</span>(<span class="st">&quot;cs&quot;</span><span class="op">,</span> {<span class="dt">dateStyle</span><span class="op">:</span><span class="st">&quot;long&quot;</span>})<span class="op">.</span><span class="fu">format</span>(date)<span class="op">;</span></span>
<span id="cb136-7"><a href="#cb136-7" aria-hidden="true" tabindex="-1"></a><span class="co">// &quot;19. října 1982&quot;</span></span>
<span id="cb136-8"><a href="#cb136-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb136-9"><a href="#cb136-9" aria-hidden="true" tabindex="-1"></a><span class="kw">new</span> <span class="bu">Intl</span><span class="op">.</span><span class="fu">DateTimeFormat</span>(<span class="st">&quot;cs&quot;</span><span class="op">,</span> {<span class="dt">dateStyle</span><span class="op">:</span><span class="st">&quot;medium&quot;</span>})<span class="op">.</span><span class="fu">format</span>(date)<span class="op">;</span></span>
<span id="cb136-10"><a href="#cb136-10" aria-hidden="true" tabindex="-1"></a><span class="co">// &quot;19. 10. 1982&quot;</span></span>
<span id="cb136-11"><a href="#cb136-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb136-12"><a href="#cb136-12" aria-hidden="true" tabindex="-1"></a><span class="kw">new</span> <span class="bu">Intl</span><span class="op">.</span><span class="fu">DateTimeFormat</span>(<span class="st">&quot;cs&quot;</span><span class="op">,</span> {<span class="dt">dateStyle</span><span class="op">:</span><span class="st">&quot;short&quot;</span>})<span class="op">.</span><span class="fu">format</span>(date)<span class="op">;</span></span>
<span id="cb136-13"><a href="#cb136-13" aria-hidden="true" tabindex="-1"></a><span class="co">// &quot;19.10.82&quot;</span></span></code></pre></div>
<h3 id="co-jsme-se-naučili-7">Co jsme se naučili</h3>
<p>Po vyřešení deváté úlohy by měl čtenář chápat a ovládat:</p>
<ul>
<li><p>reprezentaci data v JavaScriptu a JSONu</p></li>
<li><p>smysl rozhraní <code>Intl</code></p></li>
<li><p>práci s objekty <code>Intl.NumberFormat</code>
a <code>Intl.DateTimeFormat</code></p></li>
</ul>
<h2 id="zelenáči-web-storage">Zelenáči: Web Storage</h2>
<p>Protože úloha v této kapitole je motivována e-shopem, mohli bychom si
vyzkoušet implementaci jednoduchého nákupního košíku. Do něj smí
uživatel vložit položky, o které má zájem, a při jejich výpisu bude tato
skutečnost zmíněna. Klíčovým atributem nákupního košíku je, že jeho
obsah je dostupný i po znovunačtení stránky. Typicky je toho docíleno
ukládáním obsahu košíku na serveru, ale v této knize se soustředíme na
klientský JavaScript a zároveň je to skvělý způsob, jak si vyzkoušet
další užitečné a přitom velmi snadné rozhraní – <strong>Web
Storage</strong>.</p>
<p>Prohlížeč nám prostřednictvím Web Storage nabízí možnost uložit data
tak, abychom se k nim dostali při všech dalších návštěvách dané stránky.
Přesněji, tato data jsou dostupná <em>všem stránkám na té doméně, ve
které byla uložena</em>. Máme tak zaručeno, že se k takto uloženým datům
nedostanou skripty vložené do cizích stránek (tj. stránek na jiných
doménách).</p>
<p>S rozhraním Web Storage pracujeme prostřednictvím globální proměnné
<code>localStorage</code>, která nabízí dvě hlavní metody:</p>
<div class="sourceCode" id="cb137"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb137-1"><a href="#cb137-1" aria-hidden="true" tabindex="-1"></a><span class="co">// zápis</span></span>
<span id="cb137-2"><a href="#cb137-2" aria-hidden="true" tabindex="-1"></a>localStorage<span class="op">.</span><span class="fu">setItem</span>(key<span class="op">,</span> value)<span class="op">;</span></span>
<span id="cb137-3"><a href="#cb137-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb137-4"><a href="#cb137-4" aria-hidden="true" tabindex="-1"></a><span class="co">// čtení</span></span>
<span id="cb137-5"><a href="#cb137-5" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> value <span class="op">=</span> localStorage<span class="op">.</span><span class="fu">getItem</span>(key)<span class="op">;</span></span></code></pre></div>
<p>Vidíme, že do Web Storage ukládáme dvojice klíč-hodnota. Jak klíče,
tak hodnoty musí být obyčejné řetězce. Pokud tedy chceme uložit
složitější data (jako například nákupní košík), budeme je muset pro
potřeby uložení převést na řetězec.</p>
<p>Nákupní košík můžeme reprezentovat různými způsoby, nejjednodušeji
jako pole identifikátorů těch položek, které jsou v košíku. Abychom toto
pole mohli vložit do <code>localStorage</code>, můžeme jej převést na
řetězec například metodou <code>JSON.stringify</code> (dostaneme řetězec
ve formátu JSON). Při načtení stránky pak košík z minula, pokud nějaký
je, získáme zpět z <code>localStorage</code> a převedeme na pole metodou
<code>JSON.parse</code>:</p>
<div class="sourceCode" id="cb138"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb138-1"><a href="#cb138-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> storedData <span class="op">=</span> localStorage<span class="op">.</span><span class="fu">getItem</span>(<span class="st">&quot;shopping-cart&quot;</span>)<span class="op">;</span></span>
<span id="cb138-2"><a href="#cb138-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> shoppingCart <span class="op">=</span> storedData <span class="op">?</span> <span class="bu">JSON</span><span class="op">.</span><span class="fu">parse</span>(storedData) <span class="op">:</span> []<span class="op">;</span></span>
<span id="cb138-3"><a href="#cb138-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb138-4"><a href="#cb138-4" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">addToCart</span>(id) {</span>
<span id="cb138-5"><a href="#cb138-5" aria-hidden="true" tabindex="-1"></a>  shoppingCart<span class="op">.</span><span class="fu">push</span>(id)<span class="op">;</span></span>
<span id="cb138-6"><a href="#cb138-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> data <span class="op">=</span> <span class="bu">JSON</span><span class="op">.</span><span class="fu">stringify</span>(shoppingCart)<span class="op">;</span></span>
<span id="cb138-7"><a href="#cb138-7" aria-hidden="true" tabindex="-1"></a>  localStorage<span class="op">.</span><span class="fu">setItem</span>(<span class="st">&quot;shopping-cart&quot;</span><span class="op">,</span> data)<span class="op">;</span></span>
<span id="cb138-8"><a href="#cb138-8" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb138-9"><a href="#cb138-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb138-10"><a href="#cb138-10" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">removeFromCart</span>(id) {</span>
<span id="cb138-11"><a href="#cb138-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> index <span class="op">=</span> shoppingCart<span class="op">.</span><span class="fu">indexOf</span>(id)<span class="op">;</span></span>
<span id="cb138-12"><a href="#cb138-12" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (index <span class="op">!=</span> <span class="op">-</span><span class="dv">1</span>) {</span>
<span id="cb138-13"><a href="#cb138-13" aria-hidden="true" tabindex="-1"></a>    shoppingCart<span class="op">.</span><span class="fu">splice</span>(index<span class="op">,</span> <span class="dv">1</span>)<span class="op">;</span></span>
<span id="cb138-14"><a href="#cb138-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> data <span class="op">=</span> <span class="bu">JSON</span><span class="op">.</span><span class="fu">stringify</span>(shoppingCart)<span class="op">;</span></span>
<span id="cb138-15"><a href="#cb138-15" aria-hidden="true" tabindex="-1"></a>    localStorage<span class="op">.</span><span class="fu">setItem</span>(<span class="st">&quot;shopping-cart&quot;</span><span class="op">,</span> data)<span class="op">;</span></span>
<span id="cb138-16"><a href="#cb138-16" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb138-17"><a href="#cb138-17" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Odebírání položky z pole je komplikovanější. Nejprve musíme zjistit
její <em>index</em> (tj. na kolikátém místě se nachází), a pak z pole
odstranit prvek dle indexu. Používáme k tomu metodu
<code>indexOf</code>; ta pro neexistující prvek vrací speciální hodnotu
<code>-1</code>.</p>
<p>Jistou alternativou by bylo ukládání položek v množině (objekt
<code>Set</code>), u které je – na rozdíl od pole – zaručena
jedinečnost, a proto je možné prvek odebrat bez znalosti indexu. Množinu
ale neumíme přímočaře reprezentovat ve formátu JSON, takže se budeme
držet obyčejného pole. Pak už jen stačí ke každé položce přidat
tlačítko:</p>
<div class="sourceCode" id="cb139"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb139-1"><a href="#cb139-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">buildCartButton</span>(item) {</span>
<span id="cb139-2"><a href="#cb139-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> button <span class="op">=</span> <span class="bu">document</span><span class="op">.</span><span class="fu">createElement</span>(<span class="st">&quot;button&quot;</span>)<span class="op">;</span></span>
<span id="cb139-3"><a href="#cb139-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb139-4"><a href="#cb139-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (shoppingCart<span class="op">.</span><span class="fu">includes</span>(item<span class="op">.</span><span class="at">id</span>)) {</span>
<span id="cb139-5"><a href="#cb139-5" aria-hidden="true" tabindex="-1"></a>    button<span class="op">.</span><span class="at">textContent</span> <span class="op">=</span> <span class="st">&quot;Odebrat z košíku&quot;</span><span class="op">;</span></span>
<span id="cb139-6"><a href="#cb139-6" aria-hidden="true" tabindex="-1"></a>  } <span class="cf">else</span> {</span>
<span id="cb139-7"><a href="#cb139-7" aria-hidden="true" tabindex="-1"></a>    button<span class="op">.</span><span class="at">textContent</span> <span class="op">=</span> <span class="st">&quot;Přidat do košíku&quot;</span><span class="op">;</span></span>
<span id="cb139-8"><a href="#cb139-8" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb139-9"><a href="#cb139-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb139-10"><a href="#cb139-10" aria-hidden="true" tabindex="-1"></a>  button<span class="op">.</span><span class="fu">addEventListener</span>(<span class="st">&quot;click&quot;</span><span class="op">,</span> () <span class="kw">=&gt;</span> {</span>
<span id="cb139-11"><a href="#cb139-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (shoppingCart<span class="op">.</span><span class="fu">includes</span>(item<span class="op">.</span><span class="at">id</span>)) {</span>
<span id="cb139-12"><a href="#cb139-12" aria-hidden="true" tabindex="-1"></a>      <span class="fu">removeFromCart</span>(item<span class="op">.</span><span class="at">id</span>)<span class="op">;</span></span>
<span id="cb139-13"><a href="#cb139-13" aria-hidden="true" tabindex="-1"></a>    } <span class="cf">else</span> {</span>
<span id="cb139-14"><a href="#cb139-14" aria-hidden="true" tabindex="-1"></a>      <span class="fu">addToCart</span>(item<span class="op">.</span><span class="at">id</span>)<span class="op">;</span></span>
<span id="cb139-15"><a href="#cb139-15" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb139-16"><a href="#cb139-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb139-17"><a href="#cb139-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> newButton <span class="op">=</span> <span class="fu">buildCartButton</span>(item)<span class="op">;</span></span>
<span id="cb139-18"><a href="#cb139-18" aria-hidden="true" tabindex="-1"></a>    button<span class="op">.</span><span class="fu">replaceWith</span>(newButton)<span class="op">;</span></span>
<span id="cb139-19"><a href="#cb139-19" aria-hidden="true" tabindex="-1"></a>  })<span class="op">;</span></span>
<span id="cb139-20"><a href="#cb139-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb139-21"><a href="#cb139-21" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> button<span class="op">;</span></span>
<span id="cb139-22"><a href="#cb139-22" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Jakmile dojde ke změně obsahu košíku, musíme tuto skutečnost
zohlednit v uživatelském rozhraní. Jednou z možností by byla změna textu
na existujícím tlačítku. Tím bychom ale měli kód s nastavováním textu
dvakrát. Proto je snazší vyrobit nové tlačítko (se správným novým
textem) a nahradit jím to původní.</p>
<h2 id="koumáci-polyfilly">Koumáci: Polyfilly</h2>
<p>Při tvorbě webových aplikací často narážíme na otázku kompatibility
napříč prohlížeči. Jejich nové verze vznikají s vysokou frekvencí a může
se stát, že při psaní JavaScriptového kódu použijeme jinou verzi, než
jakou pak bude mít uživatel při prohlížení našeho webu. Dopředná
kompatibilita (použití staré funkcionality v modernějších verzích)
typicky nebývá problém, neboť webové standardy – HTML, CSS, JavaScript –
se snaží o zachování maximální podpory všech historicky existujících
funkcí. Horší ale je, když například s novou verzí standardu HTML či
ECMAScript přibude užitečné API, které bychom rádi použili, ale musíme
počítat i s těmi uživateli, ke kterým se pokročilá implementace zatím
nedostala.</p>
<p>Příkladem může být právě některý objekt ze standardu
<code>Intl</code>. Pokud bychom neměli jistotu, že každý uživatel má
prohlížeč s třídou <code>Intl.DateTimeFormat</code>, jak bychom při
řešení úlohy z této kapitoly postupovali?</p>
<p>Konzervativní přístup je formátovat datum bez použití
<code>Intl</code>. Víme, že je to možné, ale zároveň je to pracné a málo
flexibilní (s ohledem na všechny možné jazyky našich uživatelů). Mohli
bychom se proto uchýlit k podmínce:</p>
<div class="sourceCode" id="cb140"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb140-1"><a href="#cb140-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> date <span class="op">=</span> <span class="kw">new</span> <span class="bu">Date</span>()<span class="op">;</span></span>
<span id="cb140-2"><a href="#cb140-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb140-3"><a href="#cb140-3" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (<span class="bu">Intl</span><span class="op">.</span><span class="at">DateTimeFormat</span>) {</span>
<span id="cb140-4"><a href="#cb140-4" aria-hidden="true" tabindex="-1"></a>  <span class="co">// automatické, chytré řešení</span></span>
<span id="cb140-5"><a href="#cb140-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> options <span class="op">=</span> {<span class="dt">dateStyle</span><span class="op">:</span><span class="st">&quot;long&quot;</span>}<span class="op">;</span></span>
<span id="cb140-6"><a href="#cb140-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> dateFormat <span class="op">=</span> <span class="kw">new</span> <span class="bu">Intl</span><span class="op">.</span><span class="fu">DateTimeFormat</span>(<span class="kw">undefined</span><span class="op">,</span> options)<span class="op">;</span></span>
<span id="cb140-7"><a href="#cb140-7" aria-hidden="true" tabindex="-1"></a>  <span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(dateFormat<span class="op">.</span><span class="fu">format</span>(date))<span class="op">;</span></span>
<span id="cb140-8"><a href="#cb140-8" aria-hidden="true" tabindex="-1"></a>} <span class="cf">else</span> {</span>
<span id="cb140-9"><a href="#cb140-9" aria-hidden="true" tabindex="-1"></a>  <span class="co">// ruční, slabé řešení</span></span>
<span id="cb140-10"><a href="#cb140-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> parts <span class="op">=</span> [</span>
<span id="cb140-11"><a href="#cb140-11" aria-hidden="true" tabindex="-1"></a>    date<span class="op">.</span><span class="fu">getDate</span>()<span class="op">,</span></span>
<span id="cb140-12"><a href="#cb140-12" aria-hidden="true" tabindex="-1"></a>    date<span class="op">.</span><span class="fu">getMonth</span>()<span class="op">+</span><span class="dv">1</span><span class="op">,</span></span>
<span id="cb140-13"><a href="#cb140-13" aria-hidden="true" tabindex="-1"></a>    date<span class="op">.</span><span class="fu">getFullYear</span>()</span>
<span id="cb140-14"><a href="#cb140-14" aria-hidden="true" tabindex="-1"></a>  ]<span class="op">;</span></span>
<span id="cb140-15"><a href="#cb140-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> str <span class="op">=</span> parts<span class="op">.</span><span class="fu">join</span>(<span class="st">&quot;. &quot;</span>)<span class="op">;</span></span>
<span id="cb140-16"><a href="#cb140-16" aria-hidden="true" tabindex="-1"></a>  <span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(str)<span class="op">;</span></span>
<span id="cb140-17"><a href="#cb140-17" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Nevýhodou je, že náš kód je nyní zbytečně <em>chytrý</em> – obsahuje
dvě různé varianty formátování data. Pokud bychom datum zpracovávali na
více místech, tato neoptimalita by byla ještě patrnější. Podíváme se
proto na alternativní přístup, kterému se říká
<strong>polyfill</strong>.</p>
<p>Koncept polyfillu (český ekvivalent neexistuje) je specifikum
JavaScriptu; v jiných jazycích se s ním nesetkáváme. Jeho podstatou je
skutečnost, že JavaScript je velmi dynamický, a pokud v něm nějaká
globálně dostupná funkcionalita schází, můžeme ji za jistých podmínek
prostě doplnit. V praxi to znamená, že do stránky vložíme dva skripty:
nejprve soubor s polyfillem, který zmiňovanou funkci implementuje; poté
naši aplikaci, která se už nemusí rozhodovat podle dostupnosti, neboť
díky polyfillu je potřebná funkce vždy dostupná.</p>
<p>Zkusme si jednoduchou verzi polyfillu pro <code>DateTimeFormat</code>
naimplementovat sami:</p>
<div class="sourceCode" id="cb141"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb141-1"><a href="#cb141-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> DateTimeFormat {</span>
<span id="cb141-2"><a href="#cb141-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">constructor</span>(language<span class="op">,</span> options) {</span>
<span id="cb141-3"><a href="#cb141-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">this</span><span class="op">.</span><span class="at">language</span> <span class="op">=</span> language<span class="op">;</span>  <span class="co">// neumíme zohlednit</span></span>
<span id="cb141-4"><a href="#cb141-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">this</span><span class="op">.</span><span class="at">options</span> <span class="op">=</span> options<span class="op">;</span></span>
<span id="cb141-5"><a href="#cb141-5" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb141-6"><a href="#cb141-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb141-7"><a href="#cb141-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">format</span>(date) {</span>
<span id="cb141-8"><a href="#cb141-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// výhledově bychom měli zohlednit this.options.dateStyle</span></span>
<span id="cb141-9"><a href="#cb141-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> parts <span class="op">=</span> [</span>
<span id="cb141-10"><a href="#cb141-10" aria-hidden="true" tabindex="-1"></a>      date<span class="op">.</span><span class="fu">getDate</span>()<span class="op">,</span></span>
<span id="cb141-11"><a href="#cb141-11" aria-hidden="true" tabindex="-1"></a>      date<span class="op">.</span><span class="fu">getMonth</span>()<span class="op">+</span><span class="dv">1</span><span class="op">,</span></span>
<span id="cb141-12"><a href="#cb141-12" aria-hidden="true" tabindex="-1"></a>      date<span class="op">.</span><span class="fu">getFullYear</span>()</span>
<span id="cb141-13"><a href="#cb141-13" aria-hidden="true" tabindex="-1"></a>    ]<span class="op">;</span></span>
<span id="cb141-14"><a href="#cb141-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> parts<span class="op">.</span><span class="fu">join</span>(<span class="st">&quot;. &quot;</span>)<span class="op">;</span></span>
<span id="cb141-15"><a href="#cb141-15" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb141-16"><a href="#cb141-16" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb141-17"><a href="#cb141-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb141-18"><a href="#cb141-18" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (<span class="op">!</span><span class="bu">Intl</span><span class="op">.</span><span class="at">DateTimeFormat</span>) {</span>
<span id="cb141-19"><a href="#cb141-19" aria-hidden="true" tabindex="-1"></a>  <span class="bu">Intl</span><span class="op">.</span><span class="at">DateTimeFormat</span> <span class="op">=</span> DateTimeFormat<span class="op">;</span></span>
<span id="cb141-20"><a href="#cb141-20" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Nedílnou součástí každého dobrého polyfillu je <strong>feature
testing</strong>: musíme ověřit, zdali prohlížeč námi dodávanou
funkcionalitu neumí sám od sebe. Pokud ano, bylo by zbytečné (v tomto
případě dokonce škodlivé) dodávat tu naši. Proto do
<code>Intl.DateTimeFormat</code> přiřazujeme v podmínce na konci
polyfillu.</p>
<p>Výše uvedený polyfill v této formě nelze považovat za plnohodnotnou
náhradu objektu <code>DateTimeFormat</code>. Jednak nerespektuje zadaný
jazyk, jednak vůbec není možné konfigurovat formát výpisu pomocí druhého
parametru konstruktoru. Zvídavý čtenář může ale snadno metodu
<code>format</code> obohatit i o další formáty data či času.</p>
<p>Mimochodem: pokud bychom narazili na opravdu starý prohlížeč, mohlo
by se stát, že by v něm vůbec nebyla globální proměnná
<code>Intl</code>. Pak bychom museli kód na konci polyfillu upravit
následovně:</p>
<div class="sourceCode" id="cb142"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb142-1"><a href="#cb142-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (<span class="op">!</span><span class="bu">window</span><span class="op">.</span><span class="at">Intl</span>) { <span class="bu">window</span><span class="op">.</span><span class="at">Intl</span> <span class="op">=</span> {}<span class="op">;</span> }</span>
<span id="cb142-2"><a href="#cb142-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb142-3"><a href="#cb142-3" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (<span class="op">!</span><span class="bu">Intl</span><span class="op">.</span><span class="at">DateTimeFormat</span>) {</span>
<span id="cb142-4"><a href="#cb142-4" aria-hidden="true" tabindex="-1"></a>  <span class="bu">Intl</span><span class="op">.</span><span class="at">DateTimeFormat</span> <span class="op">=</span> DateTimeFormat<span class="op">;</span></span>
<span id="cb142-5"><a href="#cb142-5" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>V praxi se s polyfilly setkáváme celkem často. To proto, že řada
JavaScriptových funkcí vzniká za účelem zvýšení vývojářova komfortu, ale
koncepčně nic nového nepřináší. V aplikacích pak můžeme vidět
plnohodnotné polyfilly například pro funkci <code>fetch</code>, objekt
<code>Promise</code> nebo třeba
<code>String.prototype.padStart</code>.</p>
<p>Ne vždy ovšem můžeme polyfill použít. V těchto dvou případech máme
smůlu:</p>
<ol type="1">
<li><p>Když se jedná o <strong>změnu syntaxe</strong> jazyka (příklad:
klíčová slova <code>async/await</code>, arrow funkce, <code>class</code>
a další). Kód našeho polyfillu nedovede naučit parser JavaScriptu novým
pravidlům; jeho prostřednictvím můžeme jen přidávat nové vlastnosti
a funkce existujícím rozhraním.</p></li>
<li><p>Když potřebná funkcionalita není v prohlížeči žádným způsobem
dostupná (příklad: Web Storage, <code>XMLHttpRequest</code>, další API
z následující podkapitoly). V takové situaci sice umíme pomocí polyfillu
dodat potřebné rozhraní, ale neumíme zařídit jeho (dostatečnou)
funkčnost.</p></li>
</ol>
<p>Studium či dokonce vlastní tvorba polyfillů je každopádně skvělý
způsob, jak si osvojit různá JavaScriptová rozhraní a seznámit se
s jejich fungováním. Pojďme si na závěr této podkapitoly vyzkoušet
polyfill (tentokrát plně funkční) pro funkcionální iteraci, konkrétně
například pro metodu <code>Array.prototype.map</code>:</p>
<div class="sourceCode" id="cb143"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb143-1"><a href="#cb143-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (<span class="op">!</span><span class="bu">Array</span><span class="op">.</span><span class="at">prototype</span><span class="op">.</span><span class="at">map</span>) {</span>
<span id="cb143-2"><a href="#cb143-2" aria-hidden="true" tabindex="-1"></a>  <span class="bu">Array</span><span class="op">.</span><span class="at">prototype</span><span class="op">.</span><span class="at">map</span> <span class="op">=</span> <span class="kw">function</span>(callback<span class="op">,</span> thisArg) {</span>
<span id="cb143-3"><a href="#cb143-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> results <span class="op">=</span> []<span class="op">;</span></span>
<span id="cb143-4"><a href="#cb143-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> arr <span class="op">=</span> <span class="kw">this</span><span class="op">;</span></span>
<span id="cb143-5"><a href="#cb143-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (<span class="kw">let</span> i<span class="op">=</span><span class="dv">0</span><span class="op">;</span> i<span class="op">&lt;</span>arr<span class="op">.</span><span class="at">length</span><span class="op">;</span> i<span class="op">++</span>) {</span>
<span id="cb143-6"><a href="#cb143-6" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> result <span class="op">=</span> callback<span class="op">.</span><span class="fu">call</span>(thisArg<span class="op">,</span> arr[i]<span class="op">,</span> i<span class="op">,</span> arr)<span class="op">;</span></span>
<span id="cb143-7"><a href="#cb143-7" aria-hidden="true" tabindex="-1"></a>      results<span class="op">.</span><span class="fu">push</span>(result)<span class="op">;</span></span>
<span id="cb143-8"><a href="#cb143-8" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb143-9"><a href="#cb143-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> results<span class="op">;</span></span>
<span id="cb143-10"><a href="#cb143-10" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb143-11"><a href="#cb143-11" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<h2 id="profíci-další-api">Profíci: další API</h2>
<p>V této kapitole jsme si ukázali, že v prostředí (nejen) klientského
JavaScriptu je k dispozici řada rozhraní, která nám mohou významně
usnadnit práci. Jsou to tzv. <em>domain-specific</em> APIs; nástroje,
které používáme situačně. Někdy je nepotřebujeme vůbec, jindy jsme za
jejich přítomnost velmi vděčni. Podobných rozhraní jsou k dispozici
desítky a jejich popis by vystačil na celou další knihu. Pojďme si
v podkapitole pro profíky alespoň v rychlosti popsat ta, která jsou
nejzajímavější a nejužitečnější.</p>
<ul>
<li><p><strong>Web Crypto</strong>: funkce pro generování náhodných
čísel, šifrovacích klíčů, hashování, šifrování a dešifrování,
podepisování a ověřování.</p></li>
<li><p><strong>Web Audio</strong>: funkce pro generování zvuku, jeho
transformaci a analýzu.</p></li>
<li><p><strong>Web MIDI</strong>: rozhraní pro spolupráci s externími
zařízeními, které generují či přijímají tzv. <em>MIDI události</em>
(používají se zejména v hudební produkci).</p></li>
<li><p><strong>Gamepad API</strong>: získávání stavu ovládacích prvků na
herních ovladačích.</p></li>
<li><p><strong>Sensor APIs</strong>: široká sada funkcí pro zjišťování
stavu různých hardwarových senzorů, kterými může být počítač (častěji
telefon) vybaven. To zahrnuje kompas, akcelerometr, gyroskop, čidlo
osvětlení, stav baterie a další.</p></li>
<li><p><strong>Clipboard</strong>: přístup (čtení i zápis) k schránce
operačního systému.</p></li>
<li><p><strong>Web Speech</strong>: převod textu na řeč, rozpoznávání
textu.</p></li>
<li><p><strong>Web Workers</strong>: podpora pro vykonávání
JavaScriptového kódu ve více opravdových vláknech.</p></li>
<li><p><strong>Web Sockets / SSE / WebRTC</strong>: alternativní
protokoly pro přenos dat tam, kde HTTP nestačí.</p></li>
<li><p><strong>Bluetooth / Web Serial</strong>: pro přístup k zařízením
připojeným pomocí bluetooth či (virtuálního) sériového portu.</p></li>
</ul>
<p>Z výčtu jsou záměrně vypuštěna dvě rozhraní, určená pro práci
s grafikou (SVG a Canvas). To proto, že se jim budeme věnovat v dalších
kapitolách.</p>
<h1 id="html-canvas">HTML Canvas</h1>
<h2 id="úloha-9">Úloha</h2>
<p>Rádi bychom uživatelům, kteří se na našem webu zaregistrují, dovolili
nahrát profilový obrázek. Tento se bude zobrazovat vedle jejich jména
u diskuzních příspěvků a dalších aktivit. Protože se bude zobrazovat
malý, není vhodné, aby nám uživatelé nahrávali své portréty ve velkém
rozlišení. Proto obrázek před nahráním zmenšete tak, aby jeho delší
strana nepřesahovala zadaný limit (např. 1000 pixelů).</p>
<h3 id="řešení-9">Řešení</h3>
<div class="sourceCode" id="cb144"><pre
class="sourceCode html"><code class="sourceCode html"><span id="cb144-1"><a href="#cb144-1" aria-hidden="true" tabindex="-1"></a><span class="co">&lt;!-- kapitola-11.html --&gt;</span></span>
<span id="cb144-2"><a href="#cb144-2" aria-hidden="true" tabindex="-1"></a><span class="dt">&lt;</span><span class="kw">input</span> <span class="er">type</span><span class="ot">=</span><span class="st">&quot;file&quot;</span> <span class="er">accept</span><span class="ot">=</span><span class="st">&quot;image/*&quot;</span> <span class="dt">/&gt;</span></span>
<span id="cb144-3"><a href="#cb144-3" aria-hidden="true" tabindex="-1"></a><span class="dt">&lt;</span><span class="kw">script</span> <span class="er">src</span><span class="ot">=</span><span class="st">&quot;kapitola-11.js&quot;</span><span class="dt">&gt;&lt;/</span><span class="kw">script</span><span class="dt">&gt;</span></span></code></pre></div>
<div class="sourceCode" id="cb145"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb145-1"><a href="#cb145-1" aria-hidden="true" tabindex="-1"></a><span class="co">// kapitola-11.js</span></span>
<span id="cb145-2"><a href="#cb145-2" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> MAX <span class="op">=</span> <span class="dv">1000</span><span class="op">;</span></span>
<span id="cb145-3"><a href="#cb145-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb145-4"><a href="#cb145-4" aria-hidden="true" tabindex="-1"></a><span class="kw">async</span> <span class="kw">function</span> <span class="fu">loadImage</span>(file) {</span>
<span id="cb145-5"><a href="#cb145-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> img <span class="op">=</span> <span class="kw">new</span> <span class="fu">Image</span>()<span class="op">;</span></span>
<span id="cb145-6"><a href="#cb145-6" aria-hidden="true" tabindex="-1"></a>  img<span class="op">.</span><span class="at">src</span> <span class="op">=</span> URL<span class="op">.</span><span class="fu">createObjectURL</span>(file)<span class="op">;</span></span>
<span id="cb145-7"><a href="#cb145-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">await</span> img<span class="op">.</span><span class="fu">decode</span>()<span class="op">;</span></span>
<span id="cb145-8"><a href="#cb145-8" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> img<span class="op">;</span></span>
<span id="cb145-9"><a href="#cb145-9" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb145-10"><a href="#cb145-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb145-11"><a href="#cb145-11" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">resizeImage</span>(img) {</span>
<span id="cb145-12"><a href="#cb145-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">const</span> { width<span class="op">,</span> height } <span class="op">=</span> img<span class="op">;</span></span>
<span id="cb145-13"><a href="#cb145-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> scale <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span>(width<span class="op">/</span>MAX<span class="op">,</span> height<span class="op">/</span>MAX<span class="op">,</span> <span class="dv">1</span>)<span class="op">;</span></span>
<span id="cb145-14"><a href="#cb145-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> canvas <span class="op">=</span> <span class="bu">document</span><span class="op">.</span><span class="fu">createElement</span>(<span class="st">&quot;canvas&quot;</span>)<span class="op">;</span></span>
<span id="cb145-15"><a href="#cb145-15" aria-hidden="true" tabindex="-1"></a>  canvas<span class="op">.</span><span class="at">width</span> <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">round</span>(width <span class="op">/</span> scale)<span class="op">;</span></span>
<span id="cb145-16"><a href="#cb145-16" aria-hidden="true" tabindex="-1"></a>  canvas<span class="op">.</span><span class="at">height</span> <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">round</span>(height <span class="op">/</span> scale)<span class="op">;</span></span>
<span id="cb145-17"><a href="#cb145-17" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> ctx <span class="op">=</span> canvas<span class="op">.</span><span class="fu">getContext</span>(<span class="st">&quot;2d&quot;</span>)<span class="op">;</span></span>
<span id="cb145-18"><a href="#cb145-18" aria-hidden="true" tabindex="-1"></a>  ctx<span class="op">.</span><span class="fu">drawImage</span>(img<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> canvas<span class="op">.</span><span class="at">width</span><span class="op">,</span> canvas<span class="op">.</span><span class="at">height</span>)<span class="op">;</span></span>
<span id="cb145-19"><a href="#cb145-19" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> canvas<span class="op">.</span><span class="fu">toDataURL</span>(<span class="st">&quot;image/jpeg&quot;</span>)<span class="op">;</span></span>
<span id="cb145-20"><a href="#cb145-20" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb145-21"><a href="#cb145-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb145-22"><a href="#cb145-22" aria-hidden="true" tabindex="-1"></a><span class="kw">async</span> <span class="kw">function</span> <span class="fu">onChange</span>(e) {</span>
<span id="cb145-23"><a href="#cb145-23" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> file <span class="op">=</span> e<span class="op">.</span><span class="at">target</span><span class="op">.</span><span class="at">files</span>[<span class="dv">0</span>]<span class="op">;</span></span>
<span id="cb145-24"><a href="#cb145-24" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (<span class="op">!</span>file) <span class="cf">return</span><span class="op">;</span></span>
<span id="cb145-25"><a href="#cb145-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb145-26"><a href="#cb145-26" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> sourceImage <span class="op">=</span> <span class="cf">await</span> <span class="fu">loadImage</span>(file)<span class="op">;</span></span>
<span id="cb145-27"><a href="#cb145-27" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> targetImage <span class="op">=</span> <span class="fu">resizeImage</span>(sourceImage)<span class="op">;</span></span>
<span id="cb145-28"><a href="#cb145-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb145-29"><a href="#cb145-29" aria-hidden="true" tabindex="-1"></a>  <span class="fu">fetch</span>(<span class="st">&quot;/upload&quot;</span><span class="op">,</span> {</span>
<span id="cb145-30"><a href="#cb145-30" aria-hidden="true" tabindex="-1"></a>    <span class="dt">method</span><span class="op">:</span> <span class="st">&quot;POST&quot;</span><span class="op">,</span></span>
<span id="cb145-31"><a href="#cb145-31" aria-hidden="true" tabindex="-1"></a>    <span class="dt">body</span><span class="op">:</span> targetImage</span>
<span id="cb145-32"><a href="#cb145-32" aria-hidden="true" tabindex="-1"></a>  })<span class="op">;</span></span>
<span id="cb145-33"><a href="#cb145-33" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb145-34"><a href="#cb145-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb145-35"><a href="#cb145-35" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> input <span class="op">=</span> <span class="bu">document</span><span class="op">.</span><span class="fu">querySelector</span>(<span class="st">&quot;[type=file]&quot;</span>)<span class="op">;</span></span>
<span id="cb145-36"><a href="#cb145-36" aria-hidden="true" tabindex="-1"></a>input<span class="op">.</span><span class="fu">addEventListener</span>(<span class="st">&quot;change&quot;</span><span class="op">,</span> onChange)<span class="op">;</span></span></code></pre></div>
<p>Přestože vzorové řešení má jen kolem třiceti řádků, obsahuje řadu
novinek. Pro snazší pochopení si úlohu rozdělíme na tři menší části:
získání obrazových dat z disku uživatele, zmenšení a následné nahrání na
server.</p>
<h3 id="načtení-obrázku">Načtení obrázku</h3>
<p>V klientském JavaScriptu nelze přistupovat k libovolným souborům na
disku uživatele. Představovalo by to značné bezpečnostní riziko, neboť
při návštěvě webové stránky by cizí skript mohl snadno číst naše citlivá
data a následně je například posílat na server útočníka. Panuje proto
pravidlo, že prohlížeč zpřístupní obsah jen takových souborů, které za
tímto účelem uživatel explicitně označil. Možnosti jsou dvě: buď takový
soubor uživatel myší přetáhl z plochy operačního systému do okna
prohlížeče, nebo nějaký soubor vybral prostřednictvím formulářového
prvku <code>&lt;input type=file&gt;</code>.</p>
<p>Druhá možnost je o něco přímočařejší a také častější, takže ji
využijeme pro vzorové řešení. Atributem <code>accept</code> omezíme typ
použitelných souborů, takže následně nemusíme uvažovat variantu, kdy by
uživatel vybral soubor, který vůbec není obrázek. Po vybrání souboru
vznikne událost <code>change</code>, a tím dojde k vykonání posluchače
<code>onChange</code>. Vlastnost <code>files</code> HTML prvku
<code>&lt;input&gt;</code> v takové chvíli obsahuje pole vybraných
souborů (víc by jich mohlo být, pokud bychom použili atribut
<code>multiple</code>). Jedná se o proměnné typu <code>File</code> –
s takovým objektem jsme se zatím nesetkali.</p>
<p>Objekt <code>File</code> slouží k přístupu k souboru, ale nedovoluje
nám přímo získat jeho obsah. S proměnnou tohoto typu můžeme provádět
následující hlavní operace:</p>
<ol type="1">
<li><p>Můžeme ji předat funkci <code>fetch</code>, a tím obsah souboru
nahrát. To dělat nechceme, protože bychom nahrávali originální obrázek,
který může být příliš velký.</p></li>
<li><p>Můžeme použít objekt <code>FileReader</code>, prostřednictvím
kterého bychom se dostali k obsahu souboru (jednotlivým bajtům). To
vypadá užitečně, ale jedná se o příliš nízkoúrovňový přístup. Museli
bychom v JavaScriptu implementovat dekódování obrazového formátu (JPEG,
PNG, GIF, …), což je zbytečně složité a pracné.</p></li>
<li><p>Protože víme, že vybraný soubor odpovídá obrázku, můžeme jej
využít k vytvoření HTML prvku <code>&lt;img&gt;</code>. Ten je vhodný
pro následné zmenšování.</p></li>
</ol>
<p>HTML značka <code>&lt;img&gt;</code> ovšem vyžaduje URL, které
nemáme. Naštěstí existuje šikovná a nepříliš známá funkce
<code>URL.createObjectURL</code>, která slouží právě k tomuto účelu. Pro
předaný objekt typu <code>File</code> vytvoří speciální dočasné URL,
které můžeme až do zavření stránky používat tam, kde je URL očekáváno.
V našem případě ho předáme do atributu <code>src</code> nově vytvořeného
obrázku.</p>
<p>Ještě než začneme tento obrázek zpracovávat, musíme počkat, než jej
prohlížeč načte (teprve potom budou například známy jeho rozměry).
Načtení obrázku je asynchronní proces a máme dva způsoby, jak s ním
pracovat:</p>
<ol type="1">
<li><p>Počkáme na událost <code>load</code>. To by znamenalo přidání
posluchače a zabalení následného kódu do vlastní funkce. Bude to
fungovat, ale existuje snazší řešení.</p></li>
<li><p>Použijeme relativně moderní metodu <code>decode()</code>, která
taktéž čeká na načtení a vrací Promise. To je pro náš případ
ideální.</p></li>
</ol>
<h3 id="změna-rozměrů">Změna rozměrů</h3>
<p>Uživatelem vybraný soubor máme nyní načtený v HTML obrázku. Jeho
rozměry můžeme získat dvěma způsoby:</p>
<ol type="1">
<li><p>Pomocí vlastností <code>naturalWidth</code>
a <code>naturalHeight</code>. Ty obsahují původní rozměr obrázku
v pixelech tak, jak jsou obsaženy v souboru.</p></li>
<li><p>Pomocí vlastností <code>width</code> a <code>height</code>. Ty
odpovídají rozměrům obrázku při jeho vykreslení. V takovou chvíli může
být velikost ovlivněna HTML atributy nebo CSS vlastnostmi, proto je
tento způsob zjišťování rozměrů méně spolehlivý. Pokud ovšem obrázek
není součástí stromu stránky, hodnoty <code>width</code>
a <code>height</code> odpovídají těm původním (a shodují se tedy s výše
představenými vlastnostmi <code>naturalWidth</code>
a <code>naturalHeight</code>). To je náš případ, a proto sáhneme po
těchto kratších názvech.</p></li>
</ol>
<p>Zvídavý čtenář si možná povšiml nezvyklého přístupu k vlastnostem
obrázku. Použili jsme syntaxi, která se nazývá
<strong>destructuring</strong>:</p>
<div class="sourceCode" id="cb146"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb146-1"><a href="#cb146-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> { width<span class="op">,</span> height } <span class="op">=</span> img<span class="op">;</span></span></code></pre></div>
<p>Tento zápis, při kterém se kolem definovaných proměnných píšou
složené (nebo hranaté) závorky, odpovídá následujícímu kódu:</p>
<div class="sourceCode" id="cb147"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb147-1"><a href="#cb147-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> width <span class="op">=</span> img<span class="op">.</span><span class="at">width</span><span class="op">;</span></span>
<span id="cb147-2"><a href="#cb147-2" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> height <span class="op">=</span> img<span class="op">.</span><span class="at">height</span><span class="op">;</span></span></code></pre></div>
<p>Destructuring nám dovoluje ušetřit trochu místa ve chvíli, kdy
vytváříme nové proměnné ze stejně pojmenovaných vlastností objektu na
pravé straně rovnítka. Použít jej můžeme taktéž, pokud do proměnných
obdobným způsobem <em>vybalujeme</em> položky z pole.</p>
<p>K výpočtu cílových rozměrů si dále nachystáme
<strong>měřítko</strong>: číselnou hodnotu, která říká, kolikrát je
nutné obrázek zmenšit. Protože chceme zachovat původní poměr stran,
budeme oba rozměry zmenšovat stejně. Měřítko definujeme tímto
vzorcem:</p>
<div class="sourceCode" id="cb148"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb148-1"><a href="#cb148-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> scale <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span>(width<span class="op">/</span>MAX<span class="op">,</span> height<span class="op">/</span>MAX<span class="op">,</span> <span class="dv">1</span>)<span class="op">;</span></span></code></pre></div>
<p>První parametr funkce <code>max</code> říká, <em>kolikrát je šířka
obrázku větší, než požadovaný limit</em>. Druhý parametr funguje shodně,
jen pro výšku. Z těchto hodnot bereme maximum, neboť v zadání je
požadováno takové zmenšení, po kterém budou obě strany menší nebo rovny
limitu.</p>
<p>Jednička na konci je malý trik: mohlo by se stát, že by nám uživatel
nahrál obrázek, jehož oba rozměry jsou menší než náš zmenšovací limit.
Měřítko by pak bylo menší než jedna a při následné transformaci bychom
proto obrázek <em>zvětšili</em>. To je zbytečné a nežádoucí, takže pro
malé obrázky zvolíme měřítko rovno jedné, a tím pádem zachováme jejich
původní velikost.</p>
<p>Nové rozměry pak vypočítáme jako ty původní vydělené měřítkem. V tuto
chvíli nám již ovšem nestačí HTML obrázky. I kdybychom jim nastavovali
menší rozměry, prohlížeč provede zmenšení jen pro potřeby zobrazení.
Nahraná obrazová data budou stále v původním rozlišení. Proto využijeme
HTML značku <code>&lt;canvas&gt;</code>, která představuje univerzální
nástroj pro tvorbu a manipulaci s rastrovými obrazovými daty.</p>
<p>Prvek <code>&lt;canvas&gt;</code> (anglické označení pro malířské
plátno) je sice součástí jazyka HTML, ale pracujeme s ním výhradně
pomocí JavaScriptových funkcí a vlastností. A že jich je! Zatím si
ukážeme jen úplný základ práce s canvasem, ale v následujících
podkapitolách prozkoumáme i další jeho možnosti.</p>
<p>Naše plátno potřebuje především nastavit rozměry. K tomu použijeme
výše zmíněný výpočet:</p>
<div class="sourceCode" id="cb149"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb149-1"><a href="#cb149-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> canvas <span class="op">=</span> <span class="bu">document</span><span class="op">.</span><span class="fu">createElement</span>(<span class="st">&quot;canvas&quot;</span>)<span class="op">;</span></span>
<span id="cb149-2"><a href="#cb149-2" aria-hidden="true" tabindex="-1"></a>canvas<span class="op">.</span><span class="at">width</span> <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">round</span>(width <span class="op">/</span> scale)<span class="op">;</span></span>
<span id="cb149-3"><a href="#cb149-3" aria-hidden="true" tabindex="-1"></a>canvas<span class="op">.</span><span class="at">height</span> <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">round</span>(height <span class="op">/</span> scale)<span class="op">;</span></span></code></pre></div>
<p>Canvas odpovídá obdélníku pixelů, proto je potřeba jeho rozměry
nastavovat v celých čísel. Měřítko i výsledek dělení mohou být čísla
desetinná, takže je na celé pixely musíme zaokrouhlit.</p>
<p>Funkce, které canvas nabízí, jsou v rámci jeho JS API seskupeny do
tzv. <em>kontextů</em> – JavaScriptových objektů specializovaných pro
různé vykreslovací operace. Pro naši úlohu je vhodný kontext nazvaný
prostě <code>2d</code>. Ten dovoluje takové operace, které známe
například z programu Malování ve Windows: tah štětcem, vyplňování
plochy, vkládání obrázků a podobně. Čistě teoretickým příkladem dalšího
kontextu může být <code>webgl</code>, což je vysoce specializované
rozhraní určené pro vykreslování pomocí akcelerované grafiky
prostřednictvím jazyka OpenGL. S takto pokročilými technikami se ovšem
v této knize nesetkáme.</p>
<p>Metoda <code>drawImage</code> patří dvourozměrnému kontextu a má řadu
různých signatur. Prvním parametrem je zdrojový obrázek, další dva
parametry definují cílové souřadnice (místo, na kterém v canvasu
vykreslíme levý horní roh obrázku) a nejdůležitější jsou poslední dva
parametry – cílové rozměry. Právě díky nim prohlížeč vykreslí původní
obrázek do canvasu zmenšený.</p>
<p>Celá tato zmenšovací operace nás stojí jen dva řádky kódu:</p>
<div class="sourceCode" id="cb150"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb150-1"><a href="#cb150-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> ctx <span class="op">=</span> canvas<span class="op">.</span><span class="fu">getContext</span>(<span class="st">&quot;2d&quot;</span>)<span class="op">;</span></span>
<span id="cb150-2"><a href="#cb150-2" aria-hidden="true" tabindex="-1"></a>ctx<span class="op">.</span><span class="fu">drawImage</span>(img<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> canvas<span class="op">.</span><span class="at">width</span><span class="op">,</span> canvas<span class="op">.</span><span class="at">height</span>)<span class="op">;</span></span></code></pre></div>
<h3 id="nahrání-obrázku">Nahrání obrázku</h3>
<p>Máme skoro hotovo! Zmenšili jsme portrét, jen ho teď nemáme v HTML
obrázku, ale v HTML canvasu. A ten nelze sám o sobě vzít a nahrát na
server. Mimo jiné proto, že canvas představuje dvourozměrné pole pixelů,
ale soubory obsahují obrazová data v nějakém formátu. Musíme proto
prohlížeč nejprve požádat, aby obrazová data z canvasu vhodně
zakódoval.</p>
<p>Canvas pro tyto účely disponuje dvěma metodami, které dělají
v podstatě to samé: <code>toDataURL</code> a <code>toBlob</code>. Liší
se takto:</p>
<ul>
<li><p>Metoda <code>toBlob</code> je asynchronní (přijímá callback)
a produkuje objekt typu <code>Blob</code>, který zastřešuje výsledná
binární data. Můžeme jej předat funkci <code>fetch</code> a odeslat na
server. Tato metoda představuje výkonnější řešení: je úsporná a díky
asynchronnosti neblokuje hlavní vlákno.</p></li>
<li><p>Metoda <code>toDataURL</code> je synchronní a její návratová
hodnota je tzv. <strong>data URI:</strong> řetězec ve tvaru podobném
URL, obsahující zakódovaná obrazová data. Můžeme jej použít všude, kde
je očekáváno URL (podobně jako výsledek volání
<code>URL.createObjectURL</code>). Takový řetězec můžeme samozřejmě
taktéž nahrát na server. Kromě blokování hlavního vlákna je další
nevýhoda metody <code>toDataURL</code> v tom, že výsledný řetězec
obsahuje jednotlivé bajty zapsané pomocí <em>kódování Base64</em>. V něm
se používají pouze tištitelné znaky, čimž datový objem naroste zhruba
o třetinu.</p></li>
</ul>
<p>Pro jednoduchost ve vzorovém řešení použijeme <code>toDataURL</code>.
Jejím parametrem je identifikace obrazového formátu, do kterého chceme
obrázek zakódovat:</p>
<div class="sourceCode" id="cb151"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb151-1"><a href="#cb151-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">resizeImage</span>(img) {</span>
<span id="cb151-2"><a href="#cb151-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">// tvorba canvasu viz výše</span></span>
<span id="cb151-3"><a href="#cb151-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> canvas<span class="op">.</span><span class="fu">toDataURL</span>(<span class="st">&quot;image/jpeg&quot;</span>)<span class="op">;</span></span>
<span id="cb151-4"><a href="#cb151-4" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb151-5"><a href="#cb151-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb151-6"><a href="#cb151-6" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> targetImage <span class="op">=</span> <span class="fu">resizeImage</span>(sourceImage)<span class="op">;</span></span></code></pre></div>
<p>V porovnání s minulými kapitolami potřebujeme na server odeslat
značné množství dat. Musíme proto použít HTTP metodu <code>POST</code>
a data umístit do těla požadavku. V případě funkce <code>fetch</code> je
to jen otázka konfiguračních parametrů <code>method</code>
a <code>body</code>:</p>
<div class="sourceCode" id="cb152"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb152-1"><a href="#cb152-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fetch</span>(<span class="st">&quot;/upload&quot;</span><span class="op">,</span> {</span>
<span id="cb152-2"><a href="#cb152-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">method</span><span class="op">:</span> <span class="st">&quot;POST&quot;</span><span class="op">,</span></span>
<span id="cb152-3"><a href="#cb152-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">body</span><span class="op">:</span> targetImage</span>
<span id="cb152-4"><a href="#cb152-4" aria-hidden="true" tabindex="-1"></a>})<span class="op">;</span></span></code></pre></div>
<p>Tím jsme na server poslali data zmenšeného zakódovaného obrázku.</p>
<h3 id="co-jsme-se-naučili-8">Co jsme se naučili</h3>
<p>Po vyřešení desáté úlohy by měl čtenář chápat a ovládat:</p>
<ul>
<li><p>možnosti přístupu k datům uživatelem vybraného souboru</p></li>
<li><p>využití HTML canvasu pro zmenšení obrázku</p></li>
<li><p>získání obrazových dat z canvasu ve formátu vhodném k odeslání po
síti</p></li>
</ul>
<h2 id="zelenáči-další-dovednosti-canvasu">Zelenáči: další dovednosti
canvasu</h2>
<p>HTML značka <code>&lt;canvas&gt;</code> je univerzální kreslicí
plocha. Ukázali jsme, jak do ní přenést obrázek ze značky
<code>&lt;img&gt;</code>; nyní přišel čas vyzkoušet další metody, které
2d-kontext nabízí. Abychom nemalovali jen tak nahodile, vyřešíme
skutečnou úlohu, ke které lze canvas použít – ukazatel načítání.</p>
<p>Předpokládejme, že provádíme operaci, která trvá delší dobu. Může jít
třeba o nahrávání profilového obrázku nebo čekání na nějaká data ze
serveru. Když se jedná o aktivitu na pozadí, uživatel nemá žádné
informace o její existenci případně průběhu. Bývá proto obvyklé, že
síťovou komunikaci nějakým nenápadným způsobem vizualizujeme. Sestavme
animaci, která představuje postupně se zvětšující kruhovou výseč (zelené
barvy). Abychom nemuseli vymýšlet, kam takový obrázek umístit, zobrazíme
ho v záhlaví záložky prohlížeče vedle titulku stránky – uděláme z tohoto
obrázku tzv. <strong>favikonku.</strong></p>
<p>Favikonky jsou malé obrázky, které k HTML dokumentu připojujeme
pomocí značky <code>&lt;meta&gt;</code> v hlavičce stránky. Typicky to
vypadá takto:</p>
<div class="sourceCode" id="cb153"><pre
class="sourceCode html"><code class="sourceCode html"><span id="cb153-1"><a href="#cb153-1" aria-hidden="true" tabindex="-1"></a><span class="dt">&lt;</span><span class="kw">meta</span> <span class="er">rel</span><span class="ot">=</span><span class="st">&quot;icon&quot;</span> <span class="er">href</span><span class="ot">=</span><span class="st">&quot;ikonka.png&quot;</span> <span class="dt">/&gt;</span></span></code></pre></div>
<p>Nic nám ale nebrání takovou favikonku vyrobit pomocí JavaScriptu.
Jakmile pro ni dokážeme sestavit URL, můžeme jej použít pro změnu
atributu <code>href</code> u značky <code>&lt;link&gt;</code>.</p>
<p>Začneme tím, že si nachystáme malý čtvercový canvas. Pro rozměry
vytvoříme konstantu:</p>
<div class="sourceCode" id="cb154"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb154-1"><a href="#cb154-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> SIZE <span class="op">=</span> <span class="dv">32</span><span class="op">;</span></span>
<span id="cb154-2"><a href="#cb154-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> canvas <span class="op">=</span> <span class="bu">document</span><span class="op">.</span><span class="fu">createElement</span>(<span class="st">&quot;canvas&quot;</span>)<span class="op">;</span></span>
<span id="cb154-3"><a href="#cb154-3" aria-hidden="true" tabindex="-1"></a>canvas<span class="op">.</span><span class="at">width</span> <span class="op">=</span> canvas<span class="op">.</span><span class="at">height</span> <span class="op">=</span> SIZE<span class="op">;</span></span>
<span id="cb154-4"><a href="#cb154-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> ctx <span class="op">=</span> canvas<span class="op">.</span><span class="fu">getContext</span>(<span class="st">&quot;2d&quot;</span>)<span class="op">;</span></span></code></pre></div>
<p>Malování obstará funkce, která pomocí metod kontextu <code>ctx</code>
vytvoří požadovaný útvar. Ta bude muset znát úhel (velikost výseče).
Proto si nachystáme kód, který bude v čase úhel měnit a periodicky
kreslicí funkci vykonávat:</p>
<div class="sourceCode" id="cb155"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb155-1"><a href="#cb155-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> angle <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb155-2"><a href="#cb155-2" aria-hidden="true" tabindex="-1"></a><span class="pp">setInterval</span>(() <span class="kw">=&gt;</span> {</span>
<span id="cb155-3"><a href="#cb155-3" aria-hidden="true" tabindex="-1"></a>  angle <span class="op">=</span> (angle <span class="op">+</span> <span class="fl">0.1</span>) <span class="op">%</span> (<span class="dv">2</span> <span class="op">*</span> <span class="bu">Math</span><span class="op">.</span><span class="cn">PI</span>)<span class="op">;</span></span>
<span id="cb155-4"><a href="#cb155-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">draw</span>(angle)<span class="op">;</span></span>
<span id="cb155-5"><a href="#cb155-5" aria-hidden="true" tabindex="-1"></a>}<span class="op">,</span> <span class="dv">100</span>)<span class="op">;</span></span></code></pre></div>
<p>V počítačové grafice bývají úhly zpravidla specifikovány pomocí
radiánů. V tomto kódu každých 100 milisekund zvětšíme úhel o 0,1
radiánu. Hodnotu ještě upravíme operátorem procenta (zbytek po dělení)
tak, aby nikdy nepřesáhla <strong>2π</strong>, tj. celý kruh. To
znamená, že jakmile vykreslíme kruh, začneme znovu od začátku úzkou
výsečí od nuly.</p>
<p>Zbývá naimplementovat kreslení ve funkci <code>draw</code>. HTML
canvas je zajímavý tím, že jakmile do něj nějaká data vykreslíme, už je
zpětně nemůžeme měnit. Animaci tedy realizujeme tak, že canvas nejprve
zcela vyprázdníme, a pak do něj vykreslíme nový snímek dle aktuálního
stavu. Pro vymazání existuje metoda <code>clearRect</code>, které
předáme souřadnice (a rozměry) obdélníkové oblasti, kterou chceme
vymazat. V našem případě je to celý canvas:</p>
<div class="sourceCode" id="cb156"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb156-1"><a href="#cb156-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">draw</span>(angle) {</span>
<span id="cb156-2"><a href="#cb156-2" aria-hidden="true" tabindex="-1"></a>  ctx<span class="op">.</span><span class="fu">clearRect</span>(<span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> SIZE<span class="op">,</span> SIZE)<span class="op">;</span></span>
<span id="cb156-3"><a href="#cb156-3" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Kruhovou výseč vytvoříme pomocí operace, která odpovídá tažení
virtuálním štětcem po plátně. Sestává z těchto kroků:</p>
<ol type="1">
<li><p>posun štětce doprostřed plátna</p></li>
<li><p>čára doprava</p></li>
<li><p>kruhový oblouk o délce úměrné požadovanému úhlu</p></li>
<li><p>čára zpět do středu</p></li>
<li><p>vyplnění vzniklé oblasti barvou</p></li>
</ol>
<p>Náš kontext nabízí metody přesně pro tyto kroky:</p>
<div class="sourceCode" id="cb157"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb157-1"><a href="#cb157-1" aria-hidden="true" tabindex="-1"></a>ctx<span class="op">.</span><span class="fu">beginPath</span>()<span class="op">;</span></span>
<span id="cb157-2"><a href="#cb157-2" aria-hidden="true" tabindex="-1"></a>ctx<span class="op">.</span><span class="fu">moveTo</span>(SIZE<span class="op">/</span><span class="dv">2</span><span class="op">,</span> SIZE<span class="op">/</span><span class="dv">2</span>)<span class="op">;</span></span>
<span id="cb157-3"><a href="#cb157-3" aria-hidden="true" tabindex="-1"></a>ctx<span class="op">.</span><span class="fu">lineTo</span>(SIZE<span class="op">,</span> SIZE<span class="op">/</span><span class="dv">2</span>)<span class="op">;</span></span>
<span id="cb157-4"><a href="#cb157-4" aria-hidden="true" tabindex="-1"></a>ctx<span class="op">.</span><span class="fu">arc</span>(SIZE<span class="op">/</span><span class="dv">2</span><span class="op">,</span> SIZE<span class="op">/</span><span class="dv">2</span><span class="op">,</span> SIZE<span class="op">/</span><span class="dv">2</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> angle)<span class="op">;</span></span>
<span id="cb157-5"><a href="#cb157-5" aria-hidden="true" tabindex="-1"></a>ctx<span class="op">.</span><span class="fu">closePath</span>()<span class="op">;</span></span>
<span id="cb157-6"><a href="#cb157-6" aria-hidden="true" tabindex="-1"></a>ctx<span class="op">.</span><span class="at">fillStyle</span> <span class="op">=</span> <span class="st">&quot;green&quot;</span><span class="op">;</span></span>
<span id="cb157-7"><a href="#cb157-7" aria-hidden="true" tabindex="-1"></a>ctx<span class="op">.</span><span class="fu">fill</span>()<span class="op">;</span></span></code></pre></div>
<p>Jediné komplikované místo je metoda <code>arc</code>, která vytváří
kruhový oblouk. Ten vyžaduje mnoho parametrů: dvě souřadnice středu
kruhu, poloměr, počáteční úhel (nula odpovídá bodu na kružnici nejvíc
vpravo) a cílový úhel.</p>
<p>Za zmínku ještě stojí nastavení barvy výplně. Stejně jako v programu
Malování, i zde provádíme nastavení barvy (vlastnost
<code>fillStyle</code>) nezávisle na následném kreslení (metoda
<code>fill</code>). Ve chvíli vykreslení se pak použije aktuálně
nastavená barva. Znamená to, že změnu barvy můžeme provést kdykoliv před
vykreslením, ale nikdy až poté.</p>
<p>V tuto chvíli máme v canvasu hotový obrázek. Zbývá z něj vytvořit URL
(to umíme z první části této kapitoly) a nastavit jej prvku
<code>&lt;meta&gt;</code>:</p>
<div class="sourceCode" id="cb158"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb158-1"><a href="#cb158-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> link <span class="op">=</span> <span class="bu">document</span><span class="op">.</span><span class="at">head</span><span class="op">.</span><span class="fu">querySelector</span>(<span class="st">&quot;[rel=icon]&quot;</span>)<span class="op">;</span></span>
<span id="cb158-2"><a href="#cb158-2" aria-hidden="true" tabindex="-1"></a>link<span class="op">.</span><span class="at">href</span> <span class="op">=</span> canvas<span class="op">.</span><span class="fu">toDataURL</span>(<span class="st">&quot;image/png&quot;</span>)<span class="op">;</span></span></code></pre></div>
<p>Výsledný kód pak celý vypadá například takto:</p>
<div class="sourceCode" id="cb159"><pre
class="sourceCode html"><code class="sourceCode html"><span id="cb159-1"><a href="#cb159-1" aria-hidden="true" tabindex="-1"></a><span class="co">&lt;!-- kapitola-11-zelenaci.html --&gt;</span></span>
<span id="cb159-2"><a href="#cb159-2" aria-hidden="true" tabindex="-1"></a><span class="dt">&lt;!doctype </span>html<span class="dt">&gt;</span></span>
<span id="cb159-3"><a href="#cb159-3" aria-hidden="true" tabindex="-1"></a><span class="dt">&lt;</span><span class="kw">html</span><span class="dt">&gt;</span></span>
<span id="cb159-4"><a href="#cb159-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&lt;</span><span class="kw">head</span><span class="dt">&gt;&lt;</span><span class="kw">link</span> <span class="er">rel</span><span class="ot">=</span><span class="st">&quot;icon&quot;</span> <span class="dt">/&gt;&lt;/</span><span class="kw">head</span><span class="dt">&gt;</span></span>
<span id="cb159-5"><a href="#cb159-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&lt;</span><span class="kw">script</span><span class="dt">&gt;</span></span>
<span id="cb159-6"><a href="#cb159-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb159-7"><a href="#cb159-7" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> canvas <span class="op">=</span> <span class="bu">document</span><span class="op">.</span><span class="fu">createElement</span>(<span class="st">&quot;canvas&quot;</span>)<span class="op">;</span></span>
<span id="cb159-8"><a href="#cb159-8" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> SIZE <span class="op">=</span> <span class="dv">32</span><span class="op">;</span></span>
<span id="cb159-9"><a href="#cb159-9" aria-hidden="true" tabindex="-1"></a>canvas<span class="op">.</span><span class="at">width</span> <span class="op">=</span> canvas<span class="op">.</span><span class="at">height</span> <span class="op">=</span> SIZE<span class="op">;</span></span>
<span id="cb159-10"><a href="#cb159-10" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> ctx <span class="op">=</span> canvas<span class="op">.</span><span class="fu">getContext</span>(<span class="st">&quot;2d&quot;</span>)<span class="op">;</span></span>
<span id="cb159-11"><a href="#cb159-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb159-12"><a href="#cb159-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb159-13"><a href="#cb159-13" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">draw</span>(angle) {</span>
<span id="cb159-14"><a href="#cb159-14" aria-hidden="true" tabindex="-1"></a>  ctx<span class="op">.</span><span class="fu">clearRect</span>(<span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> SIZE<span class="op">,</span> SIZE)<span class="op">;</span></span>
<span id="cb159-15"><a href="#cb159-15" aria-hidden="true" tabindex="-1"></a>  ctx<span class="op">.</span><span class="fu">beginPath</span>()<span class="op">;</span></span>
<span id="cb159-16"><a href="#cb159-16" aria-hidden="true" tabindex="-1"></a>  ctx<span class="op">.</span><span class="fu">moveTo</span>(SIZE<span class="op">/</span><span class="dv">2</span><span class="op">,</span> SIZE<span class="op">/</span><span class="dv">2</span>)<span class="op">;</span></span>
<span id="cb159-17"><a href="#cb159-17" aria-hidden="true" tabindex="-1"></a>  ctx<span class="op">.</span><span class="fu">lineTo</span>(SIZE<span class="op">,</span> SIZE<span class="op">/</span><span class="dv">2</span>)<span class="op">;</span></span>
<span id="cb159-18"><a href="#cb159-18" aria-hidden="true" tabindex="-1"></a>  ctx<span class="op">.</span><span class="fu">arc</span>(SIZE<span class="op">/</span><span class="dv">2</span><span class="op">,</span> SIZE<span class="op">/</span><span class="dv">2</span><span class="op">,</span> SIZE<span class="op">/</span><span class="dv">2</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> angle)<span class="op">;</span></span>
<span id="cb159-19"><a href="#cb159-19" aria-hidden="true" tabindex="-1"></a>  ctx<span class="op">.</span><span class="fu">closePath</span>()<span class="op">;</span></span>
<span id="cb159-20"><a href="#cb159-20" aria-hidden="true" tabindex="-1"></a>  ctx<span class="op">.</span><span class="at">fillStyle</span> <span class="op">=</span> <span class="st">&quot;green&quot;</span><span class="op">;</span></span>
<span id="cb159-21"><a href="#cb159-21" aria-hidden="true" tabindex="-1"></a>  ctx<span class="op">.</span><span class="fu">fill</span>()<span class="op">;</span></span>
<span id="cb159-22"><a href="#cb159-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb159-23"><a href="#cb159-23" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> link <span class="op">=</span> <span class="bu">document</span><span class="op">.</span><span class="at">head</span><span class="op">.</span><span class="fu">querySelector</span>(<span class="st">&quot;[rel=icon]&quot;</span>)<span class="op">;</span></span>
<span id="cb159-24"><a href="#cb159-24" aria-hidden="true" tabindex="-1"></a>  link<span class="op">.</span><span class="at">href</span> <span class="op">=</span> canvas<span class="op">.</span><span class="fu">toDataURL</span>(<span class="st">&quot;image/png&quot;</span>)<span class="op">;</span></span>
<span id="cb159-25"><a href="#cb159-25" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb159-26"><a href="#cb159-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb159-27"><a href="#cb159-27" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> angle <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb159-28"><a href="#cb159-28" aria-hidden="true" tabindex="-1"></a><span class="pp">setInterval</span>(() <span class="kw">=&gt;</span> {</span>
<span id="cb159-29"><a href="#cb159-29" aria-hidden="true" tabindex="-1"></a>  angle <span class="op">=</span> (angle <span class="op">+</span> <span class="fl">0.1</span>) <span class="op">%</span> (<span class="dv">2</span> <span class="op">*</span> <span class="bu">Math</span><span class="op">.</span><span class="cn">PI</span>)<span class="op">;</span></span>
<span id="cb159-30"><a href="#cb159-30" aria-hidden="true" tabindex="-1"></a>  <span class="fu">draw</span>(angle)<span class="op">;</span></span>
<span id="cb159-31"><a href="#cb159-31" aria-hidden="true" tabindex="-1"></a>}<span class="op">,</span> <span class="dv">100</span>)<span class="op">;</span></span>
<span id="cb159-32"><a href="#cb159-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb159-33"><a href="#cb159-33" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&lt;/</span><span class="kw">script</span><span class="dt">&gt;</span></span>
<span id="cb159-34"><a href="#cb159-34" aria-hidden="true" tabindex="-1"></a><span class="dt">&lt;/</span><span class="kw">html</span><span class="dt">&gt;</span></span></code></pre></div>
<h2 id="koumáci-obrazová-data-z-kamery-a-videa">Koumáci: obrazová data
z kamery a videa</h2>
<p>Zatím jsme ukázali, jak v canvasu vytvářet nový obsah a jak ho
z canvasu získat v podobě URL. Prohlížeče nabízí ještě další způsoby,
jak do canvasu dostat obrazová data – ovšem stále prostřednictvím metody
<code>drawImage</code>, kterou jsme si představili ve vzorovém
řešení.</p>
<p>Její první parametr specifikuje zdroj dat. Nemusí jít jen o obrázek;
může to být také jiný canvas nebo HTML značka
<code>&lt;video&gt;</code>. Pokud bychom tedy měli soubor s videem,
můžeme jej přehrávat prostřednictvím značky <code>&lt;video&gt;</code>,
její obsah pravidelně přenášet do canvasu a tam jej dle potřeby
zpracovávat. Je to docela snadné:</p>
<div class="sourceCode" id="cb160"><pre
class="sourceCode html"><code class="sourceCode html"><span id="cb160-1"><a href="#cb160-1" aria-hidden="true" tabindex="-1"></a><span class="dt">&lt;</span><span class="kw">video</span> <span class="er">src</span><span class="ot">=</span><span class="st">&quot;video.mp4&quot;</span><span class="dt">&gt;&lt;/</span><span class="kw">video</span><span class="dt">&gt;</span></span>
<span id="cb160-2"><a href="#cb160-2" aria-hidden="true" tabindex="-1"></a><span class="dt">&lt;</span><span class="kw">canvas</span><span class="dt">&gt;&lt;/</span><span class="kw">canvas</span><span class="dt">&gt;</span></span></code></pre></div>
<div class="sourceCode" id="cb161"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb161-1"><a href="#cb161-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">drawToCanvas</span>() {</span>
<span id="cb161-2"><a href="#cb161-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> video <span class="op">=</span> <span class="bu">document</span><span class="op">.</span><span class="fu">querySelector</span>(<span class="st">&quot;video&quot;</span>)<span class="op">;</span></span>
<span id="cb161-3"><a href="#cb161-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> canvas <span class="op">=</span> <span class="bu">document</span><span class="op">.</span><span class="fu">querySelector</span>(<span class="st">&quot;canvas&quot;</span>)<span class="op">;</span></span>
<span id="cb161-4"><a href="#cb161-4" aria-hidden="true" tabindex="-1"></a>  canvas<span class="op">.</span><span class="at">width</span> <span class="op">=</span> video<span class="op">.</span><span class="at">videoWidth</span><span class="op">;</span></span>
<span id="cb161-5"><a href="#cb161-5" aria-hidden="true" tabindex="-1"></a>  canvas<span class="op">.</span><span class="at">height</span> <span class="op">=</span> video<span class="op">.</span><span class="at">videoHeight</span><span class="op">;</span></span>
<span id="cb161-6"><a href="#cb161-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb161-7"><a href="#cb161-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> ctx <span class="op">=</span> canvas<span class="op">.</span><span class="fu">getContext</span>(<span class="st">&quot;2d&quot;</span>)<span class="op">;</span></span>
<span id="cb161-8"><a href="#cb161-8" aria-hidden="true" tabindex="-1"></a>  ctx<span class="op">.</span><span class="fu">drawImage</span>(video<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span>)<span class="op">;</span></span>
<span id="cb161-9"><a href="#cb161-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb161-10"><a href="#cb161-10" aria-hidden="true" tabindex="-1"></a>  <span class="fu">requestAnimationFrame</span>(drawToCanvas)<span class="op">;</span></span>
<span id="cb161-11"><a href="#cb161-11" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb161-12"><a href="#cb161-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb161-13"><a href="#cb161-13" aria-hidden="true" tabindex="-1"></a><span class="fu">drawToCanvas</span>()<span class="op">;</span></span></code></pre></div>
<p>Pro periodické vykonávání funkce <code>drawToCanvas</code> jsme
tentokrát zvolili jiný přístup než <code>setInterval</code>. Pokud
chceme opakovaně provádět operaci, která něco vykresluje do stránky, je
lepší použít funkci <code>requestAnimationFrame</code>. U ní neříkáme
časový krok, tj. <em>za jak dlouho má prohlížeč zadaný kód vykonat</em>.
Namísto toho necháváme prohlížeč, aby volil časový krok sám – s ohledem
na aktuální vytížení počítače, snímkovou frekvenci monitoru a další
faktory (pokud je například záložka s naším kódem neaktivní, uživatel
nic nevidí a prohlížeč může snížit frekvenci vykreslování).</p>
<p>Funkce <code>requestAnimationFrame</code> je, podobně jako
<code>setTimeout</code>, jednorázová. Musíme ji proto zavolat po každém
vykreslení (a naplánovat tak zase další krok). Vytváříme tím nepřímo
smyčku, kterou můžeme přerušit prostě tím, že přeskočíme další volání
<code>requestAnimationFrame</code>.</p>
<p>Vykreslování a zpracování jednotlivých snímků z HTML značky
<code>&lt;video&gt;</code> je zároveň základem pro přístup k datům
z kamery. Docílíme toho v několika fázích:</p>
<ol type="1">
<li><p>požádáme prohlížeč o tzv. <strong>stream</strong> (datový proud)
z kamery</p></li>
<li><p>prohlížeč požádá uživatele o svolení – jedná se o vysoce citlivá
data, takže uživatel musí vyjádřit souhlas</p></li>
<li><p>získaný stream použijeme jako zdroj dat pro značku
<code>&lt;video&gt;</code></p></li>
<li><p>obrazová data jednotlivých snímků získáme do canvasu stejně, jako
v minulé ukázce</p></li>
</ol>
<p>Přestože se dohromady jedná o spoustu práce, většinu z ní udělá
prohlížeč. My musíme v JavaScriptu nově jen vyvolat žádost o přístup ke
streamu. K tomu slouží funkce
<code>navigator.mediaDevices.getUserMedia</code> a její jediný parametr
upřesňuje, která všechna audio-vizuální data z kterých vstupů nás
zajímají. Můžeme zde poměrně detailně určit, jestli stojíme jen o obraz,
nebo i o zvuk; u obrazu definovat požadované rozlišení a dále třeba
prohlížeči naznačit, jestli má v případě mobilního telefonu použít
hlavní zadní kameru, nebo selfie-kameru umístěnou na přední straně
zařízení. V nejjednodušším případě si prostě vyžádáme libovolný zdroj
obrazu:</p>
<div class="sourceCode" id="cb162"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb162-1"><a href="#cb162-1" aria-hidden="true" tabindex="-1"></a><span class="cf">try</span> {</span>
<span id="cb162-2"><a href="#cb162-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> options <span class="op">=</span> {<span class="dt">video</span><span class="op">:</span> <span class="kw">true</span>}<span class="op">;</span></span>
<span id="cb162-3"><a href="#cb162-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> stream <span class="op">=</span> <span class="cf">await</span> <span class="bu">navigator</span><span class="op">.</span><span class="at">mediaDevices</span><span class="op">.</span><span class="fu">getUserMedia</span>(options)<span class="op">;</span></span>
<span id="cb162-4"><a href="#cb162-4" aria-hidden="true" tabindex="-1"></a>} <span class="cf">catch</span> (e) {</span>
<span id="cb162-5"><a href="#cb162-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">// není žádná kamera, případně uživatel nepovolil přístup</span></span>
<span id="cb162-6"><a href="#cb162-6" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Funkce je asynchronní a je pravděpodobné, že na její dokončení si
počkáme. Prohlížeč v tuto chvíli musí uživateli ukázat dialog, ve kterém
dojde nejen k odsouhlasení přístupu webové stránky ke kameře, ale také
k výběru konkrétní kamery, pokud jich je v zařízení dostupných více.
Proměnná <code>stream</code> pak bude obsahovat objekt typu
<code>MediaStream</code>, který použijeme jako zdroj dat pro
<code>&lt;video&gt;</code>:</p>
<div class="sourceCode" id="cb163"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb163-1"><a href="#cb163-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> video <span class="op">=</span> <span class="bu">document</span><span class="op">.</span><span class="fu">querySelector</span>(<span class="st">&quot;video&quot;</span>)<span class="op">;</span></span>
<span id="cb163-2"><a href="#cb163-2" aria-hidden="true" tabindex="-1"></a>video<span class="op">.</span><span class="at">srcObject</span> <span class="op">=</span> stream<span class="op">;</span></span>
<span id="cb163-3"><a href="#cb163-3" aria-hidden="true" tabindex="-1"></a>video<span class="op">.</span><span class="fu">play</span>()<span class="op">;</span></span></code></pre></div>
<p>Značku <code>&lt;video&gt;</code> v tomto případě vůbec nemusíme
ukazovat – je pro nás jen nezbytný spojovací článek mezi streamem
z kamery a canvasem, ve kterém výsledná data zobrazujeme
a upravujeme.</p>
<h2 id="profíci-kdy-s-canvasem-narazíme-a-jak-z-toho-ven">Profíci: kdy
s canvasem narazíme a jak z toho ven</h2>
<p>V této podkapitole si ukážeme některé zapeklité situace, na které
můžeme při práci s canvasem narazit. Jejich řešení je často snadné, ale
ne vždy na první pohled zřejmé.</p>
<h3 id="tainting">Tainting</h3>
<p>V páté kapitole jsme se dozvěděli, že v JavaScriptu není obecně možné
přistoupit k datům získaným z jiné domény, než je doména aktuální
stránky. Jedná se o mechanismus <strong>Same Origin Policy</strong>
a jeho hlavním účelem je ochrana proti útokům CSRF, tj. situacím, kdy
vstoupíme na stránku útočníka a náš prohlížeč jí poskytne citlivé údaje.
Na ochranu SOP můžeme narazit trochu nezvykle i při práci s canvasem,
aniž bychom přímo vykonávali HTTP požadavky prostřednictvím
<code>XHR</code> nebo <code>fetch</code>.</p>
<p>Začněme obyčejným HTML obrázkem (značkou <code>&lt;img&gt;</code>),
kterému nastavíme zdrojovou adresu s jiným originem (tento důležitý
termín je definován rovněž v páté kapitole), než je origin současné
stránky. Prohlížeč jej stáhne a zobrazí, ale protože se jedná
o potenciálně citlivá data, nesmí je (bez souhlasu vzdáleného serveru)
dát k dispozici JavaScriptu. Můžeme se o to pokusit použitím již známé
metody <code>drawImage</code> – a v takovou chvíli se obrázek v canvasu
sice vykreslí, ale prohlížeč si zároveň canvas vnitřně označí jako
<strong>tainted</strong> (něco jako <em>otrávený</em>). To znamená, že
přestanou fungovat veškeré mechanismy, kterými bychom se mohli pomocí
JavaScriptu dívat na obrazová data v canvasu obsažená. Zahrnuje to jak
zmíněné metody <code>toDataURL</code> a <code>toBlob</code>, tak
i možnost čtení jednotlivých pixelů pomocí metody
<code>getImageData</code>. Dokud canvas, který je <em>tainted</em>,
zcela nevyprázdníme, nebudeme jej moci plnohodnotně používat.</p>
<p>Za toto bezpečnostní omezení jsme rádi, ale v některých situacích je
zbytečně striktní. Víme, že SOP lze obejít, pokud vzdálený server vydá
explicitní souhlas s tím, aby jeho data byla přístupná JavaScriptu.
U HTML obrázků musíme nejprve přidat <code>crossOrigin</code>, ať už
pomocí atributu nebo vlastnosti:</p>
<div class="sourceCode" id="cb164"><pre
class="sourceCode html"><code class="sourceCode html"><span id="cb164-1"><a href="#cb164-1" aria-hidden="true" tabindex="-1"></a><span class="dt">&lt;</span><span class="kw">img</span> <span class="er">src</span><span class="ot">=</span><span class="st">&quot;https://...&quot;</span> <span class="er">crossOrigin</span><span class="ot">=</span><span class="st">&quot;anonymous&quot;</span> <span class="dt">/&gt;</span></span></code></pre></div>
<div class="sourceCode" id="cb165"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb165-1"><a href="#cb165-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> image <span class="op">=</span> <span class="kw">new</span> <span class="fu">Image</span>()<span class="op">;</span></span>
<span id="cb165-2"><a href="#cb165-2" aria-hidden="true" tabindex="-1"></a>image<span class="op">.</span><span class="at">crossOrigin</span> <span class="op">=</span> <span class="st">&quot;anonymous&quot;</span><span class="op">;</span></span></code></pre></div>
<p>Povolené hodnoty jsou dvě: <code>anonymous</code> (do požadavku
nejsou přidány cookies) a <code>use-credentials</code> (cookies jsou
přítomny). Tím prohlížeč v požadavku na obrázek pošle také hlavičku
<code>Origin</code>. Pokud následně server do HTTP odpovědi přidá
potřebné CORS hlavičky (stejně jako na konci páté kapitoly), canvas
s tímto obrázkem nebude <em>tainted</em> a můžeme s ním pracovat
plnohodnotně.</p>
<h3 id="antialiasing">Antialiasing</h3>
<p>V podkapitole pro zelenáče jsme viděli, jak do canvasu kreslit různé
geometrické útvary a křivky. V rámci tahu štětcem (posloupnost příkazů
začínající metodou <code>beginPath</code>) musí prohlížeč danou křivku
převést na jednotlivé pixely v canvasu – této operaci se říká
<em>rasterizace</em>. Pixely jsou umístěny v pravidelné mřížce a během
rasterizace se rozhoduje, který z nich bude mít jakou barvu. Tato
činnost je docela komplexní a u složitějších křivek ji vlastně ani nelze
vykonat zcela přesně. Můžeme si to představit na jednoduché diagonální
čáře; při její rasterizaci na čtverečkovaném papíře vidíme, že vzniklý
útvar je <em>zubatý</em>.</p>
<p>V HTML canvasu prohlížeče automaticky během rasterizace provádí tzv.
<em>antialiasing</em>. Při této operaci se snaží vyhnout zmiňovaným
zubatým hranám tak, že pixely poblíž hranic vykreslované oblasti zobrazí
barvou, která je někde mezi barvou výplně a barvou pozadí. Pokud do
bílého canvasu kreslíme černý útvar, jeho hrany budou při bližším
zkoumání šedé. Tato nepřesnost pak pro lidské oko zvýší iluzi toho, že
hrana je hladká a přesná.</p>
<p>V naprosté většině případů je antialiasing užitečný a chtěný.
Existuje však jeden scénář, kdy nám vadí – a přitom jej nelze vypnout.
Jedná se o kresbu čáry, která je zcela svislá či vodorovná, má
celočíselné souřadnice a lichou tloušťku. Jeden obrázek je v tomto
případě lepší, než tisíc slov: pokusme se vykreslit krátkou svislou
čáru, tlustou jeden pixel, spojující body (3; 1) a (3; 5).</p>
<figure>
<img src="../img/canvas1.svg" alt="Cílová tenká (jednopixelová) čára" />
<figcaption aria-hidden="true">Cílová tenká (jednopixelová)
čára</figcaption>
</figure>
<p>Každý pixel si můžeme představit jako malý čtverec, který má v levém
horním rohu <em>své</em> souřadnice. Pixel (3; 1) je druhý shora
a čtvrtý zleva. Jeho pravý dolní roh má souřadnice o jedničku vyšší – je
to zároveň levý horní roh sousedního pixelu.</p>
<p>Podívejme se nyní na problémovou svislou čáru z bodu (3; 1) dolů.
Její tloušťka je jeden pixel, což znamená, že od svého matematického
středu zabírá půl pixelu doleva a půl pixelu doprava. Do šířky by tedy
měla pokrývat rozpětí od 2,5 do 3,5 pixelu. To ale nedává smysl, protože
není možné zapnout na obrazovce (ani v canvasu) jen polovinu pixelu.
Prohlížeč tento problém řeší antialiasingem, takže obarví oba dva pixely
takto zasažené čarou, ale nastaví jim jen poloviční barvu. Namísto
jednopixelové černé čáry pak vidíme čáru dvoupixelovou šedou.</p>
<figure>
<img src="../img/canvas2.svg"
alt="Jednopixelová čára zabírá dva půlpixely" />
<figcaption aria-hidden="true">Jednopixelová čára zabírá dva
půlpixely</figcaption>
</figure>
<p>Víme, že antialiasing v canvasu nejde vypnout. Při pohledu na
zvětšené pixely nás ale může napadnout snadný trik. Naším cílem je
obarvit pixel (3; 1) a následně ty pod ním. Horizontálně to tedy
znamená, že chceme obarvit rozpětí od třetího do čtvrtého pixelu. To
odpovídá jednopixelové čáře, jejíž první souřadnice je 3,5! A canvas nám
dovoluje používání neceločíselných souřadnic. Správně tedy ostrou
svislou čáru (s lichou šířkou) vykreslíme tak, že ji posuneme o polovinu
pixelu:</p>
<div class="sourceCode" id="cb166"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb166-1"><a href="#cb166-1" aria-hidden="true" tabindex="-1"></a>ctx<span class="op">.</span><span class="at">lineWidth</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb166-2"><a href="#cb166-2" aria-hidden="true" tabindex="-1"></a>ctx<span class="op">.</span><span class="fu">beginPath</span>()<span class="op">;</span></span>
<span id="cb166-3"><a href="#cb166-3" aria-hidden="true" tabindex="-1"></a>ctx<span class="op">.</span><span class="fu">moveTo</span>(<span class="fl">3.5</span><span class="op">,</span> <span class="dv">1</span>)<span class="op">;</span></span>
<span id="cb166-4"><a href="#cb166-4" aria-hidden="true" tabindex="-1"></a>ctx<span class="op">.</span><span class="fu">lineTo</span>(<span class="fl">3.5</span><span class="op">,</span> <span class="dv">5</span>)<span class="op">;</span></span>
<span id="cb166-5"><a href="#cb166-5" aria-hidden="true" tabindex="-1"></a>ctx<span class="op">.</span><span class="fu">stroke</span>()<span class="op">;</span></span></code></pre></div>
<figure>
<img src="../img/canvas3.svg" alt="Posun o polovinu pixelu doprava" />
<figcaption aria-hidden="true">Posun o polovinu pixelu
doprava</figcaption>
</figure>
<h3 id="vysoká-hustota-pixelů">Vysoká hustota pixelů</h3>
<p>V posledních letech se často setkáváme se zobrazovacími zařízeními,
které disponují vysokou hustotou pixelů (známe je např. pod obchodním
názvem Retina). Tyto displeje mají extrémně malé pixely, takže se jich –
v porovnání s běžnými displeji – na stejnou plochu vejde třeba
čtyřnásobek. Díky tomu je možné dosáhnout perfektní ostrosti. Takto malé
pixely ale neznamenají, že pracujeme s násobným rozlišením. Můžeme si to
představit třeba na písmu běžné výšky 16 pixelů, zobrazovaném na
displeji s dvojnásobnou hustotou pixelů. Pokud bychom u takového
displeje vykreslovali písmo vždy na 16 pixelů výšky, bude ve skutečnosti
(v milimetrech) dvakrát menší, a tím pádem nečitelné.</p>
<p>Zařízení s vysokou hustotou proto používají trik: vykreslované
objekty před rasterizací úměrně zvětší (typicky na dvojnásobek), takže
písmo s nastavenou velikostí 16 pixelů jich zabere 32 a přitom je
(v milimetrech) stejně velké, jako kdyby na běžném displeji zabralo
pixelů 16.</p>
<p>Pro vývojáře to představuje jistou komplikaci, neboť nyní pracujeme
se dvěma druhy pixelů:</p>
<ol type="1">
<li><p><em>CSS pixely</em> neboli <strong>logické pixely</strong>, které
odpovídají původnímu rozlišení. Když si koupíme displej Retina, počet
logických pixelů zůstane stejný. Logické pixely používáme téměř všude:
při specifikaci délkových jednotek v CSS, při nastavování rozměrů
obrázků, v media queries.</p></li>
<li><p><em>Hardwarové</em> neboli <strong>fyzické pixely</strong>, které
odpovídají skutečným diodám tvořícím hardware displeje. S nimi pracuje
až prohlížeč a operační systém, když obsah webové stránky rasterizují
před vykreslením.</p></li>
</ol>
<p>V JavaScriptu máme k dispozici informaci jen o logických pixelech,
ale zároveň se ve vlastnosti <code>window.devicePixelRatio</code>
dozvíme, kolikrát je počet fyzických pixelů větší než počet těch
logických. Jinými slovy, displeje s vysokou hustotou pixelů mají
<code>devicePixelRatio</code> větší než jedna.</p>
<p>Koncept logických a fyzických pixelů je navržen tak, abychom se o něj
v naprosté většině případů nemuseli starat. Bohužel, práce s canvasem je
jedno z těch míst, kdy nás hardwarové pixely zajímají. Představme si
stránku s HTML obsahem šířky 640 pixelů (logických), ve které máme
canvas (aby do stránky dobře pasoval, jeho šířka je též 640). Do canvasu
jsme nakreslili obrázek a nyní jej chceme zobrazit na monitoru
s <code>devicePixelRatio=2</code>. Znamená to, že prohlížeč musí canvas
nejprve roztáhnout na šířku 1280 pixelů (hardwarových) a pak teprve
vykreslit. Během roztažení dojde k nepěknému rozmazání způsobenému
jednoduše tím, že si prohlížeč musí čtyřnásobný počet pixelů
domyslet.</p>
<p>Tomuto nežádoucímu rozmazání můžeme předejít tím, že si canvas
nachystáme v takové velikosti, která odpovídá počtu hardwarových pixelů.
Zahrnuje to tři kroky:</p>
<ol type="1">
<li><p>Canvasu nastavíme rozměry (atributy <code>width</code>
a <code>height</code>) dle fyzických pixelů.</p></li>
<li><p>Canvasu nastavíme velikost (CSS vlastnosti <code>width</code>
a <code>height</code>) dle logických pixelů – chceme, aby dobře pasoval
do stránky široké 640 logických pixelů.</p></li>
<li><p>Vše, co do canvasu kreslíme, musíme vytvářet dvakrát větší (neboť
i počet pixelů v canvasu je větší).</p></li>
</ol>
<p>Náš kód by měl ale stejně dobře fungovat jak pro zařízení s vysokou
hustotou pixelů, tak pro ta běžná. Podívejme se, jak můžeme canvas pro
takové vykreslování připravit zcela univerzálně, jen na základě znalosti
<code>devicePixelRatio</code>:</p>
<div class="sourceCode" id="cb167"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb167-1"><a href="#cb167-1" aria-hidden="true" tabindex="-1"></a><span class="co">// CSS pixely</span></span>
<span id="cb167-2"><a href="#cb167-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> width <span class="op">=</span> <span class="dv">640</span><span class="op">;</span></span>
<span id="cb167-3"><a href="#cb167-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> height <span class="op">=</span> <span class="dv">480</span><span class="op">;</span></span>
<span id="cb167-4"><a href="#cb167-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb167-5"><a href="#cb167-5" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> canvas <span class="op">=</span> <span class="bu">document</span><span class="op">.</span><span class="fu">createElement</span>(<span class="st">&quot;canvas&quot;</span>)<span class="op">;</span></span>
<span id="cb167-6"><a href="#cb167-6" aria-hidden="true" tabindex="-1"></a>canvas<span class="op">.</span><span class="at">style</span><span class="op">.</span><span class="at">width</span> <span class="op">=</span> <span class="vs">`</span><span class="sc">${</span>width<span class="sc">}</span><span class="vs">px`</span><span class="op">;</span></span>
<span id="cb167-7"><a href="#cb167-7" aria-hidden="true" tabindex="-1"></a>canvas<span class="op">.</span><span class="at">style</span><span class="op">.</span><span class="at">height</span> <span class="op">=</span> <span class="vs">`</span><span class="sc">${</span>height<span class="sc">}</span><span class="vs">px`</span><span class="op">;</span></span>
<span id="cb167-8"><a href="#cb167-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb167-9"><a href="#cb167-9" aria-hidden="true" tabindex="-1"></a><span class="co">// hardwarové pixely</span></span>
<span id="cb167-10"><a href="#cb167-10" aria-hidden="true" tabindex="-1"></a>canvas<span class="op">.</span><span class="at">width</span> <span class="op">=</span> width <span class="op">*</span> devicePixelRatio<span class="op">;</span></span>
<span id="cb167-11"><a href="#cb167-11" aria-hidden="true" tabindex="-1"></a>canvas<span class="op">.</span><span class="at">height</span> <span class="op">=</span> height <span class="op">*</span> devicePixelRatio<span class="op">;</span></span>
<span id="cb167-12"><a href="#cb167-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb167-13"><a href="#cb167-13" aria-hidden="true" tabindex="-1"></a>canvas<span class="op">.</span><span class="fu">scale</span>(devicePixelRatio<span class="op">,</span> devicePixelRatio)<span class="op">;</span></span></code></pre></div>
<p>Poslední řádek říká, že všechny následující vykreslovací operace mají
být <em>zvětšeny</em> dle zadaného měřítka (resp. dle dvou – jednoho
v ose X, jednoho v ose Y). Pokud pracujeme s běžným displejem, je
<code>devicePixelRatio</code> rovno jedné, žádné zvětšování se
neodehrává a CSS rozměry se shodují s fyzickými. U displejů s vysokým
rozlišením vytvoříme canvas veliký, vykreslujeme jej do menšího
prostoru, a tím se naše canvasové pixely přesně trefí do těch
hardwarových.</p>
<p>Pozor – některé displeje mají hodnotu <code>devicePixelRatio</code>
neceločíselnou. Musíme pak dát pozor na to, abychom po násobení zůstali
u celých čísel, neboť canvas musí mít celočíselné rozměry.</p>
<h1 id="javascript-mimo-prohlížeč">JavaScript mimo prohlížeč</h1>
<p>Většinu knihy jsme se věnovali JavaScriptu v prostředí webového
prohlížeče, dokumentu HTML a rozhraní DOM. JavaScript je však
univerzální jazyk, a tak není překvapivé, že ho lze používat i v jiných
situacích. Často se použití bez prohlížeče týká serverového prostředí,
ale ukážeme si, že se nám může hodit i pro běžné programátorské úkony
zcela mimo provoz webových aplikací.</p>
<p>Proč bychom chtěli používat JavaScript tam, kde máme na výběr téměř
všechny ostatní myslitelné programovací jazyky? Důvodů může být více:
pokud už ovládáme JavaScript v prohlížeči, můžeme získané dovednosti
znovupoužít na serveru. Může nám také vyhovovat koncept asynchronního
programování, na kterém je JavaScript vystaven. A konečně, díky
JavaScriptu připadá v úvahu možnost sdílení některého kódu mezi
serverovou a klientskou částí aplikace. Tuto vlastnost se pokusíme
využít i v úloze, kterou za malou chvíli vyřešíme.</p>
<p>Co to technologicky znamená, JavaScript bez prohlížeče? Potřebujeme
implementaci jazyka samotného a k tomu takovou sadu rozhraní, abychom
dokázali přistupovat k souborům, obrazovce, síti a dalším komponentám
počítače. Zdaleka nejpopulárnější možností je v tomto směru projekt
Node.js, který staví na jádře V8 (stejně jako prohlížeče Chrome a Edge)
a přidává k němu bohatou sadu vestavěných knihoven. Výsledek je
k dispozici pro všechny operační systémy a navíc zdarma (open source).
Můžeme si jej stáhnout, nainstalovat a pak spouštět pomocí příkazu
<code>node</code> v příkazové řádce.</p>
<h2 id="úloha-10">Úloha</h2>
<p>Vytvořte základ HTTP serveru, který bude umožňovat registraci
uživatelských účtů. Založené účty evidujte v souboru
<code>accounts.json</code>.</p>
<h3 id="řešení-10">Řešení</h3>
<div class="sourceCode" id="cb168"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb168-1"><a href="#cb168-1" aria-hidden="true" tabindex="-1"></a><span class="co">// kapitola-12.js</span></span>
<span id="cb168-2"><a href="#cb168-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> <span class="op">*</span> <span class="im">as</span> fs <span class="im">from</span> <span class="st">&quot;node:fs&quot;</span><span class="op">;</span></span>
<span id="cb168-3"><a href="#cb168-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> <span class="op">*</span> <span class="im">as</span> http <span class="im">from</span> <span class="st">&quot;node:http&quot;</span><span class="op">;</span></span>
<span id="cb168-4"><a href="#cb168-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> validateUsername <span class="im">from</span> <span class="st">&quot;./validate-username.js&quot;</span><span class="op">;</span></span>
<span id="cb168-5"><a href="#cb168-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb168-6"><a href="#cb168-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb168-7"><a href="#cb168-7" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> accounts <span class="op">=</span> []<span class="op">;</span></span>
<span id="cb168-8"><a href="#cb168-8" aria-hidden="true" tabindex="-1"></a><span class="cf">try</span> {</span>
<span id="cb168-9"><a href="#cb168-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> data <span class="op">=</span> fs<span class="op">.</span><span class="fu">readFileSync</span>(<span class="st">&quot;accounts.json&quot;</span>)<span class="op">;</span></span>
<span id="cb168-10"><a href="#cb168-10" aria-hidden="true" tabindex="-1"></a>  accounts <span class="op">=</span> <span class="bu">JSON</span><span class="op">.</span><span class="fu">parse</span>(data)<span class="op">;</span></span>
<span id="cb168-11"><a href="#cb168-11" aria-hidden="true" tabindex="-1"></a>} <span class="cf">catch</span> (e) {}</span>
<span id="cb168-12"><a href="#cb168-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb168-13"><a href="#cb168-13" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">processRequest</span>(req<span class="op">,</span> res) {</span>
<span id="cb168-14"><a href="#cb168-14" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (req<span class="op">.</span><span class="at">method</span> <span class="op">!=</span> <span class="st">&quot;POST&quot;</span>) {</span>
<span id="cb168-15"><a href="#cb168-15" aria-hidden="true" tabindex="-1"></a>    res<span class="op">.</span><span class="fu">writeHead</span>(<span class="dv">204</span>)<span class="op">;</span></span>
<span id="cb168-16"><a href="#cb168-16" aria-hidden="true" tabindex="-1"></a>    res<span class="op">.</span><span class="fu">end</span>()<span class="op">;</span></span>
<span id="cb168-17"><a href="#cb168-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span><span class="op">;</span></span>
<span id="cb168-18"><a href="#cb168-18" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb168-19"><a href="#cb168-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb168-20"><a href="#cb168-20" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> body <span class="op">=</span> <span class="st">&quot;&quot;</span><span class="op">;</span></span>
<span id="cb168-21"><a href="#cb168-21" aria-hidden="true" tabindex="-1"></a>  req<span class="op">.</span><span class="fu">on</span>(<span class="st">&quot;data&quot;</span><span class="op">,</span> chunk <span class="kw">=&gt;</span> body <span class="op">+=</span> chunk<span class="op">.</span><span class="fu">toString</span>())<span class="op">;</span></span>
<span id="cb168-22"><a href="#cb168-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb168-23"><a href="#cb168-23" aria-hidden="true" tabindex="-1"></a>  req<span class="op">.</span><span class="fu">on</span>(<span class="st">&quot;end&quot;</span><span class="op">,</span> () <span class="kw">=&gt;</span> {</span>
<span id="cb168-24"><a href="#cb168-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> data <span class="op">=</span> <span class="bu">JSON</span><span class="op">.</span><span class="fu">parse</span>(body)<span class="op">;</span></span>
<span id="cb168-25"><a href="#cb168-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb168-26"><a href="#cb168-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (<span class="fu">validateUsername</span>(data<span class="op">.</span><span class="at">username</span>)) {</span>
<span id="cb168-27"><a href="#cb168-27" aria-hidden="true" tabindex="-1"></a>      accounts<span class="op">.</span><span class="fu">push</span>(data)<span class="op">;</span></span>
<span id="cb168-28"><a href="#cb168-28" aria-hidden="true" tabindex="-1"></a>      res<span class="op">.</span><span class="fu">writeHead</span>(<span class="dv">200</span>)<span class="op">;</span></span>
<span id="cb168-29"><a href="#cb168-29" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> str <span class="op">=</span> <span class="bu">JSON</span><span class="op">.</span><span class="fu">stringify</span>(accounts)<span class="op">;</span></span>
<span id="cb168-30"><a href="#cb168-30" aria-hidden="true" tabindex="-1"></a>      fs<span class="op">.</span><span class="fu">writeFile</span>(<span class="st">&quot;accounts.json&quot;</span><span class="op">,</span> str<span class="op">,</span> e <span class="kw">=&gt;</span> {})<span class="op">;</span></span>
<span id="cb168-31"><a href="#cb168-31" aria-hidden="true" tabindex="-1"></a>    } <span class="cf">else</span> {</span>
<span id="cb168-32"><a href="#cb168-32" aria-hidden="true" tabindex="-1"></a>      res<span class="op">.</span><span class="fu">writeHead</span>(<span class="dv">400</span>)<span class="op">;</span></span>
<span id="cb168-33"><a href="#cb168-33" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb168-34"><a href="#cb168-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb168-35"><a href="#cb168-35" aria-hidden="true" tabindex="-1"></a>    res<span class="op">.</span><span class="fu">end</span>()<span class="op">;</span></span>
<span id="cb168-36"><a href="#cb168-36" aria-hidden="true" tabindex="-1"></a>  })<span class="op">;</span></span>
<span id="cb168-37"><a href="#cb168-37" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb168-38"><a href="#cb168-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb168-39"><a href="#cb168-39" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> server <span class="op">=</span> http<span class="op">.</span><span class="fu">createServer</span>(processRequest)<span class="op">;</span></span>
<span id="cb168-40"><a href="#cb168-40" aria-hidden="true" tabindex="-1"></a>server<span class="op">.</span><span class="fu">listen</span>(<span class="dv">8000</span>)<span class="op">;</span></span></code></pre></div>
<div class="sourceCode" id="cb169"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb169-1"><a href="#cb169-1" aria-hidden="true" tabindex="-1"></a><span class="co">// validate-username.js</span></span>
<span id="cb169-2"><a href="#cb169-2" aria-hidden="true" tabindex="-1"></a><span class="im">export</span> <span class="im">default</span> <span class="kw">function</span>(username) {</span>
<span id="cb169-3"><a href="#cb169-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> username<span class="op">.</span><span class="fu">match</span>(<span class="ss">/</span><span class="sc">^[a-z]</span><span class="ss">/</span>)<span class="op">;</span></span>
<span id="cb169-4"><a href="#cb169-4" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<div class="sourceCode" id="cb170"><pre
class="sourceCode json"><code class="sourceCode json"><span id="cb170-1"><a href="#cb170-1" aria-hidden="true" tabindex="-1"></a><span class="er">//</span> <span class="er">package.json</span></span>
<span id="cb170-2"><a href="#cb170-2" aria-hidden="true" tabindex="-1"></a><span class="fu">{</span></span>
<span id="cb170-3"><a href="#cb170-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&quot;type&quot;</span><span class="fu">:</span><span class="st">&quot;module&quot;</span></span>
<span id="cb170-4"><a href="#cb170-4" aria-hidden="true" tabindex="-1"></a><span class="fu">}</span></span></code></pre></div>
<p>Přestože se jedná o JavaScript, můžeme být překvapeni některými
odlišnostmi od kódu, který jsme si v minulých kapitolách navykli psát
pro prohlížeč. Začněme malinkatým souborem <code>package.json</code>,
který je v ukázce až úplně na konci a který bývá součástí každého
projektu pro Node.js. Je určen pro různá metadata naší aplikace, výčet
závislostí a další konfiguraci. My do něj do začátku přidáme jedinou
konfigurační položku (<code>"type":"module"</code>), která říká, že kód
plánujeme dělit do souborů pomocí ES modulů (poprvé jsme je potkali
v osmé kapitole). Prostředí Node.js je relativně staré a historicky
nabízí i odlišný způsob členění kódu do knihoven (říká se mu
<em>CommonJS require</em>). Protože je ale jedním z našich cílů možnost
sdílení kódu mezi serverem a prohlížečem, rozhodně chceme používat ES
moduly, tj. klíčová slova <code>export</code> a <code>import</code>.</p>
<p>Samotný kód serveru je v souboru <code>kapitola-12.js</code>.
Rozdělme si jej do menších částí. Hned na začátku importujeme potřebné
knihovny:</p>
<div class="sourceCode" id="cb171"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb171-1"><a href="#cb171-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> <span class="op">*</span> <span class="im">as</span> fs <span class="im">from</span> <span class="st">&quot;node:fs&quot;</span><span class="op">;</span></span>
<span id="cb171-2"><a href="#cb171-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> <span class="op">*</span> <span class="im">as</span> http <span class="im">from</span> <span class="st">&quot;node:http&quot;</span><span class="op">;</span></span>
<span id="cb171-3"><a href="#cb171-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> validateUsername <span class="im">from</span> <span class="st">&quot;./validate-username.js&quot;</span><span class="op">;</span></span></code></pre></div>
<p>První dva importy odpovídají vestavěným knihovnám, které jsou
součástí Node.js. Proto jejich identifikace začíná tzv.
pseudo-protokolem <code>node:</code> – a hned zde vidíme první rozdíl
oproti klientskému JavaScriptu, ve kterém lze importovat jen soubory
z webových adres (HTTP/HTTPS), případně relativní vůči aktuálnímu
skriptu (s tečkou na začátku). Třetí import je naše vlastní miniaturní
knihovna, která obsahuje jedinou funkci <code>validateUsername</code>.
Tu plánujeme použít pro kontrolu zadaného uživatelského jména. Do
vlastního souboru jsme ji umístili právě proto, abychom tento mohli
následně importovat i do HTML dokumentu a kontrolní funkci mohli
používat i při klientské kontrole před odesláním formuláře (viz kapitolu
4).</p>
<p>Namísto opravdové databáze budeme uživatelské účty spravovat
v obyčejném souboru. Kód našeho serveru proto začíná načtením
existujících dat z tohoto souboru. K tomu se hodí funkce
<code>readFileSync</code>. Blok try-catch je přítomen pro případ, že by
soubor neexistoval:</p>
<div class="sourceCode" id="cb172"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb172-1"><a href="#cb172-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> accounts <span class="op">=</span> []<span class="op">;</span></span>
<span id="cb172-2"><a href="#cb172-2" aria-hidden="true" tabindex="-1"></a><span class="cf">try</span> {</span>
<span id="cb172-3"><a href="#cb172-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> data <span class="op">=</span> fs<span class="op">.</span><span class="fu">readFileSync</span>(<span class="st">&quot;accounts.json&quot;</span>)<span class="op">;</span></span>
<span id="cb172-4"><a href="#cb172-4" aria-hidden="true" tabindex="-1"></a>  accounts <span class="op">=</span> <span class="bu">JSON</span><span class="op">.</span><span class="fu">parse</span>(data)<span class="op">;</span></span>
<span id="cb172-5"><a href="#cb172-5" aria-hidden="true" tabindex="-1"></a>} <span class="cf">catch</span> (e) {}</span></code></pre></div>
<p>Dostáváme se k hlavní části aplikace. HTTP server je dlouho-běžící
program (spustíme jej a očekáváme, že bude spuštěn stále, dokud jej sami
ručně nevypneme), jehož úkolem je zpracovávat požadavky přicházející po
síti. V rámci standardní knihovny Node.js jsme získali modul
<code>http</code>, který většinu této práce udělá za nás. Stačí pak
dodat vlastní funkci, která jako parametr získá data příchozího
požadavku a jejímž úkolem bude vyrobit odpověď. Ve vzorovém řešení je
pojmenovaná <code>processRequest</code> a server ji zavolá pro každý
příchozí HTTP požadavek. O jejích parametrech se můžeme dočíst
v oficiální dokumentaci Node.js.</p>
<p>Nejprve musíme rozpoznat, jestli se skutečně jedná o požadavek na
registraci uživatelského účtu. Naše kontrola je jednoduchá:</p>
<div class="sourceCode" id="cb173"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb173-1"><a href="#cb173-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (req<span class="op">.</span><span class="at">method</span> <span class="op">!=</span> <span class="st">&quot;POST&quot;</span>) {</span>
<span id="cb173-2"><a href="#cb173-2" aria-hidden="true" tabindex="-1"></a>  res<span class="op">.</span><span class="fu">writeHead</span>(<span class="dv">204</span>)<span class="op">;</span></span>
<span id="cb173-3"><a href="#cb173-3" aria-hidden="true" tabindex="-1"></a>  res<span class="op">.</span><span class="fu">end</span>()<span class="op">;</span></span>
<span id="cb173-4"><a href="#cb173-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span><span class="op">;</span></span>
<span id="cb173-5"><a href="#cb173-5" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Pro jednoduchost jen ověřujeme, zdali je požadavek realizován HTTP
metodou <code>POST</code>. V praxi bychom typicky chtěli ještě
kontrolovat URL, formát dat (hlavičku <code>Content-Type</code>)
a další. Nevhodné požadavky zodpovíme stavovým kódem 204 (tzv. <em>No
Content</em>; tento předdefinovaný stav informuje klienta, že server na
požadavek nemá žádnou odpověď) a metodou <code>res.end()</code> odešleme
zpět klientovi.</p>
<p>Následuje několik řádků věnovaných zpracování těla požadavku:</p>
<div class="sourceCode" id="cb174"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb174-1"><a href="#cb174-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> body <span class="op">=</span> <span class="st">&quot;&quot;</span><span class="op">;</span></span>
<span id="cb174-2"><a href="#cb174-2" aria-hidden="true" tabindex="-1"></a>req<span class="op">.</span><span class="fu">on</span>(<span class="st">&quot;data&quot;</span><span class="op">,</span> chunk <span class="kw">=&gt;</span> body <span class="op">+=</span> chunk<span class="op">.</span><span class="fu">toString</span>())<span class="op">;</span></span>
<span id="cb174-3"><a href="#cb174-3" aria-hidden="true" tabindex="-1"></a>req<span class="op">.</span><span class="fu">on</span>(<span class="st">&quot;end&quot;</span><span class="op">,</span> () <span class="kw">=&gt;</span> { <span class="op">...</span> })</span></code></pre></div>
<p>Předpokládáme, že klient nám data posílá ve formátu JSON. V kontextu
HTTP serveru je ovšem tělo požadavku představováno prostým řetězcem,
který navíc může po síti přicházet v menších kouscích (paketech). Proto
tyto části postupně přidáváme do velkého řetězce. Teprve když data od
klienta dorazí všechna, lze pokračovat dále.</p>
<p>Můžeme si přitom všimnout, že funkce <code>processRequest</code> je
asynchronní. Její vykonávání už dávno skončilo, server může zpracovávat
další požadavky, ale my mezitím čekáme na data. V knihovně
<code>node:http</code> se o datech dozvídáme prostřednictvím událostí –
obdobně jako v rozhraní DOM metodou <code>addEventListener</code>. Ve
světě serverového JavaScriptu ale není žádný strom dokumentu, a proto se
s událostmi pracuje trochu odlišně; mimo jiné i jinak pojmenovanými
metodami. V tomto případě přidáváme posluchač metodou <code>on</code>
a zajímají nás dvě události: příchod další části dat (událost
<code>data</code>) a ukončení HTTP požadavku (událost
<code>end</code>).</p>
<p>Poslední část funkce <code>processRequest</code> následně zpracuje
získaná data:</p>
<div class="sourceCode" id="cb175"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb175-1"><a href="#cb175-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> data <span class="op">=</span> <span class="bu">JSON</span><span class="op">.</span><span class="fu">parse</span>(body)<span class="op">;</span></span>
<span id="cb175-2"><a href="#cb175-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb175-3"><a href="#cb175-3" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (<span class="fu">validateUsername</span>(data<span class="op">.</span><span class="at">username</span>)) {</span>
<span id="cb175-4"><a href="#cb175-4" aria-hidden="true" tabindex="-1"></a>  accounts<span class="op">.</span><span class="fu">push</span>(data)<span class="op">;</span></span>
<span id="cb175-5"><a href="#cb175-5" aria-hidden="true" tabindex="-1"></a>  res<span class="op">.</span><span class="fu">writeHead</span>(<span class="dv">200</span>)<span class="op">;</span></span>
<span id="cb175-6"><a href="#cb175-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> str <span class="op">=</span> <span class="bu">JSON</span><span class="op">.</span><span class="fu">stringify</span>(accounts)<span class="op">;</span></span>
<span id="cb175-7"><a href="#cb175-7" aria-hidden="true" tabindex="-1"></a>  fs<span class="op">.</span><span class="fu">writeFile</span>(<span class="st">&quot;accounts.json&quot;</span><span class="op">,</span> str<span class="op">,</span> e <span class="kw">=&gt;</span> {})<span class="op">;</span></span>
<span id="cb175-8"><a href="#cb175-8" aria-hidden="true" tabindex="-1"></a>} <span class="cf">else</span> {</span>
<span id="cb175-9"><a href="#cb175-9" aria-hidden="true" tabindex="-1"></a>  res<span class="op">.</span><span class="fu">writeHead</span>(<span class="dv">400</span>)<span class="op">;</span></span>
<span id="cb175-10"><a href="#cb175-10" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb175-11"><a href="#cb175-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb175-12"><a href="#cb175-12" aria-hidden="true" tabindex="-1"></a>res<span class="op">.</span><span class="fu">end</span>()<span class="op">;</span></span></code></pre></div>
<p>Pro kontrolu získaných dat použijeme importovanou funkci
<code>validateUsername</code>, která vrací pravdivostní hodnotu. Při
neúspěchu jen vrátíme stavový kód 400 (tzn. <em>Bad Request</em>, tedy
chyba klienta). Pokud kontrola dopadne dobře, přidáme získaná data do
pole <code>accounts</code> a jeho obsah následně zapíšeme do souboru.
Zápis tentokrát realizujeme asynchronní funkcí <code>writeFile</code>,
která neblokuje další vykonávání kódu – to proto, abychom zápisem na
disk neoddalovali odpověď klientovi a zpracování dalších požadavků.
Třetí parametr pro <code>writeFile</code> je <em>callback</em>; funkce,
která bude vykonána po zapsání a jako parametr dostane informaci
o případné chybě.</p>
<p>Výše uvedený kód je funkční, ale rozhodně není robustní. Za domácí
úkol je možné naimplementovat celou řadu jeho vylepšení:</p>
<ol type="1">
<li><p>Neprovádíme žádnou kontrolu duplicity uživatelských
jmen.</p></li>
<li><p>Do pole <code>accounts</code> ukládáme veškerá příchozí data,
aniž bychom se podívali, kolik jich je (a co je jejich
obsahem).</p></li>
<li><p>Pokud v rámci registrace ukládáme také heslo, jistě bychom jej
měli vhodným způsobem zabezpečit (uložit jej hashované
a osolené).</p></li>
<li><p>Pokud selže kontrola uživ. jména, měli bychom v odpovědi
klientovi sdělit také informaci o tom, co přesně bylo v poslaném jménu
špatně.</p></li>
</ol>
<p>Úplně na konci vzorového řešení zbývá samotné spuštění serveru:</p>
<div class="sourceCode" id="cb176"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb176-1"><a href="#cb176-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> server <span class="op">=</span> http<span class="op">.</span><span class="fu">createServer</span>(processRequest)<span class="op">;</span></span>
<span id="cb176-2"><a href="#cb176-2" aria-hidden="true" tabindex="-1"></a>server<span class="op">.</span><span class="fu">listen</span>(<span class="dv">8000</span>)<span class="op">;</span></span></code></pre></div>
<p>Parametr pro funkci <code>listen</code> je číslo TCP portu, na kterém
bude server poslouchat. Na závěr v rychlosti prohlédněme knihovnu
<code>validate-username.js</code>, která se stará o kontrolu
uživatelského jména:</p>
<div class="sourceCode" id="cb177"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb177-1"><a href="#cb177-1" aria-hidden="true" tabindex="-1"></a><span class="co">// validate-username.js</span></span>
<span id="cb177-2"><a href="#cb177-2" aria-hidden="true" tabindex="-1"></a><span class="im">export</span> <span class="im">default</span> <span class="kw">function</span>(username) {</span>
<span id="cb177-3"><a href="#cb177-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (username<span class="op">.</span><span class="fu">match</span>(<span class="ss">/</span><span class="sc">^[a-z]</span><span class="ss">/</span>)) {</span>
<span id="cb177-4"><a href="#cb177-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb177-5"><a href="#cb177-5" aria-hidden="true" tabindex="-1"></a>  } <span class="cf">else</span> {</span>
<span id="cb177-6"><a href="#cb177-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb177-7"><a href="#cb177-7" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb177-8"><a href="#cb177-8" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Jedná se o prostou (a dost možná ne zcela dostačující) kontrolu
pomocí regulárního výrazu; s takovými jsme se již setkali ve čtvrté
kapitole. Naši aplikaci můžeme nyní spustit např. příkazem</p>
<div class="sourceCode" id="cb178"><pre
class="sourceCode sh"><code class="sourceCode bash"><span id="cb178-1"><a href="#cb178-1" aria-hidden="true" tabindex="-1"></a><span class="ex">node</span> kapitola-12.js</span></code></pre></div>
<p>Protože v aplikaci nevypisujeme na obrazovku serveru žádné informace,
budeme muset její spuštění a běh sledovat jinak. Připomeňme, že naše
aplikace je navržená specificky pro příjem HTTP požadavků POST, které
mají v těle JSON s klíčem <code>username</code>. Pro ověření tedy můžeme
použít například nástroj <code>curl</code>:</p>
<div class="sourceCode" id="cb179"><pre
class="sourceCode sh"><code class="sourceCode bash"><span id="cb179-1"><a href="#cb179-1" aria-hidden="true" tabindex="-1"></a><span class="ex">curl</span> <span class="at">-v</span> <span class="at">--data</span> <span class="st">&#39;{&quot;username&quot;:&quot;test&quot;}&#39;</span> http://localhost:8000</span></code></pre></div>
<p>Pokud je vše spuštěno správně, dostaneme odpověď s kódem 200 (OK)
a v souboru <code>accounts.json</code> se objeví nový záznam.</p>
<h3 id="co-jsme-se-naučili-9">Co jsme se naučili</h3>
<p>Po vyřešení jedenácté úlohy by měl čtenář chápat a ovládat:</p>
<ul>
<li><p>spuštění JS aplikace pomocí Node.js</p></li>
<li><p>import funkcionality ze standardních knihoven Node.js</p></li>
<li><p>koncepty obsluhy HTTP požadavků</p></li>
</ul>
<h2 id="zelenáči-npm">Zelenáči: npm</h2>
<p>Při používání Node.js se nejčastěji potkáme s programem
<code>node</code>, který slouží ke spuštění JavaScriptového kódu. Další
důležitou součástí ekosystému Node.js je nástroj <code>npm</code>
<em>(Node Package Manager),</em> který slouží k instalaci a správě
knihoven – typicky těch, na kterých náš projektu závisí.</p>
<p>Viděli jsme, že pomocí klíčového slova <code>import</code> můžeme
připojit kód z dalších souborů našeho projektu, stejně jako
z vestavěných knihoven. Zcela jsme ale zatím přeskočili miliony
a miliony řádků kódu, které vytvořili ostatní programátoři a dali
k dispozici k všeobecnému používání online. Pojďme zkusit do našeho
serveru přidat barevný výpis toho, co server zrovna provádí.</p>
<p>Náš HTTP server je spuštěn jako běžný program v rámci příkazové
řádky, takže z něj můžeme snadno psát do terminálu. Funkce
<code>console.log</code>, kterou známe především jako nástroj pro
přístup k vývojářským nástrojům v prohlížeči, je k dispozici i v Node.js
– její výstup si můžeme přečíst na příkazové řádce, kde je program
spuštěný. Zbývá jen dodat požadované barvy.</p>
<p>Při výpisu textu do terminálu se barvy definují pomocí speciálních
znaků vložených do vypisovaného řetězce. Mohli bychom je nastudovat
a text s nimi obohatit, ale jistě bude snazší použít hotovou knihovnu.
Pro naše potřeby se ideálně hodí <code>chalk</code>, která je nejen
veřejně dostupná na GitHubu, ale zároveň je připravená pro Node.js na
webu <a href="https://www.npmjs.com/">https://www.npmjs.com/</a>. Odtud
ji můžeme snadno získat právě pomocí programu <code>npm</code>.</p>
<p>V příkazové řádce, tam kde máme připravený HTTP server, napíšeme:</p>
<pre><code>npm install chalk</code></pre>
<p>Program <code>npm</code> stáhne zadanou knihovnu a uloží ji do
podadresáře <code>node_modules</code>. Toto umístění je předmětem
domluvy mezi programy <code>npm</code> a <code>node</code>, neboť právě
v <code>node_modules</code> hledá Node.js knihovny, které nejsou ani
vestavěné, ani netvoří naši aplikaci. Znamená to, že následně v souboru
<code>kapitola-12.js</code> můžeme v záhlaví přidat další import:</p>
<div class="sourceCode" id="cb181"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb181-1"><a href="#cb181-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> chalk <span class="im">from</span> <span class="st">&quot;chalk&quot;</span><span class="op">;</span></span></code></pre></div>
<p>Všimněme si, že se nejedná ani o vestavěnou knihovnu (název nezačíná
<code>node:</code>), ani o součást aplikace (název nezačíná tečkou).
Node.js proto tento modul hledá v <code>node_modules</code>, kam jsme
jej před chvílí nainstalovali.</p>
<p>S knihovnou <code>chalk</code> můžeme <em>obarvit</em> řetězce, které
plánujeme vypisovat. Začněme posledními řádky serveru:</p>
<div class="sourceCode" id="cb182"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb182-1"><a href="#cb182-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> server <span class="op">=</span> http<span class="op">.</span><span class="fu">createServer</span>(processRequest)<span class="op">;</span></span>
<span id="cb182-2"><a href="#cb182-2" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> port <span class="op">=</span> <span class="dv">8000</span><span class="op">;</span></span>
<span id="cb182-3"><a href="#cb182-3" aria-hidden="true" tabindex="-1"></a>server<span class="op">.</span><span class="fu">listen</span>(port)<span class="op">;</span></span>
<span id="cb182-4"><a href="#cb182-4" aria-hidden="true" tabindex="-1"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(chalk<span class="op">.</span><span class="fu">green</span>(<span class="vs">`Server listening on port </span><span class="sc">${</span>port<span class="sc">}</span><span class="vs">`</span>))<span class="op">;</span></span></code></pre></div>
<p>Pro sledování aktivity serveru ještě přidáme výpis tam, kde úspěšně
zpracováváme požadavky:</p>
<div class="sourceCode" id="cb183"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb183-1"><a href="#cb183-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (<span class="fu">validateUsername</span>(data<span class="op">.</span><span class="at">username</span>)) {</span>
<span id="cb183-2"><a href="#cb183-2" aria-hidden="true" tabindex="-1"></a>  accounts<span class="op">.</span><span class="fu">push</span>(data)<span class="op">;</span></span>
<span id="cb183-3"><a href="#cb183-3" aria-hidden="true" tabindex="-1"></a>  res<span class="op">.</span><span class="fu">writeHead</span>(<span class="dv">200</span>)<span class="op">;</span></span>
<span id="cb183-4"><a href="#cb183-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> str <span class="op">=</span> <span class="bu">JSON</span><span class="op">.</span><span class="fu">stringify</span>(accounts)<span class="op">;</span></span>
<span id="cb183-5"><a href="#cb183-5" aria-hidden="true" tabindex="-1"></a>  fs<span class="op">.</span><span class="fu">writeFile</span>(<span class="st">&quot;accounts.json&quot;</span><span class="op">,</span> str<span class="op">,</span> e <span class="kw">=&gt;</span> {})<span class="op">;</span></span>
<span id="cb183-6"><a href="#cb183-6" aria-hidden="true" tabindex="-1"></a>  <span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(chalk<span class="op">.</span><span class="fu">green</span>(<span class="vs">`Account </span><span class="sc">${</span>data<span class="op">.</span><span class="at">username</span><span class="sc">}</span><span class="vs"> created`</span>))<span class="op">;</span></span>
<span id="cb183-7"><a href="#cb183-7" aria-hidden="true" tabindex="-1"></a>} <span class="cf">else</span> {</span>
<span id="cb183-8"><a href="#cb183-8" aria-hidden="true" tabindex="-1"></a>  res<span class="op">.</span><span class="fu">writeHead</span>(<span class="dv">400</span>)<span class="op">;</span></span>
<span id="cb183-9"><a href="#cb183-9" aria-hidden="true" tabindex="-1"></a>  <span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(chalk<span class="op">.</span><span class="fu">red</span>(<span class="vs">`Invalid username </span><span class="sc">${</span>data<span class="op">.</span><span class="at">username</span><span class="sc">}</span><span class="vs">`</span>))<span class="op">;</span></span>
<span id="cb183-10"><a href="#cb183-10" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Barevný výpis pomůže čitelnosti a stál nás jen minimum úsilí.
Spokojeni ale ještě nejsme. Pokud bychom nyní chtěli náš projekt spustit
na jiném počítači, bude pro jeho spuštění chybět před chvilkou
nainstalovaná knihovna <code>chalk</code> v adresáři
<code>node_modules</code>. Je proto nutné dát nějakým způsobem najevo,
že ke spuštění tohoto HTTP serveru je potřeba nejprve zmíněnou závislost
doinstalovat.</p>
<p>Tím se znovu dostáváme k malému konfiguračnímu souboru
<code>package.json</code>. Právě v něm je obvyklé definovat, které
všechny knihovny jsou pro běh aplikace nezbytné. Stačí jen, abychom
přidali při instalaci parametr:</p>
<pre><code>npm install -S chalk</code></pre>
<p>Program <code>npm</code> teď nejen závislost stáhne a uloží na
správné místo, ale zároveň její jméno zaznamená
v <code>package.json</code>. Až pak náš kód budeme chtít spustit na
jiném počítači, napíšeme prostě <code>npm install</code> (případně
zkráceně <code>npm i</code>) a program <code>npm</code> namísto jedné
knihovny stáhne a nainstaluje všechny, které budou v souboru
<code>package.json</code> uvedeny.</p>
<p>Je dobré zmínit, že ačkoliv je <code>npm</code> určen především pro
správu a instalaci závislostí, nabízí značné množství další
funkcionality. Umí nás informovat o nových verzích používaných modulů,
můžeme s ním instalovat knihovny jako spustitelné programy
a v neposlední řadě nám dovoluje nahrávat naše vlastní knihovny na web
npmjs.com.</p>
<h2 id="koumáci-tooling">Koumáci: tooling</h2>
<p>Pojďme si nyní ukázat další situace, ve kterých se může JavaScript
mimo prohlížeč hodit. Začněme úlohou, která je zkušenějším programátorům
dobře známá: <em>testování</em>. Využijeme toho, že Node.js obsahuje
vestavěnou podporu pro spouštění unit testů.</p>
<h3 id="testy">Testy</h3>
<p>Automatizované testování je užitečná a zajímavá kapitola vývoje
software. Na toto téma se píší obsáhlé knihy; my se omezíme na
konstatování, že námi produkovaný kód zpravidla kontrolujeme tak, že jej
sami zkoušíme používat a pozorujeme, zdali se chová dle očekávání.
Myšlenka automatizovaného testování říká, že pokud dokážeme formálně
popsat, co od kódu očekáváme, můžeme pak následně nechat počítač, aby
funkčnost kódu ověřil za nás.</p>
<p>Nejsnazší formou testování jsou tzv. <strong>jednotkové
testy</strong> (anglicky <em>unit testing</em>). Při něm jednoduše
nachystáme některé funkce z naší aplikace, opakovaně je vykonáváme
s různými parametry a kontrolujeme, zdali jsou návratové hodnoty
korektní. Za tímto účelem se nejlépe hodí funkce, které veškerý svůj
vstup přijímají formou parametrů a výsledek své práce vrací výhradně
pomocí návratové hodnoty. V úloze této kapitoly se pro potřeby testování
docela dobře hodí sdílená funkce <code>validateUsername</code>.</p>
<p>Spouštění testů v prostředí Node.js je velmi snadné. Nejprve
připravíme jeden či více <em>testových souborů</em>, které nejsou
nezbytnou součástí aplikace, ale ve kterých některé aplikační komponenty
otestujeme. Tyto testové soubory musí mít název, který začíná či končí
(před příponou) slovem <em>test</em>. Pojďme založit nový soubor
<code>kapitola-12.test.js</code>:</p>
<div class="sourceCode" id="cb185"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb185-1"><a href="#cb185-1" aria-hidden="true" tabindex="-1"></a><span class="co">// kapitola-12.test.js</span></span>
<span id="cb185-2"><a href="#cb185-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> test <span class="im">from</span> <span class="st">&quot;node:test&quot;</span><span class="op">;</span></span>
<span id="cb185-3"><a href="#cb185-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> assert <span class="im">from</span> <span class="st">&quot;node:assert&quot;</span><span class="op">;</span></span>
<span id="cb185-4"><a href="#cb185-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> validateUsername <span class="im">from</span> <span class="st">&quot;./validate-username.js&quot;</span><span class="op">;</span></span></code></pre></div>
<p>K vytvoření testu potřebujeme tři základní stavební kameny:</p>
<ol type="1">
<li><p>Funkci <code>test</code>, která slouží pro definici
testu.</p></li>
<li><p>Objekt <code>assert</code>, který slouží pro porovnání očekávané
a skutečné hodnoty námi testované funkce.</p></li>
<li><p>Aplikační funkci, kterou plánujeme testovat.</p></li>
</ol>
<p>Samotná definice testu funguje tak, že zavoláme funkci
<code>test</code>, předáme jí název testu a malou (typicky anonymní)
funkci, která testování provede. V ní budeme volat
<code>validateUsername</code> a pomocí <code>assert.strictEqual</code>
ověřovat, že se návratová hodnota shoduje s tou, kterou očekáváme:</p>
<div class="sourceCode" id="cb186"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb186-1"><a href="#cb186-1" aria-hidden="true" tabindex="-1"></a><span class="fu">test</span>(<span class="st">&quot;funkce validateUsername&quot;</span><span class="op">,</span> () <span class="kw">=&gt;</span> {</span>
<span id="cb186-2"><a href="#cb186-2" aria-hidden="true" tabindex="-1"></a>  assert<span class="op">.</span><span class="fu">strictEqual</span>(<span class="fu">validateUsername</span>(<span class="st">&quot;test&quot;</span>)<span class="op">,</span>     <span class="kw">true</span>)<span class="op">;</span></span>
<span id="cb186-3"><a href="#cb186-3" aria-hidden="true" tabindex="-1"></a>  assert<span class="op">.</span><span class="fu">strictEqual</span>(<span class="fu">validateUsername</span>(<span class="st">&quot;0test&quot;</span>)<span class="op">,</span>    <span class="kw">false</span>)<span class="op">;</span></span>
<span id="cb186-4"><a href="#cb186-4" aria-hidden="true" tabindex="-1"></a>  assert<span class="op">.</span><span class="fu">strictEqual</span>(<span class="fu">validateUsername</span>(<span class="st">&quot;123 ahoj&quot;</span>)<span class="op">,</span> <span class="kw">false</span>)<span class="op">;</span></span>
<span id="cb186-5"><a href="#cb186-5" aria-hidden="true" tabindex="-1"></a>  assert<span class="op">.</span><span class="fu">strictEqual</span>(<span class="fu">validateUsername</span>(<span class="st">&quot;&quot;</span>)<span class="op">,</span>         <span class="kw">false</span>)<span class="op">;</span></span>
<span id="cb186-6"><a href="#cb186-6" aria-hidden="true" tabindex="-1"></a>  assert<span class="op">.</span><span class="fu">strictEqual</span>(<span class="fu">validateUsername</span>()<span class="op">,</span>           <span class="kw">false</span>)<span class="op">;</span></span>
<span id="cb186-7"><a href="#cb186-7" aria-hidden="true" tabindex="-1"></a>  assert<span class="op">.</span><span class="fu">strictEqual</span>(<span class="fu">validateUsername</span>(<span class="st">&quot;a b&quot;</span>)<span class="op">,</span>      <span class="kw">true</span>)<span class="op">;</span></span>
<span id="cb186-8"><a href="#cb186-8" aria-hidden="true" tabindex="-1"></a>  assert<span class="op">.</span><span class="fu">strictEqual</span>(<span class="fu">validateUsername</span>(<span class="st">&quot;a&quot;</span>)<span class="op">,</span>        <span class="kw">true</span>)<span class="op">;</span></span>
<span id="cb186-9"><a href="#cb186-9" aria-hidden="true" tabindex="-1"></a>})<span class="op">;</span></span></code></pre></div>
<p>Dobré jednotkové testy pokrývají spoustu přípustných i nepřípustných
variant volání funkce. Často bývá dokonce zvykem vytvořit tyto testy
dříve, než samotnou implementaci – protože o tom, jak se má funkce
chovat, míváme představu před tím, než ji napíšeme. Takovému postupu se
říká TDD: <strong>Test-Driven Development.</strong></p>
<p>Jakmile máme test připravený, můžeme jej spustit. V příkazové řádce
napíšeme:</p>
<div class="sourceCode" id="cb187"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb187-1"><a href="#cb187-1" aria-hidden="true" tabindex="-1"></a>node <span class="op">--</span>test</span></code></pre></div>
<p>Pokud jsme postupovali přesně dle kódu v knize, uvidíme výpis
spouštěných testů a informaci o tom, zdali všechny proběhly úspěšně, tj.
zdali všechna volání funkce <code>assert.strictEqual</code> dostala
identické parametry. Jenže ouha! Náš test skončil chybou a podle výpisu
je vidět, na kterém řádku se tak stalo. Na základě toho snadno poznáme,
které volání <code>validateUsername</code> nedopadlo dle očekávání.</p>
<p>Jedná se o variantu <code>validateUsername()</code>, kdy funkci
nepředáme žádný parametr, tj. její lokální proměnná
<code>username</code> bude mít hodnotu <code>undefined</code>. Těžko na
ní tedy zavoláme metodu <code>match</code>. Přitom se zdaleka nejedná
o umělý případ; stalo by se tak pokaždé, kdyby našemu serveru přišel
požadavek, v jehož JSON datech nebude přítomen klíč
<code>username</code>. Díky testu jsme tedy odhalili skutečnou chybu
v našem kódu!</p>
<p>Poučeni tímto nezdarem upravíme implementaci funkce
<code>validateUsername</code>:</p>
<div class="sourceCode" id="cb188"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb188-1"><a href="#cb188-1" aria-hidden="true" tabindex="-1"></a><span class="im">export</span> <span class="im">default</span> <span class="kw">function</span>(username) {</span>
<span id="cb188-2"><a href="#cb188-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> ((username <span class="op">||</span> <span class="st">&quot;&quot;</span>)<span class="op">.</span><span class="fu">match</span>(<span class="ss">/</span><span class="sc">^[a-z]</span><span class="ss">/</span>)) {</span>
<span id="cb188-3"><a href="#cb188-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb188-4"><a href="#cb188-4" aria-hidden="true" tabindex="-1"></a>  } <span class="cf">else</span> {</span>
<span id="cb188-5"><a href="#cb188-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb188-6"><a href="#cb188-6" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb188-7"><a href="#cb188-7" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Přidali jsme operátor <em>nebo</em> a tím zařídili, že pokud je
parametr <em>falsy value</em>, použijeme místo něj prázdný řetězec
(který má metodu <code>match</code>). A skutečně, testy nyní prochází
bez chyb:</p>
<div class="sourceCode" id="cb189"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb189-1"><a href="#cb189-1" aria-hidden="true" tabindex="-1"></a>$ node <span class="op">--</span>test</span>
<span id="cb189-2"><a href="#cb189-2" aria-hidden="true" tabindex="-1"></a>✔ funkce <span class="fu">validateUsername</span> (<span class="fl">0.950831</span>ms)</span>
<span id="cb189-3"><a href="#cb189-3" aria-hidden="true" tabindex="-1"></a>ℹ tests <span class="dv">1</span></span>
<span id="cb189-4"><a href="#cb189-4" aria-hidden="true" tabindex="-1"></a>ℹ suites <span class="dv">0</span></span>
<span id="cb189-5"><a href="#cb189-5" aria-hidden="true" tabindex="-1"></a>ℹ pass <span class="dv">1</span></span>
<span id="cb189-6"><a href="#cb189-6" aria-hidden="true" tabindex="-1"></a>ℹ fail <span class="dv">0</span></span>
<span id="cb189-7"><a href="#cb189-7" aria-hidden="true" tabindex="-1"></a>ℹ cancelled <span class="dv">0</span></span>
<span id="cb189-8"><a href="#cb189-8" aria-hidden="true" tabindex="-1"></a>ℹ skipped <span class="dv">0</span></span>
<span id="cb189-9"><a href="#cb189-9" aria-hidden="true" tabindex="-1"></a>ℹ todo <span class="dv">0</span></span>
<span id="cb189-10"><a href="#cb189-10" aria-hidden="true" tabindex="-1"></a>ℹ duration_ms <span class="fl">44.574717</span></span></code></pre></div>
<h3 id="bundling">Bundling</h3>
<p>Díky mohutnému ekosystému knihoven v rámci Node.js a npm je s pomocí
JavaScriptu naprogramováno mnoho nástrojů, které nám při vývoji mohou
různým způsobem pomáhat.</p>
<p>V osmé kapitole jsme ukázali, že objemnější kód je užitečné rozdělit
do více souborů (a propojit direktivami <code>import</code>
a <code>export</code>). Pro programátora je členění klíčové pro
čitelnost a organizaci aplikace. Naši uživatelé však o takovou skladbu
nestojí, neboť jejich prohlížeč musí každý jednotlivý soubor naší
aplikace získat individuálním HTTP požadavkem. Je proto běžné, že
hotovou (modularizovanou) aplikaci pro potřeby provozu na webu
<em>zabalíme</em> do jediného souboru, který připojíme k HTML
dokumentu.</p>
<p>Nejedná se o balení ve smyslu komprimace. Výsledkem musí být stále
JavaScript, ale upravený tak, aby celá funkcionalita byla dostupná
v jediném souboru. Něco takového nebudeme dělat ručně, ale použijeme
k tomu existující balicí program, tzv. <strong>bundler</strong>.</p>
<p>Existuje jich celá řada, my si tento scénář předvedeme pomocí
nástroje <code>esbuild</code>. Není náhodou, že je taktéž dostupný
prostřednictvím nástroje <code>npm</code>. Jeho instalace je tedy
jednoduchá:</p>
<div class="sourceCode" id="cb190"><pre
class="sourceCode sh"><code class="sourceCode bash"><span id="cb190-1"><a href="#cb190-1" aria-hidden="true" tabindex="-1"></a><span class="ex">npm</span> install <span class="at">-g</span> esbuild</span></code></pre></div>
<p>Tentokrát jsme použili parametr <code>-g</code> (global), který
upravuje chování <code>npm</code>:</p>
<ol type="1">
<li><p>Knihovna se neinstaluje do <code>node_modules</code>, ale do
systémového adresáře, odkud je dostupná pro všechny uživatele.</p></li>
<li><p>Informace o knihovně se nezapíše do <code>package.json</code>. To
je v pořádku, neboť <code>esbuild</code> nepotřebujeme k běhu našeho
serveru. Vlastně nás žádný server v tuto chvíli ani nezajímá. Program
<code>esbuild</code> chceme používat pro potřeby klientského JavaScriptu
nezávisle na tom, má-li naše aplikace nějakou komponentu
v Node.js.</p></li>
</ol>
<p>V této podkapitole nemáme žádný kód, který bychom chtěli nebo mohli
<em>bundlovat</em>. Program <code>esbuild</code> nicméně můžeme
vyzkoušet třeba na kódu z osmé kapitoly, který jsme poprvé rozdělili do
více souborů:</p>
<div class="sourceCode" id="cb191"><pre
class="sourceCode sh"><code class="sourceCode bash"><span id="cb191-1"><a href="#cb191-1" aria-hidden="true" tabindex="-1"></a><span class="ex">esbuild</span> <span class="at">--bundle</span> kapitola-8.js <span class="at">--outfile</span><span class="op">=</span>kapitola-8.bundle.js</span></code></pre></div>
<p>Vzniklý balíček, pojmenovaný <code>kapitola-8.bundle.js</code>, pak
můžeme normálně připojit k HTML dokumentu. Jeho obsah je sice
JavaScript, ale my nemáme potřebu do něj zasahovat. To proto, že při
následných úpravách <em>zdrojových souborů</em>
(<code>kapitola-8.js</code>, <code>comment.js</code>) budeme chtít
pomocí esbuildu opět balíček přegenerovat. Tím bychom o případné ruční
zásahy do něj přišli.</p>
<h2 id="profíci-alternativy-k-node.js">Profíci: alternativy
k Node.js</h2>
<p>Přestože Node.js nabízí pohodlný prostor pro JavaScriptové
programování mimo prohlížeč, není jediným nástrojem svého druhu.
Existuje několik alternativních možností, které se liší použitými
technologiemi, výkonem, množstvím implementované funkcionality a obecně
řečeno přístupem k DX (anglicky <em>developer experience</em>). Jinými
slovy, všechny tyto nástroje soupeří o přízeň nás, programátorů. V této
kapitole si některé z nich představíme. Nemáme sice prostor pro detailní
ukázky, ale povíme si alespoň o jejich základních konceptech a rozdílech
oproti Node.js.</p>
<h3 id="deno">Deno</h3>
<p>Prvním a hlavním konkurentem pro Node.js je projekt <em>Deno</em>. Je
poměrně nezvyklé, že jeho autorem je Ryan Dahl, tedy původní autor
Node.js. V roce 2018 dospěl k závěru, že jím odstartovaný projekt
Node.js z roku 2009 nesplňuje moderní požadavky na programovací nástroj,
a rozhodl se vytvořit alternativu.</p>
<p>Deno stojí na stejné implementaci JavaScriptu (V8), ale jeho další
funkcionalita je implementována v jazyce Rust. Zprovoznění a vývoj
projektu v Deno je v několika aspektech jednodušší než v Node.js:</p>
<ul>
<li><p>Program Deno není nutné instalovat, jedná se o jediný spustitelný
soubor.</p></li>
<li><p>Standardní knihovna (funkce pro práci se soubory, sítí, …) není
součástí staženého programu; namísto toho je při běhu programu stahována
z internetu, a tak je vždy aktuální.</p></li>
<li><p>Součástí Deno není koncept <code>node_modules</code> ani program
<code>npm</code>. Nedochází k žádné instalaci závislostí, veškerý kód je
importován – stejně jako v prohlížeči – z adres HTTP/HTTPS.</p></li>
<li><p>Pokud bychom náš zdrojový kód psali v TypeScriptu (více o tom
v příští kapitole), můžeme jej v Deno pustit rovnou, bez transpilace do
JavaScriptu.</p></li>
</ul>
<p>V prostředí Deno je značná snaha o znovupoužívání těch API, která
známe z klientského JavaScriptu (tj. z webového prohlížeče). V případě
úlohy s HTTP serverem bychom tak v rámci funkce
<code>processRequest</code> pracovali s existujícími objekty typu
<code>Request</code> a <code>Response</code>, které jsou součástí
standardu <code>fetch</code>.</p>
<p>Deno láká vývojáře také doplňkovými službami. Jedná se zejména
o <em>Deno Deploy</em>, službu hostingu pro servery a aplikace napsané
v Deno. Je to zajímavá a snadná alternativa k provozu vlastních
linuxových serverů. Další nabídkou ze světa Deno je distribuovaná
databáze KV, navržená jako obecné datové úložiště právě pro aplikace
provozované v Deno Deploy.</p>
<h3 id="bun">Bun</h3>
<p>Nejnovějším zápasníkem v ringu JavaScriptových prostředí je Bun,
který spatřil světlo světa v roce 2023. Jeho definující vlastností je
výkon: v rychlosti většiny testovaných scénářů předčí nejen relativně
starý Node.js, ale i novější Deno. Bun používá JavaScriptovou
implementaci JavaScriptCore od firmy Apple, kterou jinak známe
z prohlížeče Safari; jeho další části jsou napsány v jazyce Zig.</p>
<p>Bun, stejně jako Deno, dovede přímo vykonávat soubory psané
v TypeScriptu. Taktéž si zakládá na podpoře standardních prohlížečových
API (např. <code>WebSocket</code>, <code>fetch</code>, …) tam, kde
Node.js potřebuje vlastní řešení, případně knihovnu staženou
z <code>npm</code>.</p>
<p>S ohledem na nízký věk projektu Bun zatím není zřejmé, které budou
definující odlišnosti od ostatních prostředí. Při pohledu na jeho
výkonové parametry je nicméně zajímavým experimentem, který rozhodně
stojí za sledování.</p>
<h1 id="když-javascript-nestačí">Když JavaScript nestačí</h1>
<p>V předposlední kapitole už nebudeme řešit konkrétní úlohu, ale
ukážeme si další směry, kam se v rámci prozkoumávání klientských
webových technologií můžeme vydávat. Jakkoliv je totiž JavaScript
užitečný, samotný nám nedokáže poskytnout vše, co bychom mohli
potřebovat. Podívejme se tedy na několik populárních knihoven
a nadstaveb, se kterými se v praxi můžeme setkat.</p>
<h2 id="zelenáči-react">Zelenáči: React</h2>
<p>Pro mnohé frontendové vývojáře je knihovna React stejně důležitá,
jako Java­Script samotný. Jedná se o nástroj původně vyvinutý pro interní
potřeby projektu Facebook, který se následně rychle rozšířil po celém
internetu. React je určen k tvorbě stromu stránky ze vstupních dat.
Takovou úlohu jsme v této knize řešili několikrát – použili jsme k tomu
buď vestavěný HTML parser (tj. vlastnost <code>innerHTML</code>), nebo
individuální metody dostupné v rozhraní DOM (jako např.
<code>document.createElement</code>). React volí přístup koncepčně někde
mezi těmito dvěma variantami: strom stránky vytváříme deklarativně (jako
kdybychom rovnou psali HTML), ale atributy a textové uzly můžeme
generovat rovnou z JavaScriptových dat (jako kdybychom nastavovali
atributy DOM objektům).</p>
<p>React staví zejména na těchto konceptech:</p>
<ul>
<li><p>HTML výstup definujeme pomocí <strong>značkovacího jazyka
JSX</strong>, který HTML připomíná. Jedná se o mix HTML a JavaScriptu;
podobá se také trochu <em>template literals</em> (tyto řetězce jsme
viděli v páté kapitole). React lze používat i bez JSX, ale připravujeme
se tím o jisté množství funkcionality. Při naší ukázce vyzkoušíme React
včetně JSX.</p></li>
<li><p>Jednotlivé části kódu organizujeme do tzv.
<strong>komponent</strong>, které zodpovídají za jednotlivé části stromu
dokumentu. Úkolem komponent (a úkolem Reactu jako takového) je
prezentace dat. Tato jsou komponentám v jazyce JSX předávána pomocí
atributů, které mohou – v porovnání s HTML – obsahovat libovolné datové
typy. V jazyce JSX pak komponenty vypadají jako HTML značky a nápadně
připomínají <em>Custom Elements</em> (devátá kapitola). Komponenty jsou
typicky implementovány jako JavaScriptové funkce.</p></li>
<li><p>Při použití Reactu necháváme knihovnu vygenerovat výstup při
libovolné změně ve vstupních datech, což zní jako zbytečná práce. React
ale vzniklé HTML prvky negeneruje rovnou ve stránce, ale v rámci tzv.
<strong>virtual DOM</strong> – svého virtuálního dokumentu. Do stránky
pak promítne jen ty úpravy, které znamenají změnu v dokumentu
opravdovém.</p></li>
</ul>
<p>React si můžeme vyzkoušet na úloze z šesté kapitoly, ve které
implementujeme zobrazování výsledků hledání. Vystačíme si s minimálním
HTML dokumentem:</p>
<div class="sourceCode" id="cb192"><pre
class="sourceCode html"><code class="sourceCode html"><span id="cb192-1"><a href="#cb192-1" aria-hidden="true" tabindex="-1"></a><span class="co">&lt;!-- index.html --&gt;</span></span>
<span id="cb192-2"><a href="#cb192-2" aria-hidden="true" tabindex="-1"></a><span class="dt">&lt;</span><span class="kw">body</span><span class="dt">&gt;</span></span>
<span id="cb192-3"><a href="#cb192-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&lt;</span><span class="kw">main</span><span class="dt">&gt;&lt;/</span><span class="kw">main</span><span class="dt">&gt;</span></span>
<span id="cb192-4"><a href="#cb192-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&lt;</span><span class="kw">script</span> <span class="er">src</span><span class="ot">=</span><span class="st">&quot;index.js&quot;</span><span class="dt">&gt;&lt;/</span><span class="kw">script</span><span class="dt">&gt;</span></span>
<span id="cb192-5"><a href="#cb192-5" aria-hidden="true" tabindex="-1"></a><span class="dt">&lt;/</span><span class="kw">body</span><span class="dt">&gt;</span></span></code></pre></div>
<p>Celé HTML plánujeme vytvářet pomocí Reactu. Budeme k tomu používat
jazyk JSX, takže výsledný skript <code>index.js</code> si na závěr
necháme vygenerovat. Místo toho začneme vstupním bodem aplikace
v souboru <code>index.jsx</code>:</p>
<div class="sourceCode" id="cb193"><pre
class="sourceCode jsx"><code class="sourceCode javascriptreact"><span id="cb193-1"><a href="#cb193-1" aria-hidden="true" tabindex="-1"></a><span class="co">// index.jsx</span></span>
<span id="cb193-2"><a href="#cb193-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> { createRoot } <span class="im">from</span> <span class="st">&quot;react-dom/client&quot;</span><span class="op">;</span></span>
<span id="cb193-3"><a href="#cb193-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> App <span class="im">from</span> <span class="st">&quot;./App.jsx&quot;</span><span class="op">;</span></span>
<span id="cb193-4"><a href="#cb193-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb193-5"><a href="#cb193-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb193-6"><a href="#cb193-6" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> main <span class="op">=</span> <span class="bu">document</span><span class="op">.</span><span class="fu">querySelector</span>(<span class="st">&quot;main&quot;</span>)<span class="op">;</span></span>
<span id="cb193-7"><a href="#cb193-7" aria-hidden="true" tabindex="-1"></a><span class="fu">createRoot</span>(main)<span class="op">.</span><span class="fu">render</span>(<span class="fu">&lt;App</span> <span class="fu">/&gt;</span>)</span></code></pre></div>
<p>Většina vstupních bodů reactových aplikací vypadá obdobně: pomocí
funkce <code>createRoot</code> označíme místo ve stránce, do kterého
necháme React generovat obsah prostřednictvím komponent. Zpravidla
nepoužíváme celé <code>&lt;body&gt;</code>, ale jen nějakou pod-značku
(jako zde <code>&lt;main&gt;</code>). To proto, aby nám zůstala možnost
některé další části dokumentu spravovat bez použití Reactu.</p>
<p>Na druhém řádku pak importujeme hlavní komponentu, která zastřešuje
celou aplikaci. V parametru funkce <code>render</code> již vidíme jazyk
JSX v akci, když tuto komponentu předáváme jako parametr. Podívejme se
na její implementaci:</p>
<div class="sourceCode" id="cb194"><pre
class="sourceCode jsx"><code class="sourceCode javascriptreact"><span id="cb194-1"><a href="#cb194-1" aria-hidden="true" tabindex="-1"></a><span class="co">// App.jsx</span></span>
<span id="cb194-2"><a href="#cb194-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> { useState } <span class="im">from</span> <span class="st">&quot;react&quot;</span><span class="op">;</span></span>
<span id="cb194-3"><a href="#cb194-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> Results <span class="im">from</span> <span class="st">&quot;./Results.jsx&quot;</span><span class="op">;</span></span>
<span id="cb194-4"><a href="#cb194-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb194-5"><a href="#cb194-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb194-6"><a href="#cb194-6" aria-hidden="true" tabindex="-1"></a><span class="im">export</span> <span class="im">default</span> <span class="kw">function</span> <span class="fu">App</span>() {</span>
<span id="cb194-7"><a href="#cb194-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> [results<span class="op">,</span> setResults] <span class="op">=</span> <span class="fu">useState</span>({})<span class="op">;</span></span>
<span id="cb194-8"><a href="#cb194-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb194-9"><a href="#cb194-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">async</span> <span class="kw">function</span> <span class="fu">onSubmit</span>(e) {</span>
<span id="cb194-10"><a href="#cb194-10" aria-hidden="true" tabindex="-1"></a>    e<span class="op">.</span><span class="fu">preventDefault</span>()<span class="op">;</span></span>
<span id="cb194-11"><a href="#cb194-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> query <span class="op">=</span> <span class="pp">encodeURIComponent</span>(e<span class="op">.</span><span class="at">target</span><span class="op">.</span><span class="at">elements</span><span class="op">.</span><span class="at">query</span><span class="op">.</span><span class="at">value</span>)<span class="op">;</span></span>
<span id="cb194-12"><a href="#cb194-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> response <span class="op">=</span> <span class="cf">await</span> <span class="fu">fetch</span>(<span class="vs">`/search?query=</span><span class="sc">${</span>query<span class="sc">}</span><span class="vs">`</span>)<span class="op">;</span></span>
<span id="cb194-13"><a href="#cb194-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> results <span class="op">=</span> <span class="cf">await</span> response<span class="op">.</span><span class="fu">json</span>()<span class="op">;</span></span>
<span id="cb194-14"><a href="#cb194-14" aria-hidden="true" tabindex="-1"></a>    <span class="fu">setResults</span>({results<span class="op">,</span> query})<span class="op">;</span></span>
<span id="cb194-15"><a href="#cb194-15" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb194-16"><a href="#cb194-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb194-17"><a href="#cb194-17" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return </span><span class="kw">&lt;&gt;</span></span>
<span id="cb194-18"><a href="#cb194-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">&lt;h1&gt;</span>Hledání<span class="kw">&lt;/h1&gt;</span></span>
<span id="cb194-19"><a href="#cb194-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">&lt;form</span> <span class="ot">onSubmit</span><span class="op">=</span><span class="va">{</span>onSubmit<span class="va">}</span><span class="kw">&gt;</span></span>
<span id="cb194-20"><a href="#cb194-20" aria-hidden="true" tabindex="-1"></a>      <span class="kw">&lt;label&gt;</span></span>
<span id="cb194-21"><a href="#cb194-21" aria-hidden="true" tabindex="-1"></a>        Hledaný výraz: <span class="kw">&lt;input</span> <span class="ot">type</span><span class="op">=</span><span class="st">&quot;text&quot;</span> <span class="ot">name</span><span class="op">=</span><span class="st">&quot;query&quot;</span> <span class="kw">/&gt;</span></span>
<span id="cb194-22"><a href="#cb194-22" aria-hidden="true" tabindex="-1"></a>      <span class="kw">&lt;/label&gt;</span></span>
<span id="cb194-23"><a href="#cb194-23" aria-hidden="true" tabindex="-1"></a>      <span class="kw">&lt;label&gt;</span></span>
<span id="cb194-24"><a href="#cb194-24" aria-hidden="true" tabindex="-1"></a>        <span class="kw">&lt;button&gt;</span>🔎<span class="kw">&lt;/button&gt;</span></span>
<span id="cb194-25"><a href="#cb194-25" aria-hidden="true" tabindex="-1"></a>      <span class="kw">&lt;/label&gt;</span></span>
<span id="cb194-26"><a href="#cb194-26" aria-hidden="true" tabindex="-1"></a>    <span class="kw">&lt;/form&gt;</span></span>
<span id="cb194-27"><a href="#cb194-27" aria-hidden="true" tabindex="-1"></a>    <span class="fu">&lt;Results</span> <span class="ot">data</span><span class="op">=</span><span class="va">{</span>results<span class="va">}</span> <span class="fu">/&gt;</span></span>
<span id="cb194-28"><a href="#cb194-28" aria-hidden="true" tabindex="-1"></a>  <span class="kw">&lt;/&gt;</span><span class="op">;</span></span>
<span id="cb194-29"><a href="#cb194-29" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Nenechme se zastrašit větším množstvím nezvyklých konstrukcí a pojďme
si je po částech rozebrat. Poslední část funkce <code>App</code>
definuje výsledné HTML, resp. výsledné JSX. To odpovídá přístupu
<strong>komponenty jsou funkce, které transformují vstup na
HTML</strong>. Každá komponenta musí vrátit jen jeden prvek, takže pokud
chceme vykreslit více HTML (nadpis, formulář, výsledky), musíme je
zabalit do společného <em>bezejmenného</em> obalu, který se v JSX
zapisuje jako <code>&lt;&gt;...&lt;/&gt;</code>.</p>
<p>Na konci HTML používáme další vlastní komponentu
(<code>&lt;Results&gt;</code>), ke které se dostaneme za chvíli. Syntaxe
se složenými závorkami odpovídá interpolaci hodnot z proměnných;
zápis</p>
<div class="sourceCode" id="cb195"><pre
class="sourceCode jsx"><code class="sourceCode javascriptreact"><span id="cb195-1"><a href="#cb195-1" aria-hidden="true" tabindex="-1"></a><span class="fu">&lt;Results</span> <span class="ot">data</span><span class="op">=</span><span class="va">{</span>results<span class="va">}</span> <span class="fu">/&gt;</span></span></code></pre></div>
<p>tedy znamená, že zde chceme vykreslit zadanou komponentu a předat jí
obsah lokální proměnné <code>results</code>.</p>
<p>Samotné hledání provede funkce <code>onSubmit</code>, kterou pro
jednoduchost implementujeme pomocí <code>fetch</code>. Je to posluchač
události, který v JSX přidáváme atributem <code>onSubmit</code>. Uvnitř
této funkce potřebujeme přistoupit k hodnotě z vyhledávacího pole.
Nemůžeme použít běžné dotazování pomocí <code>querySelector</code>,
neboť celou tvorbu stromu DOMu za nás řeší React. Využijeme proto klíč
<code>e.target</code>, který odpovídá odesílanému formuláři. Jeho
vlastnost <code>elements</code> pak dovoluje přistoupit k jednotlivým
formulářovým prvkům pomocí jejich jména (tedy HTML atributu
<code>name</code>). Výsledný dotaz je zaslán na server a po obdržení
odpovědi se zavolá funkce <code>setResults</code>, která aktualizuje
stav aplikace.</p>
<p>V tuto chvíli je dobré poznamenat, že React nabízí i další způsoby,
jak se v rámci posluchače dostat k hodnotě z formulářového pole.
Představené řešení je sice funkční, ale v praxi můžeme narazit na
odlišné varianty. Zmiňme pro inspiraci dvě z nich:</p>
<ol type="1">
<li><p>Formulářovému poli <code>&lt;input&gt;</code> můžeme přidat
posluchač na změnu hodnoty (DOM událost <code>input</code>). V rámci
posluchače je pak zadaný text dostupný jako <code>e.target.value</code>
a my si jej můžeme například uložit do lokální proměnné.</p></li>
<li><p>K jednotlivým Reactem vytvořeným HTML prvkům se můžeme dostat
pomocí tzv. <em>referencí</em> vytvářených reactovou funkcí
<code>useRef</code>. Lze si je představit jako samolepky, kterými pomocí
atributu <code>ref</code> označíme prvky v JSX a díky nim se pak
dostaneme k jim odpovídajícím DOM objektům.</p></li>
</ol>
<p>Poslední specialita v souboru <code>App.jsx</code> je funkce
<code>useState</code>. Připomeňme, že hlavní úkol Reactu je převést naše
data na HTML. Ideálně bychom rádi, aby komponenta tuto operaci provedla
automaticky vždy, když její vstupní data změníme. Pouhá změna hodnoty
v proměnné (jako např. <code>results</code>) k tomu ale nestačí, protože
React se o takové změně nedozví. Zde vstupuje do hry funkce
<code>useState</code>, která vytvoří navzájem provázanou dvojici
proměnných: jednu pro hodnotu a jednu pro jí odpovídající funkci určenou
ke změně hodnoty. Jakmile funkci zavoláme, hodnota se změní a <em>React
dostane pokyn k překreslení</em>.</p>
<p>Mimochodem: využíváme zde zkrácený zápis definice objektu, který jsme
poprvé potkali v osmé kapitole, konkrétně v její podkapitole pro
zelenáče. Do funkce <code>setResults</code> tedy předáváme
<code>{results:results, query:query}</code>.</p>
<p>Pokračujme ke komponentě <code>&lt;Results&gt;</code> v souboru
<code>Results.jsx</code>:</p>
<div class="sourceCode" id="cb196"><pre
class="sourceCode jsx"><code class="sourceCode javascriptreact"><span id="cb196-1"><a href="#cb196-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Results.jsx</span></span>
<span id="cb196-2"><a href="#cb196-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> Result <span class="im">from</span> <span class="st">&quot;./Result.jsx&quot;</span><span class="op">;</span></span>
<span id="cb196-3"><a href="#cb196-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb196-4"><a href="#cb196-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb196-5"><a href="#cb196-5" aria-hidden="true" tabindex="-1"></a><span class="im">export</span> <span class="im">default</span> <span class="kw">function</span> <span class="fu">Results</span>(props) {</span>
<span id="cb196-6"><a href="#cb196-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">const</span> { query<span class="op">,</span> results } <span class="op">=</span> props<span class="op">.</span><span class="at">data</span><span class="op">;</span></span>
<span id="cb196-7"><a href="#cb196-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb196-8"><a href="#cb196-8" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (<span class="op">!</span>query) { <span class="cf">return</span><span class="op">;</span> }</span>
<span id="cb196-9"><a href="#cb196-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb196-10"><a href="#cb196-10" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (<span class="op">!</span>results<span class="op">.</span><span class="at">length</span>) {</span>
<span id="cb196-11"><a href="#cb196-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return </span><span class="kw">&lt;p&gt;</span>Tomuto dotazu nevyhovují žádné písně 🙁<span class="kw">&lt;/p&gt;</span><span class="op">;</span></span>
<span id="cb196-12"><a href="#cb196-12" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb196-13"><a href="#cb196-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb196-14"><a href="#cb196-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> items <span class="op">=</span> results<span class="op">.</span><span class="fu">map</span>(item <span class="kw">=&gt; </span><span class="fu">&lt;Result</span> <span class="ot">data</span><span class="op">=</span><span class="va">{</span>item<span class="va">}</span> <span class="fu">/&gt;</span>)<span class="op">;</span></span>
<span id="cb196-15"><a href="#cb196-15" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return </span><span class="kw">&lt;&gt;</span></span>
<span id="cb196-16"><a href="#cb196-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">&lt;h2&gt;</span>Nalezené písně pro dotaz: <span class="va">{</span>query<span class="va">}</span><span class="kw">&lt;/h2&gt;</span></span>
<span id="cb196-17"><a href="#cb196-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">&lt;ol&gt;</span><span class="va">{</span>items<span class="va">}</span><span class="kw">&lt;/ol&gt;</span></span>
<span id="cb196-18"><a href="#cb196-18" aria-hidden="true" tabindex="-1"></a>  <span class="kw">&lt;/&gt;</span><span class="op">;</span></span>
<span id="cb196-19"><a href="#cb196-19" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Zde žádná velká překvapení nejsou. JSX atributy, které komponentě
předáváme, jsou v odpovídající JS funkci dostupné jako vlastnosti
objektu předaného v prvním parametru. Bývá obvyklé jej pojmenovat
<strong>props</strong> (z anglického <em>properties</em>). Pro následné
rozdělení dat do lokálních proměnných používáme destructuring (slyšeli
jsme o něm v jedenácté kapitole).</p>
<p>Komponenta <code>&lt;Results&gt;</code> zastřešuje tři různé stavy
(nebylo hledáno / nejsou výsledky / jsou výsledky), čemuž odpovídají
jednotlivé podmínky. V případě nalezených výsledků vidíme cyklus
realizovaný funkcionální metodou <code>map</code>. To znamená, že ve
výsledném JSX interpolujeme proměnnou <code>items</code>, která je pole
komponent typu <code>&lt;Result&gt;</code>. Ty jsou definovány
v posledním souboru <code>Result.jsx</code>:</p>
<div class="sourceCode" id="cb197"><pre
class="sourceCode jsx"><code class="sourceCode javascriptreact"><span id="cb197-1"><a href="#cb197-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Result.jsx</span></span>
<span id="cb197-2"><a href="#cb197-2" aria-hidden="true" tabindex="-1"></a><span class="im">export</span> <span class="im">default</span> <span class="kw">function</span> <span class="fu">Result</span>(props) {</span>
<span id="cb197-3"><a href="#cb197-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> html <span class="op">=</span> {<span class="dt">__html</span><span class="op">:</span> props<span class="op">.</span><span class="at">data</span><span class="op">.</span><span class="at">text</span>}<span class="op">;</span></span>
<span id="cb197-4"><a href="#cb197-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return </span><span class="kw">&lt;li&gt;</span></span>
<span id="cb197-5"><a href="#cb197-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">&lt;a</span> <span class="ot">href</span><span class="op">=</span><span class="va">{</span>props<span class="op">.</span><span class="at">data</span><span class="op">.</span><span class="at">url</span><span class="va">}</span><span class="kw">&gt;</span><span class="va">{</span>props<span class="op">.</span><span class="at">data</span><span class="op">.</span><span class="at">title</span><span class="va">}</span><span class="kw">&lt;/a&gt;</span></span>
<span id="cb197-6"><a href="#cb197-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">&lt;br/&gt;</span></span>
<span id="cb197-7"><a href="#cb197-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">&lt;span</span> <span class="ot">dangerouslySetInnerHTML</span><span class="op">=</span><span class="va">{</span>html<span class="va">}</span> <span class="kw">/&gt;</span></span>
<span id="cb197-8"><a href="#cb197-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">&lt;/li&gt;</span><span class="op">;</span></span>
<span id="cb197-9"><a href="#cb197-9" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Vzpomeňme si na šestou kapitolu, ve které jsme narazili na koncept
<code>innerHTML</code> a jeho potenciální důsledky pro bezpečnost
aplikace. React se nás snaží od podobného postupu odradit, takže přímé
vložení HTML kódu z proměnné je nezvykle složité:</p>
<ul>
<li><p>Nejprve musíme nachystat objekt s klíčem <code>__html</code>,
jehož hodnota je náš řetězec obsahující (potenciálně rizikové)
HTML.</p></li>
<li><p>Poté tento objekt předáme atributu
<code>dangerouslySetInnerHTML</code>, jehož výmluvné označení varuje, že
jde o nebezpečnou operaci.</p></li>
</ul>
<p>Co dál? Napsaný kód je docela složitý a prohlížeč mu nerozumí. Jednak
nezná syntaxi JSX, jednak neví, jak importovat
z <code>"react-dom/client"</code> (vzpomeňme na serverové importy
z minulé kapitoly). Budeme muset použít nějaký nástroj, který JSX
převede na použitelný JavaScript.</p>
<p>Z minulé kapitoly známe program <code>esbuild</code> (používali jsme
jej k <em>bundlingu</em>). Teď se nám hodí, že <code>esbuild</code>
dokáže mimo jiné zpracovávat soubory JSX a také používat závislosti
z adresáře <code>node_modules</code>. Použijeme proto <code>npm</code>
a nainstalujeme několik balíčků:</p>
<div class="sourceCode" id="cb198"><pre
class="sourceCode sh"><code class="sourceCode bash"><span id="cb198-1"><a href="#cb198-1" aria-hidden="true" tabindex="-1"></a><span class="ex">npm</span> i <span class="at">-g</span> esbuild       <span class="co"># zpracování JSX, bundling</span></span>
<span id="cb198-2"><a href="#cb198-2" aria-hidden="true" tabindex="-1"></a><span class="ex">npm</span> i react react-dom  <span class="co"># součásti reactu</span></span></code></pre></div>
<p>Nástroj <code>esbuild</code> instalujeme globálně, zatímco React
a React-DOM lokálně do <code>node_modules</code>. Teď zbývá jen
vygenerovat celou aplikaci:</p>
<div class="sourceCode" id="cb199"><pre
class="sourceCode sh"><code class="sourceCode bash"><span id="cb199-1"><a href="#cb199-1" aria-hidden="true" tabindex="-1"></a><span class="ex">esbuild</span> <span class="at">--bundle</span> index.jsx <span class="at">--jsx</span><span class="op">=</span>automatic <span class="at">--outfile</span><span class="op">=</span>index.js</span></code></pre></div>
<p>Na závěr poznamenejme, že kompilace z JSX do JS je dnes dostupná
prostřednictvím celé řady programů. Kromě zmiňovaného
<code>esbuild</code> se často používají alternativy jako
<code>babel</code>, <code>swc</code>, <code>rollup</code> nebo
<code>tsc</code>, kterému se budeme věnovat v následující
podkapitole.</p>
<h2 id="koumáci-typescript">Koumáci: TypeScript</h2>
<p>Pojďme si nyní prohlédnout další jazyk, který je dnes s JavaScriptem
neodmyslitelně spojen. TypeScript vznikl jako nadmnožina JavaScriptu, ve
které můžeme k proměnným a funkcím volitelně přidávat informace o jejich
datovém typu. Říká se jim <strong>typové anotace</strong> a můžeme je
znát i z dalších jazyků, jako např. Python či PHP. V JavaScriptu však
typové anotace neexistují, takže kód psaný v TypeScriptu nemůžeme rovnou
předhodit prohlížeči. Podobně jako u JSX je nutné nejprve kód převést na
JavaScript. Tentokrát je ale převod velmi snadný, protože typicky
zahrnuje pouze smazání typových anotací.</p>
<p>A proč to celé vlastně chceme dělat? TypeScript je odpovědí na
dynamické typování JavaScriptu, které je pro mnoho vývojářů až příliš
flexibilní. Kvůli němu nelze rychlým pohledem na proměnnou či funkci
odhadnout, jakých hodnot může nabývat. Snadno se pak vystavujeme riziku,
že budeme nějakou hodnotu mylně považovat za jiný datový typ a dopustíme
se různých chyb (např. výjimek způsobujících přerušení běhu
programu).</p>
<p>S typovými anotacemi se v TypeScriptu setkáváme dvakrát. Když
převádíme kód z TypeScriptu do JavaScriptu, kompilátor anotace nejen
odstraní, ale také s jejich pomocí zkontroluje, zdali neporušujeme jimi
definovaná pravidla – jestli třeba do proměnné označené jako
<em>string</em> nevkládáme číslo. Zároveň ale anotace používáme již při
samotném psaní kódu, pokud si správně nastavíme editor. Ten může na
základě typových informací rovnou označovat bloky problematického kódu,
případně napovídat typy a názvy parametrů funkcí a podobně.</p>
<p>Zdrojový kód v TypeScriptu píšeme do souborů s příponou
<code>.ts</code>. Nejčastěji se typové anotace objevují za dvojtečkou,
za názvem proměnné či parametru funkce. Můžeme si to vyzkoušet na
příkladu triviální sčítací funkce:</p>
<div class="sourceCode" id="cb200"><pre
class="sourceCode ts"><code class="sourceCode typescript"><span id="cb200-1"><a href="#cb200-1" aria-hidden="true" tabindex="-1"></a><span class="co">// test.ts</span></span>
<span id="cb200-2"><a href="#cb200-2" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">add</span>(a<span class="op">:</span> <span class="dt">number</span><span class="op">,</span> b<span class="op">:</span> <span class="dt">number</span>)<span class="op">:</span> <span class="dt">number</span> {</span>
<span id="cb200-3"><a href="#cb200-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> a<span class="op">+</span>b<span class="op">;</span></span>
<span id="cb200-4"><a href="#cb200-4" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Typové anotace jsme přidali jak k oběma parametrům, tak k funkci jako
takové – říkáme tím, že její návratová hodnota je číslo. Na chování kódu
anotace nemají žádný vliv, takže pokud bychom funkci předali dva
řetězce, dojde k jejich (pravděpodobně chybnému) spojení. Proto bychom
rádi, aby nás nějaká komponenta zavčasu (na základě anotací) upozornila,
že funkci voláme špatně. Nejprve napíšeme problémový kód:</p>
<div class="sourceCode" id="cb201"><pre
class="sourceCode ts"><code class="sourceCode typescript"><span id="cb201-1"><a href="#cb201-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> a <span class="op">=</span> <span class="st">&quot;protřepat&quot;</span><span class="op">;</span></span>
<span id="cb201-2"><a href="#cb201-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> b <span class="op">=</span> <span class="st">&quot;nemíchat&quot;</span><span class="op">;</span></span>
<span id="cb201-3"><a href="#cb201-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> c <span class="op">=</span> <span class="fu">add</span>(a<span class="op">,</span> b)<span class="op">;</span></span></code></pre></div>
<p>Dobře nastavené vývojové prostředí by nás už nyní mělo varovat, že
funkci voláme chybně. My nyní ale stojíme o kontrolu spojenou s převodem
do prostého JavaScriptu. K tomu použijeme oficiální kompilátor
<strong>tsc</strong> (TypeScript Compiler). Nainstalujeme jej pomocí
npm:</p>
<div class="sourceCode" id="cb202"><pre
class="sourceCode sh"><code class="sourceCode bash"><span id="cb202-1"><a href="#cb202-1" aria-hidden="true" tabindex="-1"></a><span class="ex">npm</span> i <span class="at">-g</span> typescript</span></code></pre></div>
<p>Pro spuštění kompilace stačí předat jméno souboru s TypeScriptovým
kódem:</p>
<div class="sourceCode" id="cb203"><pre
class="sourceCode sh"><code class="sourceCode bash"><span id="cb203-1"><a href="#cb203-1" aria-hidden="true" tabindex="-1"></a><span class="ex">tsc</span> test.ts</span>
<span id="cb203-2"><a href="#cb203-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb203-3"><a href="#cb203-3" aria-hidden="true" tabindex="-1"></a><span class="ex">test.ts:6:13</span> <span class="at">-</span> error TS2345: Argument of type <span class="st">&#39;string&#39;</span> is not assignable to parameter of type <span class="st">&#39;number&#39;</span>.</span></code></pre></div>
<p>Dostali jsme vynadáno přesně dle očekávání. Zároveň s tím ale vznikl
soubor <code>test.js</code>, který obsahuje náš chybný kód bez anotací.
Kompilátor nám tedy nebrání v psaní pochybného kódu, ale pokud mu k tomu
dáme příležitost, upozorní nás na problematická místa.</p>
<p>Mimochodem: v minulých kapitolách a podkapitolách jsme používali
nástroj <code>esbuild</code>, který mj. provádí <em>bundling</em>
a transpilaci JSX. Zvídavého čtenáře možná napadne, zdali by pomocí
<code>esbuild</code> nešel kompilovat i zdrojový kód v TypeScriptu.
Odpověď je <em>ano, ale</em> – esbuild sice dovede odstranit typové
anotace, ale neprovede při tom typovou kontrolu. Dostáváme tak jen
polovinu funkcionality, kterou nám nabízí <code>tsc</code>.</p>
<p>Jazyk TypeScript je od počátku zamýšlen pro dobrovolné, pozvolné
vylepšování JavaScriptového kódu. Pokud máme hotový projekt a rádi
bychom do něj TypeScript zavedli, můžeme tak činit po malých krůčcích
bez obav, že něco pokazíme. Program <code>tsc</code> lze vykonat i nad
kódem, ve kterém typové anotace vůbec nejsou, nebo jsme je doplnili jen
občasně. Součástí TypeScriptu je totiž tzv. <strong>typová
inference</strong>, což znamená schopnost kompilátoru domyslet si v řadě
případů datové typy podle toho, jakým způsobem s proměnnými pracujeme.
Pokud například do proměnné při definici rovnou přiřadíme hodnotu,
TypeScript odvodí její datový typ a bude s ním pracovat při dalších
manipulacích s touto proměnnou:</p>
<div class="sourceCode" id="cb204"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb204-1"><a href="#cb204-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> a <span class="op">=</span> <span class="st">&quot;ahoj&quot;</span><span class="op">;</span></span>
<span id="cb204-2"><a href="#cb204-2" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> <span class="dv">42</span><span class="op">;</span>  <span class="co">// Warning: Type &#39;number&#39; is not assignable to type &#39;string&#39;.</span></span></code></pre></div>
<p>Stejně jako v minulé podkapitole, i nyní můžeme zkusit upravit
vzorový kód z šesté kapitoly. Potřebujeme doplnit typové anotace tak,
aby byl jasný datový typ každé proměnné a aby kompilátor nehlásil žádnou
chybu. Hlavní data, se kterými pracujeme, jsou výsledky hledání. Na
základě dohody s backendovou stranou aplikace víme, že se bude jednat
o slovník s konkrétními položkami. Takový datový typ můžeme
v TypeScriptu vyjádřit klíčovým slovem <code>interface</code>:</p>
<div class="sourceCode" id="cb205"><pre
class="sourceCode ts"><code class="sourceCode typescript"><span id="cb205-1"><a href="#cb205-1" aria-hidden="true" tabindex="-1"></a><span class="kw">interface</span> Song {</span>
<span id="cb205-2"><a href="#cb205-2" aria-hidden="true" tabindex="-1"></a>  url<span class="op">:</span> <span class="dt">string</span><span class="op">;</span></span>
<span id="cb205-3"><a href="#cb205-3" aria-hidden="true" tabindex="-1"></a>  title<span class="op">:</span> <span class="dt">string</span><span class="op">;</span></span>
<span id="cb205-4"><a href="#cb205-4" aria-hidden="true" tabindex="-1"></a>  text<span class="op">:</span> <span class="dt">string</span><span class="op">;</span></span>
<span id="cb205-5"><a href="#cb205-5" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb205-6"><a href="#cb205-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb205-7"><a href="#cb205-7" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">buildSong</span>(song<span class="op">:</span> Song) {</span>
<span id="cb205-8"><a href="#cb205-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> item <span class="op">=</span> <span class="bu">document</span><span class="op">.</span><span class="fu">createElement</span>(<span class="st">&quot;li&quot;</span>)<span class="op">;</span></span>
<span id="cb205-9"><a href="#cb205-9" aria-hidden="true" tabindex="-1"></a>  item<span class="op">.</span><span class="at">innerHTML</span> <span class="op">=</span> <span class="vs">`</span></span>
<span id="cb205-10"><a href="#cb205-10" aria-hidden="true" tabindex="-1"></a><span class="vs">    &lt;a href=&quot;</span><span class="sc">${</span>song<span class="op">.</span><span class="at">url</span><span class="sc">}</span><span class="vs">&quot;&gt;</span><span class="sc">${</span>song<span class="op">.</span><span class="at">title</span><span class="sc">}</span><span class="vs">&lt;/a&gt;</span></span>
<span id="cb205-11"><a href="#cb205-11" aria-hidden="true" tabindex="-1"></a><span class="vs">    &lt;br/&gt; </span><span class="sc">${</span>song<span class="op">.</span><span class="at">text</span><span class="sc">}</span></span>
<span id="cb205-12"><a href="#cb205-12" aria-hidden="true" tabindex="-1"></a><span class="vs">  `</span><span class="op">;</span></span>
<span id="cb205-13"><a href="#cb205-13" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> item<span class="op">;</span></span>
<span id="cb205-14"><a href="#cb205-14" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Dále přidáme typové informace do funkce, která je zodpovědná za
zpracování a zobrazení výsledků hledání:</p>
<div class="sourceCode" id="cb206"><pre
class="sourceCode ts"><code class="sourceCode typescript"><span id="cb206-1"><a href="#cb206-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">showResults</span>(xhr<span class="op">:</span> <span class="bu">XMLHttpRequest</span><span class="op">,</span> query<span class="op">:</span> <span class="dt">string</span>) {</span>
<span id="cb206-2"><a href="#cb206-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> results <span class="op">=</span> <span class="bu">document</span><span class="op">.</span><span class="fu">querySelector</span>(<span class="st">&quot;#results&quot;</span>)<span class="op">;</span></span>
<span id="cb206-3"><a href="#cb206-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (<span class="op">!</span>results) { <span class="cf">return</span><span class="op">;</span> }</span>
<span id="cb206-4"><a href="#cb206-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb206-5"><a href="#cb206-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> songs <span class="op">=</span> xhr<span class="op">.</span><span class="at">response</span> <span class="im">as</span> Song[]<span class="op">;</span></span>
<span id="cb206-6"><a href="#cb206-6" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (songs<span class="op">.</span><span class="at">length</span> <span class="op">==</span> <span class="dv">0</span>) {</span>
<span id="cb206-7"><a href="#cb206-7" aria-hidden="true" tabindex="-1"></a>    results<span class="op">.</span><span class="fu">replaceChildren</span>(<span class="st">&quot;Dotazu nevyhovují žádné písně 🙁&quot;</span>)<span class="op">;</span></span>
<span id="cb206-8"><a href="#cb206-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span><span class="op">;</span></span>
<span id="cb206-9"><a href="#cb206-9" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb206-10"><a href="#cb206-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb206-11"><a href="#cb206-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> heading <span class="op">=</span> <span class="bu">document</span><span class="op">.</span><span class="fu">createElement</span>(<span class="st">&quot;h2&quot;</span>)<span class="op">;</span></span>
<span id="cb206-12"><a href="#cb206-12" aria-hidden="true" tabindex="-1"></a>  heading<span class="op">.</span><span class="at">textContent</span> <span class="op">=</span> <span class="vs">`Nalezené písně pro dotaz: </span><span class="sc">${</span>query<span class="sc">}</span><span class="vs">`</span><span class="op">;</span></span>
<span id="cb206-13"><a href="#cb206-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb206-14"><a href="#cb206-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> ol <span class="op">=</span> <span class="bu">document</span><span class="op">.</span><span class="fu">createElement</span>(<span class="st">&quot;ol&quot;</span>)<span class="op">;</span></span>
<span id="cb206-15"><a href="#cb206-15" aria-hidden="true" tabindex="-1"></a>  results<span class="op">.</span><span class="fu">replaceChildren</span>(heading<span class="op">,</span> ol)<span class="op">;</span></span>
<span id="cb206-16"><a href="#cb206-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb206-17"><a href="#cb206-17" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> (<span class="kw">let</span> i<span class="op">=</span><span class="dv">0</span><span class="op">;</span> i<span class="op">&lt;</span>songs<span class="op">.</span><span class="at">length</span><span class="op">;</span> i<span class="op">++</span>) {</span>
<span id="cb206-18"><a href="#cb206-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> song <span class="op">=</span> <span class="fu">buildSong</span>(songs[i])<span class="op">;</span></span>
<span id="cb206-19"><a href="#cb206-19" aria-hidden="true" tabindex="-1"></a>    ol<span class="op">.</span><span class="fu">append</span>(song)<span class="op">;</span></span>
<span id="cb206-20"><a href="#cb206-20" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb206-21"><a href="#cb206-21" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>TypeScript je obeznámen s vestavěnými objekty rozhraní DOM, takže
u prvního parametru můžeme rovnou psát <code>xhr: XMLHttpRequest</code>.
Další důležitá novinka se objevuje hned na prvním řádku funkce
<code>showResults</code>, kdy je nutné věnovat více pozornosti metodě
<code>querySelector</code>. Může se totiž snadno stát, že tato metoda
nevrátí použitelnou hodnotu – když ve stránce takový prvek není nebo
třeba když uděláme překlep v zadaném selektoru. Pokud chceme s proměnnou
<code>results</code> nadále pracovat, musíme mít jistotu, že je
neprázdná. Proto přidáme na další řádek podmínku a vykonávání případně
ukončíme.</p>
<p>Hodnota <code>xhr.response</code> může být jakákoliv, neboť z našeho
kódu neumíme ovlivnit data, která server vygeneruje. Nemáme proto žádnou
jistotu, že proměnná <code>songs</code> je opravdu pole struktur typu
<code>Song</code>. Zápisem <code>as Song[]</code> kompilátoru říkáme, ať
pro potřeby kontroly typů předpokládá, že tomu tak opravdu je. Kdybychom
chtěli, mohli bychom ještě dodat explicitní kód, který by příchozí data
prošel a zkontroloval.</p>
<p>Zbývá vylepšení poslední části kódu, kdy reagujeme na odeslání
hledacího formuláře. Jedná se o posluchač události
<code>submit</code>:</p>
<div class="sourceCode" id="cb207"><pre
class="sourceCode ts"><code class="sourceCode typescript"><span id="cb207-1"><a href="#cb207-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">onSubmit</span>(e<span class="op">:</span> <span class="bu">Event</span>) {</span>
<span id="cb207-2"><a href="#cb207-2" aria-hidden="true" tabindex="-1"></a>  e<span class="op">.</span><span class="fu">preventDefault</span>()<span class="op">;</span></span>
<span id="cb207-3"><a href="#cb207-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> xhr <span class="op">=</span> <span class="kw">new</span> <span class="bu">XMLHttpRequest</span>()<span class="op">;</span></span>
<span id="cb207-4"><a href="#cb207-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> input <span class="op">=</span> form<span class="op">.</span><span class="fu">querySelector</span><span class="op">&lt;</span><span class="bu">HTMLInputElement</span><span class="op">&gt;</span>(<span class="st">&quot;[name=query]&quot;</span>)<span class="op">;</span></span>
<span id="cb207-5"><a href="#cb207-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (<span class="op">!</span>input) { <span class="cf">return</span><span class="op">;</span> }</span>
<span id="cb207-6"><a href="#cb207-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> query <span class="op">=</span> input<span class="op">.</span><span class="at">value</span><span class="op">;</span></span>
<span id="cb207-7"><a href="#cb207-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> url <span class="op">=</span> <span class="vs">`/search?query=</span><span class="sc">${</span><span class="pp">encodeURIComponent</span>(query)<span class="sc">}</span><span class="vs">`</span><span class="op">;</span></span>
<span id="cb207-8"><a href="#cb207-8" aria-hidden="true" tabindex="-1"></a>  xhr<span class="op">.</span><span class="at">responseType</span> <span class="op">=</span> <span class="st">&quot;json&quot;</span><span class="op">;</span></span>
<span id="cb207-9"><a href="#cb207-9" aria-hidden="true" tabindex="-1"></a>  xhr<span class="op">.</span><span class="fu">open</span>(<span class="st">&quot;GET&quot;</span><span class="op">,</span> url)<span class="op">;</span></span>
<span id="cb207-10"><a href="#cb207-10" aria-hidden="true" tabindex="-1"></a>  xhr<span class="op">.</span><span class="fu">send</span>()<span class="op">;</span></span>
<span id="cb207-11"><a href="#cb207-11" aria-hidden="true" tabindex="-1"></a>  xhr<span class="op">.</span><span class="fu">addEventListener</span>(<span class="st">&quot;load&quot;</span><span class="op">,</span> e <span class="kw">=&gt;</span> <span class="fu">showResults</span>(xhr<span class="op">,</span> query))<span class="op">;</span></span>
<span id="cb207-12"><a href="#cb207-12" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Kromě kontroly návratové hodnoty <code>querySelector</code> zde
narážíme na další komplikaci. Různé HTML prvky mají různé JavaScriptové
vlastnosti, takže jednou nám funkce <code>querySelector</code> může
vrátit třeba obrázek (ten má mj. vlastnost <code>src</code>), zatímco
jindy vrátí prvek <code>&lt;input&gt;</code> (který má vlastnost
<code>value</code>). TypeScriptový kompilátor je v tomto směru bezradný,
takže mu napovíme pomocí tzv. <strong>typového parametru</strong>.
Zápisem <code>querySelector&lt;HTMLInputElement&gt;</code> říkáme, že
počítáme s tím, že návratová hodnota bude zadaného typu (a proto je
v pořádku u ní následně pracovat s vlastností <code>value</code>).</p>
<p>Úplně na konec přidáme posluchač na formulář a při tom si ukážeme
ještě jeden syntaktický prvek ze světa TypeScriptu:</p>
<div class="sourceCode" id="cb208"><pre
class="sourceCode ts"><code class="sourceCode typescript"><span id="cb208-1"><a href="#cb208-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> form <span class="op">=</span> <span class="bu">document</span><span class="op">.</span><span class="fu">querySelector</span>(<span class="st">&quot;form&quot;</span>)<span class="op">!;</span></span>
<span id="cb208-2"><a href="#cb208-2" aria-hidden="true" tabindex="-1"></a>form<span class="op">.</span><span class="fu">addEventListener</span>(<span class="st">&quot;submit&quot;</span><span class="op">,</span> onSubmit)<span class="op">;</span></span></code></pre></div>
<p>Víme, že funkce <code>querySelector</code> vrací buď HTML prvek, nebo
<code>null</code>. Vykřičníkem říkáme, ať TypeScript možnost
s <code>null</code> neuvažuje. I zde bychom mohli prostě použít podmínku
(náš kód by byl robustnější!), ale vytvořili bychom tak komplikaci pro
již upravený posluchač <code>onSubmit</code>. V něm se totiž, díky
uzávěře, s proměnnou <code>form</code> taktéž pracuje. Kdyby její
hodnota nebyla jistá, museli bychom s ní opatrně pracovat i uvnitř
posluchače. My jako programátoři víme, že pokud se posluchač vykoná,
proměnná <code>form</code> existuje – TypeScript to ale za nás vymyslet
nedokáže.</p>
<h2 id="profíci-webassembly">Profíci: WebAssembly</h2>
<p>Programovacích jazyků je kolem nás velké množství, a přesto je možné
v rámci webového prohlížeče psát aplikační kód jen v JavaScriptu. Říkáme
si, proč nemáme k dispozici i další možnosti jako například Python, Go
nebo třeba Ruby. Jakkoliv by bylo zavedení dalšího jazyka do prohlížeče
praktické, jedná se o příliš komplikovaný úkol – znamenalo by to, že
všechny prohlížeče musí přijít s identickou implementací zvoleného
jazyka a zároveň pro něj poskytovat všechna rozhraní, se kterými jsme
v JavaScriptu navyklí pracovat (DOM, práce se sítí, Canvas, Web Audio,
…).</p>
<p>Namísto integrace nějakého dalšího konkrétního programovacího jazyka
je pro nás ovšem dostupná trochu jiná možnost: prohlížeče dokážou
zpracovávat kód ve speciálním tvaru <strong>WebAssembly</strong>. Jde
o binární formát, který popisuje jednotlivé instrukce virtuálního
procesoru, a v porovnání s JavaScriptem je tedy velmi nízkoúrovňový.
Jeho výhoda tkví v tom, že do WebAssembly lze kompilovat programy psané
v celé řadě jiných jazyků, zejména C, C++ a Rust. V prohlížeči pak
nemusí existovat implementace těchto jazyků – převod do WebAssembly musí
provést vývojář bokem před tím, než vzniklý kód ke stránce připojí.</p>
<p>Použitím WebAssembly se nám otevírají dvě hlavní nové možnosti:</p>
<ul>
<li><p>spuštění existujícího kódu, který je psaný v jiném jazyce,
v rámci webové stránky;</p></li>
<li><p>vytvoření aplikace či knihovny, kterou vykoná prohlížeč bez
nutnosti parsování a vykonávání JavaScriptu (vyšší výkon, předvídatelné
chování napříč prohlížeči).</p></li>
</ul>
<p>U velkých webových aplikací není neobvyklé, když některé jejich
součásti tvoří JavaScript (zejména ty, které pracují s uživatelským
rozhraním) a jiné zase Web­Assembly (třeba ty, které provádí komplikované
operace nad velkým množstvím dat). Je ovšem dobré poznamenat, že práce
s WebAssembly je komplikovaná a vyplatí se jen tam, kde potřebujeme
maximální výkon nebo musíme spolupracovat s existujícím
ne-JavaScriptovým kódem. Když se chceme touto cestou vydat, čekají nás
především tyto kroky:</p>
<ol type="1">
<li><p>Zvolit vhodný zdrojový programovací jazyk. Musí k němu existovat
takový kompilátor, který dokáže vygenerovat výstup v jazyce WebAssembly,
tj. soubory s příponou <code>wasm</code>.</p></li>
<li><p>V rámci běžného klientského JavaScriptu načíst vzniklé
<code>wasm</code> soubory (typicky pomocí <code>fetch</code>).</p></li>
<li><p>Dodat potřebný podpůrný kód (tzv. <em>glue code</em>), který
poskytne přemostění mezi logikou WebAssembly a světem klientského
JavaScriptu. Pokud například ve WebAssembly chceme načítat data (po síti
nebo ze souborů), musíme tuto logiku dodat formou běžných
JavaScriptových funkcí. Naopak, načtené WebAssembly funkce budeme chtít
jistě volat z normálního JavaScriptu a předávat jim data uložená v JS
proměnných.</p></li>
</ol>
<p>V rámci této knihy se na WebAssembly podíváme jen v tom
nejjednodušším příkladu. Vytvoříme funkci v jazyce C, zkompilujeme ji do
WebAssembly a následně ji zavoláme z JavaScriptu. Pro jazyk C existuje
celá řada překladačů; my použijeme <strong>Emcscripten</strong>, který
převádí C/C++ právě do WebAssembly.</p>
<p>Kód naší knihovny bude nabízet jedinou funkci <code>my_sqrt</code>,
která implementuje celočíselnou odmocninu (a činí tak voláním funkce
<code>sqrt</code> ze standardní knihovny <code>math.h</code>). Může
vypada třeba takto:</p>
<div class="sourceCode" id="cb209"><pre
class="sourceCode c"><code class="sourceCode c"><span id="cb209-1"><a href="#cb209-1" aria-hidden="true" tabindex="-1"></a><span class="co">// my_sqrt.c</span></span>
<span id="cb209-2"><a href="#cb209-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb209-3"><a href="#cb209-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;math.h&gt;</span></span>
<span id="cb209-4"><a href="#cb209-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;emscripten.h&gt;</span></span>
<span id="cb209-5"><a href="#cb209-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb209-6"><a href="#cb209-6" aria-hidden="true" tabindex="-1"></a>EMSCRIPTEN_KEEPALIVE</span>
<span id="cb209-7"><a href="#cb209-7" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> my_sqrt<span class="op">(</span><span class="dt">int</span> x<span class="op">)</span> <span class="op">{</span></span>
<span id="cb209-8"><a href="#cb209-8" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> sqrt<span class="op">(</span>x<span class="op">);</span></span>
<span id="cb209-9"><a href="#cb209-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Makro <code>EMSCRIPTEN_KEEPALIVE</code> pochází z projektu překladače
Emscripten, který musíme na svém operačním systému zprovoznit. Jeho
účelem je označení těch funkcí, které chceme do výsledného WebAssembly
exportovat a zachovat (chytrý překladač by jinak funkci odstranil, neboť
v kódu není nikde volána). Jakmile máme Emscripten nainstalovaný, můžeme
s ním tento kód zkompilovat:</p>
<pre><code>emcc -O3 --no-entry my_sqrt.c -o my_sqrt.wasm</code></pre>
<p>V ideálním případě vznikne soubor <code>my_sqrt.wasm</code>, který
obsahuje danou funkci v binárním formátu WebAssembly. Přesuneme se do
známějšího světa běžného JavaScriptu a tento soubor načteme:</p>
<div class="sourceCode" id="cb211"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb211-1"><a href="#cb211-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> response <span class="op">=</span> <span class="cf">await</span> <span class="fu">fetch</span>(<span class="st">&quot;my_sqrt.wasm&quot;</span>)<span class="op">;</span></span>
<span id="cb211-2"><a href="#cb211-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> ab <span class="op">=</span> <span class="cf">await</span> response<span class="op">.</span><span class="fu">arrayBuffer</span>()<span class="op">;</span></span></code></pre></div>
<p>Dostáváme se k poslednímu kroku celé akce, totiž k propojení
WebAssembly a JavaScriptu. Použijeme k tomu metodu
<code>instantiate</code> z objektu <code>WebAssembly</code>:</p>
<div class="sourceCode" id="cb212"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb212-1"><a href="#cb212-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> wasm <span class="op">=</span> <span class="cf">await</span> WebAssembly<span class="op">.</span><span class="fu">instantiate</span>(ab<span class="op">,</span> {})<span class="op">;</span></span></code></pre></div>
<p>Druhý parametr je prázdný. Pokud by náš kód v C potřeboval přístup
k některým JS funkcím, museli bychom mu je poskytnout právě v druhém
parametru funkce <code>instantiate</code>. Exportovaná funkcionalita je
pro nás nyní dostupná v proměnné <code>wasm</code>:</p>
<div class="sourceCode" id="cb213"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb213-1"><a href="#cb213-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> my_sqrt <span class="op">=</span> wasm<span class="op">.</span><span class="at">instance</span><span class="op">.</span><span class="at">exports</span><span class="op">.</span><span class="at">my_sqrt</span><span class="op">;</span></span>
<span id="cb213-2"><a href="#cb213-2" aria-hidden="true" tabindex="-1"></a><span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(<span class="dv">42</span><span class="op">,</span> <span class="fu">my_sqrt</span>(<span class="dv">42</span>))<span class="op">;</span></span></code></pre></div>
<p>Protože jsme použili celočíselnou verzi funkce <code>sqrt</code>,
nepřekvapí nás, že vypsaná hodnota je šest – výsledek je oříznut na
nižší celé číslo. Pro potřeby ukázky se jedná o triviální funkcionalitu.
Snadno si ale představíme, že místo funkce <code>my_sqrt</code> můžeme
exportovat složitou logiku, která provede třeba kódování videa,
interakci s neuronovou sítí nebo hledání průchodu velkým grafem při
plánování cesty na mapě.</p>
<h1 id="co-se-nevešlo">Co se nevešlo</h1>
<p>Úlohy z minulých kapitol byly vybrány tak, abychom si jejich
prostřednictvím prohlédli a vyzkoušeli různé partie JavaScriptu. Pro
vážné zájemce tu ještě zbylo několik témat, která nemají společnou úlohu
a do celkové architektury knihy tak úplně nezapadají. Abychom zvídavého
čtenáře o tyto doplňkové zajímavosti nepřipravili, podíváme se na ně
nyní formou neorganizovaného bonusu.</p>
<h2 id="zelenáči-svg">Zelenáči: SVG</h2>
<p>V jedenácté kapitole jsme se seznámili s Canvasem. Šlo o kreslicí
plochu, se kterou pracujeme pomocí JavaScriptu. Vyzkoušeli jsme různé
funkce a zjistili, že canvas je vskutku univerzální nástroj pro rozličné
grafické manipulace. Není ale jediný. Ve světě počítačové grafiky
typicky uvažujeme dva směry práce s obrazovými daty – rastrový
a vektorový. Canvas představuje ten první; prohlížeč nám ovšem dává
možnost používat i přístup vektorový. Ten je realizován grafickým
formátem SVG (Scalable Vector Graphics).</p>
<p>Do začátku si ujasněme, že obrazový formát je v prohlížeči zpravidla
implementován jako podpora pro soubory s danou příponou. Pokud tedy
získáme obrazová data uložená v souboru <code>obrazek.svg</code>
(typicky prostřednictvím specializovaných editorů, jako např. Adobe
Illustrator či Inkscape), snadno je můžeme ve stránce zobrazit pomocí
HTML:</p>
<div class="sourceCode" id="cb214"><pre
class="sourceCode html"><code class="sourceCode html"><span id="cb214-1"><a href="#cb214-1" aria-hidden="true" tabindex="-1"></a><span class="dt">&lt;</span><span class="kw">img</span> <span class="er">src</span><span class="ot">=</span><span class="st">&quot;obrazek.svg&quot;</span><span class="dt">&gt;</span></span></code></pre></div>
<p>Takové řešení je funkční, ale slabé. My bychom rádi pomocí
JavaScriptu obsah souboru prozkoumávali, vytvářeli a měnili.
<em>Dovnitř</em> HTML značky <code>&lt;img&gt;</code> ale rozumným
způsobem přistupovat nemůžeme. Namísto toho můžeme využít tzv.
<em>inline SVG</em>, tedy vložení součástí SVG obrázku přímo do HTML. To
je možné, neboť SVG jako takové je dialekt jazyka XML – stejně jako HTML
používá uzly, atributy a také rozhraní DOM.</p>
<p>Co tedy nalezneme uvnitř typického souboru SVG? Je textový a velmi
přímočarý. Ten nejjednodušší může vypadat třeba takto:</p>
<div class="sourceCode" id="cb215"><pre
class="sourceCode html"><code class="sourceCode html"><span id="cb215-1"><a href="#cb215-1" aria-hidden="true" tabindex="-1"></a><span class="dt">&lt;</span><span class="kw">svg</span><span class="dt">&gt;</span></span>
<span id="cb215-2"><a href="#cb215-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&lt;</span><span class="kw">circle</span> <span class="er">cx</span><span class="ot">=</span><span class="st">&quot;50&quot;</span> <span class="er">cy</span><span class="ot">=</span><span class="st">&quot;50&quot;</span> <span class="er">r</span><span class="ot">=</span><span class="st">&quot;50&quot;</span> <span class="er">fill</span><span class="ot">=</span><span class="st">&quot;pink&quot;</span> <span class="dt">/&gt;</span></span>
<span id="cb215-3"><a href="#cb215-3" aria-hidden="true" tabindex="-1"></a><span class="dt">&lt;/</span><span class="kw">svg</span><span class="dt">&gt;</span></span></code></pre></div>
<p>Obalovací značka <code>&lt;svg&gt;</code> říká, že nás čeká vektorová
grafika. Většinou v ní najdeme informace o rozměrech, resp.
souřadnicích, ale ty jsou volitelné. Uvnitř <code>&lt;svg&gt;</code> pak
pracujeme s tzv. <strong>grafickými primitivy</strong> (pozor – jednotné
číslo je zde <em>grafické primitivum</em>, nikoliv <em>grafický
primitiv</em>), která představují základní geometrické tvary a jejich
vlastnosti.</p>
<p>K prvkům ze světa SVG můžeme JavaScriptem přistupovat pomocí rozhraní
DOM, obdobně jako k ostatním HTML značkám. Můžeme si tak v této
podkapitole zkusit znovu implementovat úlohu s favikonkou z jedenácté
kapitoly, ovšem tentokrát pomocí SVG. Naším cílem bude vytvořit útvar,
který znázorňuje v čase narůstající kruhovou výseč. Nejprve si k tomu
připravíme HTML kostru:</p>
<div class="sourceCode" id="cb216"><pre
class="sourceCode html"><code class="sourceCode html"><span id="cb216-1"><a href="#cb216-1" aria-hidden="true" tabindex="-1"></a><span class="dt">&lt;</span><span class="kw">head</span><span class="dt">&gt;&lt;</span><span class="kw">link</span> <span class="er">rel</span><span class="ot">=</span><span class="st">&quot;icon&quot;</span> <span class="dt">/&gt;&lt;/</span><span class="kw">head</span><span class="dt">&gt;</span></span>
<span id="cb216-2"><a href="#cb216-2" aria-hidden="true" tabindex="-1"></a><span class="dt">&lt;</span><span class="kw">svg</span> <span class="er">width</span><span class="ot">=</span><span class="st">&quot;64&quot;</span> <span class="er">height</span><span class="ot">=</span><span class="st">&quot;64&quot;</span> <span class="er">viewBox</span><span class="ot">=</span><span class="st">&quot;0 0 20 20&quot;</span><span class="dt">&gt;</span></span>
<span id="cb216-3"><a href="#cb216-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&lt;</span><span class="kw">circle</span> <span class="er">cx</span><span class="ot">=</span><span class="st">&quot;10&quot;</span> <span class="er">cy</span><span class="ot">=</span><span class="st">&quot;10&quot;</span> <span class="er">r</span><span class="ot">=</span><span class="st">&quot;10&quot;</span> <span class="er">fill</span><span class="ot">=</span><span class="st">&quot;lime&quot;</span> <span class="dt">/&gt;</span></span>
<span id="cb216-4"><a href="#cb216-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">&lt;</span><span class="kw">path</span> <span class="er">fill</span><span class="ot">=</span><span class="st">&quot;green&quot;</span> <span class="dt">/&gt;</span></span>
<span id="cb216-5"><a href="#cb216-5" aria-hidden="true" tabindex="-1"></a><span class="dt">&lt;/</span><span class="kw">svg</span><span class="dt">&gt;</span></span></code></pre></div>
<p>Značka <code>&lt;path&gt;</code> představuje naše hlavní grafické
primitivum. Jedná se o obecný geometrický prvek, jehož tvar je určen
posloupností čar a křivek. Zatím jsme pro výseč nastavili barvu výplně
(porovnejme s canvasem, kde jsme barvu museli definovat pomocí JS
volání). U rodičovské značky <code>&lt;svg&gt;</code> se objevilo
několik atributů:</p>
<ul>
<li><p><code>width</code> a <code>height</code> říkají, kolik pixelů náš
obrázek ve stránce zabere. Pro naši úlohu to nejsou zajímavá čísla,
neboť obrázek ve stránce vůbec nepotřebujeme – chceme ho zobrazovat jako
favikonku (jejíž rozměry určuje prohlížeč). Pro potřeby ladění ale může
být užitečné vidět, co vlastně vytváříme. Tehdy se použijí určené
rozměry.</p></li>
<li><p><code>viewBox</code> je jeden z nejdůležitějších atributů SVG.
Pomocí něj říkáme, jaké jednotky se budou používat u jednotlivých
grafických primitiv. Hodnotou <code>0 0 20 20</code> definujeme, že levý
horní roh obrázku odpovídá <em>logickým souřadnicím 0,0</em>, zatímco
šířka a výška prostoru obrázku je <em>20 logických bodů</em>. Logické
jednotky jsou bezrozměrné a dovolují nám definovat geometrické prvky
nezávisle na výsledné velikosti obrázku. Když budeme následně u SVG
prvků například uvažovat <em>logickou souřadnici 10,10</em>, myslíme tím
přesně střed obrazové plochy, nezávisle na tom, kolik pixelů (atributy
<code>width</code>, <code>height</code>) obrázek zabírá.</p></li>
</ul>
<p>Hlavní JavaScriptový kód, který v čase mění úhel výseče, můžeme
jednoduše zkopírovat z jedenácté kapitoly:</p>
<div class="sourceCode" id="cb217"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb217-1"><a href="#cb217-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> angle <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb217-2"><a href="#cb217-2" aria-hidden="true" tabindex="-1"></a><span class="pp">setInterval</span>(() <span class="kw">=&gt;</span> {</span>
<span id="cb217-3"><a href="#cb217-3" aria-hidden="true" tabindex="-1"></a>  angle <span class="op">=</span> (angle <span class="op">+</span> <span class="fl">0.2</span>) <span class="op">%</span> (<span class="bu">Math</span><span class="op">.</span><span class="cn">PI</span> <span class="op">*</span> <span class="dv">2</span>)<span class="op">;</span></span>
<span id="cb217-4"><a href="#cb217-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">draw</span>(angle)<span class="op">;</span></span>
<span id="cb217-5"><a href="#cb217-5" aria-hidden="true" tabindex="-1"></a>}<span class="op">,</span> <span class="dv">100</span>)<span class="op">;</span></span></code></pre></div>
<p>Stačí tedy dodat funkci <code>draw</code>, která pro zadaný úhel
upraví velikost výseče (a z našeho SVG pak vyrobí favikonku).</p>
<p>SVG značka <code>&lt;path&gt;</code> definuje svůj tvar pomocí
nezvyklé syntaxe, která – stejně jako u canvasu – odpovídá tažení
virtuálním štětcem po plátně. Jedná se o posloupnost písmen (která značí
různé druhy posunu štětce) a čísel (která upřesňují souřadnice štětce).
Kruhová výseč bude sestávat z těchto tří kroků:</p>
<ol type="1">
<li><p><code>M 10 10</code>: posun štětce na <em>logickou souřadnici
10,10</em>, tedy do středu obrázku</p></li>
<li><p><code>L 20 10</code>: tah štětce na <em>logickou souřadnici
10,10</em>, tedy zcela doprava</p></li>
<li><p><code>A 10 10 0 ? 1 ? ?</code>: tah štětce po oblouku (části
obvodu elipsy)</p></li>
</ol>
<p>Otazníky v poslední části trasy značí místa, která musíme dopočítat.
Konkrétně pro pokyn <code>A</code> (z anglického <strong>arc</strong>,
oblouk) potřebujeme:</p>
<ul>
<li><p>velikosti dvou poloos elipsy (v našem případě jde o kružnici
a obě jsou 10)</p></li>
<li><p>míru natočení elipsy v ose X (v našem případě 0)</p></li>
<li><p>tzv. <em>large-arc-flag</em>, označení toho, zdali chceme
zdrojový a cílový bod propojit větším či menším ze dvou možných
oblouků</p></li>
<li><p>tzv. <em>sweep-flag</em>, označení toho, zdali chceme zdrojový
a cílový bod propojit obloukem po směru či proti směru hodinových
ručiček</p></li>
<li><p>souřadnice cílového bodu eliptického oblouku</p></li>
</ul>
<p>Pokud máme zdrojový a cílový bod, lze je pro zadanou elipsu propojit
čtyřmi různými oblouky. Následující obrázek vysvětluje, jak se pomocí
dvou příznaků rozliší, který z oblouků máme na mysli:</p>
<figure>
<img src="../img/arcs.svg"
alt="Dva příznaky upřesňují, který ze čtyř oblouků použít" />
<figcaption aria-hidden="true">Dva příznaky upřesňují, který ze čtyř
oblouků použít</figcaption>
</figure>
<p>Ve funkci <code>draw</code> cílové souřadnice vypočítáme snadno
pomocí goniometrických funkcí. Výsledný tah štětcem pak přiřadíme do
atributu <code>d</code> SVG značky <code>&lt;path&gt;</code>:</p>
<div class="sourceCode" id="cb218"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb218-1"><a href="#cb218-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">draw</span>(angle) {</span>
<span id="cb218-2"><a href="#cb218-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> svg <span class="op">=</span> <span class="bu">document</span><span class="op">.</span><span class="fu">querySelector</span>(<span class="st">&quot;svg&quot;</span>)<span class="op">;</span></span>
<span id="cb218-3"><a href="#cb218-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb218-4"><a href="#cb218-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> x <span class="op">=</span> <span class="dv">10</span> <span class="op">+</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">cos</span>(angle) <span class="op">*</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb218-5"><a href="#cb218-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> y <span class="op">=</span> <span class="dv">10</span> <span class="op">+</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">sin</span>(angle) <span class="op">*</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb218-6"><a href="#cb218-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> largeArc <span class="op">=</span> (angle <span class="op">&gt;</span> <span class="bu">Math</span><span class="op">.</span><span class="cn">PI</span> <span class="op">?</span> <span class="dv">1</span> <span class="op">:</span> <span class="dv">0</span>)<span class="op">;</span></span>
<span id="cb218-7"><a href="#cb218-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> d <span class="op">=</span> <span class="vs">`M 10 10 L 20 10 A 10 10 0 </span><span class="sc">${</span>largeArc<span class="sc">}</span><span class="vs"> 1 </span><span class="sc">${</span>x<span class="sc">}</span><span class="vs"> </span><span class="sc">${</span>y<span class="sc">}</span><span class="vs">`</span><span class="op">;</span></span>
<span id="cb218-8"><a href="#cb218-8" aria-hidden="true" tabindex="-1"></a>  svg<span class="op">.</span><span class="fu">querySelector</span>(<span class="st">&quot;path&quot;</span>)<span class="op">.</span><span class="fu">setAttribute</span>(<span class="st">&quot;d&quot;</span><span class="op">,</span> d)<span class="op">;</span></span>
<span id="cb218-9"><a href="#cb218-9" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Posledním krokem je vytvoření favikonky z tohoto obrázku. U canvasu
z jedenácté kapitoly jsme její URL získali metodou
<code>toDataURL</code> a jednalo se o velice dlouhý řetězec, který
obsahoval informace o barvě všech pixelů zpracovávaného plátna. Při
použití SVG stačí zadaný DOM prvek prostě převést na řetězec a z něj
vytvořit <em>data URI</em>. K tomu můžeme použít vestavěný objekt
<code>XMLSerializer</code>:</p>
<div class="sourceCode" id="cb219"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb219-1"><a href="#cb219-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> link <span class="op">=</span> <span class="bu">document</span><span class="op">.</span><span class="at">head</span><span class="op">.</span><span class="fu">querySelector</span>(<span class="st">&quot;[rel=icon]&quot;</span>)<span class="op">;</span></span>
<span id="cb219-2"><a href="#cb219-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> str <span class="op">=</span> <span class="kw">new</span> <span class="bu">XMLSerializer</span>()<span class="op">.</span><span class="fu">serializeToString</span>(svg)<span class="op">;</span></span>
<span id="cb219-3"><a href="#cb219-3" aria-hidden="true" tabindex="-1"></a>link<span class="op">.</span><span class="at">href</span> <span class="op">=</span> <span class="vs">`data:image/svg+xml,</span><span class="sc">${</span>str<span class="sc">}</span><span class="vs">`</span><span class="op">;</span></span></code></pre></div>
<p>Tyto řádky umístíme na konec funkce <code>draw</code>, stejně jako
tomu bylo v případě generování favikonky z canvasu.</p>
<h2 id="koumáci-striktní-režim">Koumáci: striktní režim</h2>
<p>Tato podkapitola je přítomna hlavně pro úplnost. Při obhlížení
některých užitečných konceptů JavaScriptu (moduly v druhé kapitole,
klíčové slovo <code>this</code> v osmé kapitole) jsme na zmínku
o striktním režimu narazili a byla by škoda toto téma nevysvětlit, byť
v praxi mu rozumět nemusíme.</p>
<p>Myšlenka striktního režimu se objevila v roce 2009. JavaScript
zažíval velký boom a vývojáři uvažovali, zda lze jazyk vylepšovat nejen
přidáváním nových vlastností, ale i změnou těch existujících. Klíčovým
problémem byla samozřejmě zpětná kompatibilita, která je na webu
důležitým tématem. Ve verzi ES5 se proto objevila možnost použití
striktního režimu, který mění některé problematické prvky jazyka
a zároveň je dostupný formou <em>opt-in</em>, tj. jen pro ty části kódu,
kde si to programátor explicitně vyžádá.</p>
<p>Volitelné zapnutí striktního režimu se provádí přidáním řetězce
<code>"use strict";</code> na první řádek kódu. Pokud tak učiníme ve
funkci, bude se striktní režim aplikovat pouze na ni. Pokud zmiňovaný
řetězec dáme na začátek souboru, bude se striktní režim aplikovat na
celý soubor.</p>
<p>Striktní režim se následně ukázal jako dobrý nápad, takže jeho
aktivace je dnes ještě jednodušší. Pokud svůj kód napíšeme jako ES modul
(použijeme direktivy <code>import</code>, <code>export</code> nebo HTML
atribut <code>type="module"</code>), bude automaticky vykonán ve
striktním režimu. Pojďme se tedy podívat, jak že se striktní režim liší
od toho historického (označovaného jako <em>sloppy mode</em>, tj. něco
jako <em>lajdácký</em>). Zde je výčet nejdůležitějších změn:</p>
<ul>
<li><p><strong>Nutnost definice proměnné pomocí klíčového
slova.</strong> Bez striktního režimu je možné definovat proměnnou
prostým zápisem <code>a = 42</code>, což způsobí vznik či přepsání
globální proměnné.</p></li>
<li><p><strong>Vyvolání výjimky při přiřazení do některých globálních
proměnných.</strong> Bez striktního režimu se můžeme pokusit přiřadit
např. do proměnné <code>undefined</code>, <code>NaN</code> či
<code>Infinity</code>. Tato operace selže a my se o tom nedozvíme. Ve
striktním režimu taková operace způsobí výjimku.</p></li>
<li><p><strong>Nula na začátku čísel.</strong> Historicky se nula na
začátku používala k zápisu čísel v osmičkové soustavě (podobně jako
prefix <code>0x</code> značící soustavu šestnáctkovou). V praxi taková
funkce vývojáře spíš mátla, takže ve striktním režimu způsobí nula na
začátku výjimku.</p></li>
<li><p><strong>Odstranění klíčového slova <code>with</code>.</strong> To
umožňovalo expanzi vlastností objektu do lokálních proměnných – v praxi
sice užitečné, ale velmi nepředvídatelné chování. Ve striktním režimu
zakázáno.</p></li>
<li><p><strong>Použití <code>this</code> ve funkci volané obyčejně, bez
tečky.</strong> Takový zápis není k ničemu užitečný a proto ve striktním
režimu při tomto volání <code>this</code> nabývá hodnoty
<code>undefined</code>.</p></li>
<li><p><strong>Odstranění vlastností <code>caller</code>
a <code>callee</code>.</strong> Pomocí nich bylo možné v těle funkce
poznat, z jaké jiné funkce je ta současná volána. To má negativní dopad
na výkon a bezpečnost, takže ve striktním režimu již tyto vlastnosti
nejsou dostupné.</p></li>
<li><p><strong>Nová klíčová slova</strong>, která nesmíme použít jako
názvy vlastních proměnných (např. <code>let</code>,
<code>interface</code>, <code>implements</code> a další). Vzniká tak
prostor pro budoucí rozšiřování syntaxe jazyka.</p></li>
</ul>
<h2 id="profíci-iterační-protokol">Profíci: iterační protokol</h2>
<p>Ve třetí kapitole jsme se seznamovali s různými formami iterace. Při
použití syntaxe <code>for-of</code> dochází k <strong>programovatelné
iteraci</strong>, kdy procházený objekt sám specifikuje, co to znamená
<em>vrátit další položku</em>.</p>
<p>Představme si značný objem textu, který potřebujeme zpracovávat po
řádcích. Může jít o velký dokument získaný prostřednictvím HTTP
požadavku, logovací soubor nebo cokoliv jiného. Rozdělit text na
jednotlivé řádky je triviální (stačí použít metodu <code>split</code>,
které předáme rozdělovací podřetězec), ale zároveň nešikovné s ohledem
na výkon. Při převodu řetězce na pole vznikne fakticky duplikát
původního textu, takže touto operací zabereme alespoň dvojnásobek
paměti. Chytřejší je v původním textu postupně vyhledávat oddělovače
řádků a soustředit se na jednotlivé podřetězce mezi nimi.</p>
<p>Toto chytřejší procházení můžeme vytvořit jako iterovatelný objekt.
Zadáme mu velký vstupní text a oddělovač; pak mu budeme opakovaně říkat
<em>„dej další kousek!“</em> tak dlouho, než dojdeme na konec
procházených dat.</p>
<p>Přesně takhle funguje iterační protokol. Musíme vytvořit objekt
s metodou <code>next()</code>, která vrátí další iterovanou položku
a také příznak, zdali už jsme na konci, nebo můžeme pokračovat. Jeho
návratovou hodnotou proto bude objekt s vlastnostmi <code>value</code>
(vrácená hodnota) a <code>done</code> (bool, jsme-li na konci). Proces
iterace je stavový (mezi jednotlivými voláními <code>next()</code> si
musíme pamatovat, kde jsme minule oddělovač nalezli), takže pro jeho
realizaci často používáme uzávěru:</p>
<div class="sourceCode" id="cb220"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb220-1"><a href="#cb220-1" aria-hidden="true" tabindex="-1"></a><span class="kw">function</span> <span class="fu">createIterator</span>(text) {</span>
<span id="cb220-2"><a href="#cb220-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> separator <span class="op">=</span> <span class="st">&quot;</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb220-3"><a href="#cb220-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> lastIndex <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb220-4"><a href="#cb220-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> {</span>
<span id="cb220-5"><a href="#cb220-5" aria-hidden="true" tabindex="-1"></a>    <span class="fu">next</span>() {</span>
<span id="cb220-6"><a href="#cb220-6" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> (lastIndex <span class="op">&gt;</span> text<span class="op">.</span><span class="at">length</span>) {</span>
<span id="cb220-7"><a href="#cb220-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> { <span class="dt">value</span><span class="op">:</span> <span class="kw">undefined</span><span class="op">,</span> <span class="dt">done</span><span class="op">:</span> <span class="kw">true</span> }<span class="op">;</span></span>
<span id="cb220-8"><a href="#cb220-8" aria-hidden="true" tabindex="-1"></a>      }</span>
<span id="cb220-9"><a href="#cb220-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb220-10"><a href="#cb220-10" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> index <span class="op">=</span> text<span class="op">.</span><span class="fu">indexOf</span>(separator<span class="op">,</span> lastIndex)<span class="op">;</span></span>
<span id="cb220-11"><a href="#cb220-11" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> (index <span class="op">==</span> <span class="op">-</span><span class="dv">1</span>) {  <span class="co">// oddělovač nenalezen</span></span>
<span id="cb220-12"><a href="#cb220-12" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> value <span class="op">=</span> text<span class="op">.</span><span class="fu">slice</span>(lastIndex)<span class="op">;</span></span>
<span id="cb220-13"><a href="#cb220-13" aria-hidden="true" tabindex="-1"></a>        lastIndex <span class="op">=</span> text<span class="op">.</span><span class="at">length</span><span class="op">+</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb220-14"><a href="#cb220-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> { value<span class="op">,</span> <span class="dt">done</span><span class="op">:</span> <span class="kw">false</span> }<span class="op">;</span></span>
<span id="cb220-15"><a href="#cb220-15" aria-hidden="true" tabindex="-1"></a>      } <span class="cf">else</span> {            <span class="co">// oddělovač nalezen</span></span>
<span id="cb220-16"><a href="#cb220-16" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> value <span class="op">=</span> text<span class="op">.</span><span class="fu">slice</span>(lastIndex<span class="op">,</span> index)<span class="op">;</span></span>
<span id="cb220-17"><a href="#cb220-17" aria-hidden="true" tabindex="-1"></a>        lastIndex <span class="op">=</span> index <span class="op">+</span> separator<span class="op">.</span><span class="at">length</span><span class="op">;</span></span>
<span id="cb220-18"><a href="#cb220-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> { value<span class="op">,</span> <span class="dt">done</span><span class="op">:</span> <span class="kw">false</span> }<span class="op">;</span></span>
<span id="cb220-19"><a href="#cb220-19" aria-hidden="true" tabindex="-1"></a>      }</span>
<span id="cb220-20"><a href="#cb220-20" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb220-21"><a href="#cb220-21" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb220-22"><a href="#cb220-22" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Při hledání oddělovače využíváme metodu <code>indexOf</code>
a zejména její volitelný druhý parametr, který říká, od kolikátého znaku
hledáme. V proměnné <code>lastIndex</code> si pamatujeme, kde jsme
minule hledání skončili. Při zavolání <code>next()</code> se tak můžou
stát tři různé věci:</p>
<ol type="1">
<li><p>Pokud jsme se minulým hledáním dostali na konec textu, vrátíme
v odpovědi <code>done:true</code> (hodnota není relevantní, náš iterátor
již nic nevrací).</p></li>
<li><p>Pokud jsme v neprozkoumané části textu našli oddělovač, vrátíme
podřetězec (od minulého oddělovače k novému) a zapamatujeme si pozici
konce tohoto nového oddělovače.</p></li>
<li><p>Pokud jsme už žádný další oddělovač nenašli, vrátíme zbytek textu
(od minulého oddělovače do konce).</p></li>
</ol>
<p>Z toho plyne, že i když v textu žádný oddělovač nenalezneme, metoda
<code>next()</code> vždy vrátí alespoň jednu hodnotu (poslední položka
v seznamu výše).</p>
<p>Abychom tento objekt (když má metodu <code>next()</code>, říkáme mu
<em>iterátor</em>) mohli při iteraci použít, zbývá ho vložit na správné
předem dohodnuté místo. Konkrétně jej musí <em>vrátit funkce, která je
v iterovaném datovém typu dostupná pod klíčem, jehož hodnota je
<code>Symbol.iterator</code></em>. Zní to složitě, ale implementace je
jednoduchá. Můžeme jí docílit například třídou:</p>
<div class="sourceCode" id="cb221"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb221-1"><a href="#cb221-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> LineIterator {</span>
<span id="cb221-2"><a href="#cb221-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">constructor</span>(text) {</span>
<span id="cb221-3"><a href="#cb221-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">this</span><span class="op">.</span><span class="at">text</span> <span class="op">=</span> text<span class="op">;</span></span>
<span id="cb221-4"><a href="#cb221-4" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb221-5"><a href="#cb221-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb221-6"><a href="#cb221-6" aria-hidden="true" tabindex="-1"></a>  [<span class="bu">Symbol</span><span class="op">.</span><span class="at">iterator</span>]() {</span>
<span id="cb221-7"><a href="#cb221-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="fu">createIterator</span>(<span class="kw">this</span><span class="op">.</span><span class="at">text</span>)<span class="op">;</span></span>
<span id="cb221-8"><a href="#cb221-8" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb221-9"><a href="#cb221-9" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Tím je obřad tvorby iterátoru dokončen a my jej můžeme s velkou
slávou použít:</p>
<div class="sourceCode" id="cb222"><pre
class="sourceCode js"><code class="sourceCode javascript"><span id="cb222-1"><a href="#cb222-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> data <span class="op">=</span> <span class="st">&quot;a</span><span class="sc">\n</span><span class="st">b</span><span class="sc">\n</span><span class="st">c&quot;</span><span class="op">;</span></span>
<span id="cb222-2"><a href="#cb222-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> iterator <span class="op">=</span> <span class="kw">new</span> <span class="fu">LineIterator</span>(data)<span class="op">;</span></span>
<span id="cb222-3"><a href="#cb222-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (<span class="kw">let</span> line <span class="kw">of</span> iterator) <span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(line)<span class="op">;</span></span></code></pre></div>
<p>Mimochodem: výše uvedený kód implementuje tzv. <em>synchronní
iterační protokol</em>. V praxi se můžeme setkat s variantou, kdy je
funkce <code>next()</code> asynchronní (tj. vrací Promise, protože
například stahuje data HTTP požadavkem a podobně). Takový asynchronní
iterátor pak umístíme pod klíč <code>Symbol.asyncIterator</code>
a pracujeme s ním syntaxí <code>for await (let x of ...)</code>.</p>
</body>
</html>
