# Kapitola 4: Vše o událostech

## Zadání

Vzpomínkový web o Karlu Gottovi je velmi populární a rádi bychom s jeho uživateli a fanoušky vstoupili do bližšího kontaktu. Na konci stránky chceme formulář, kde bude moci uživatel vložit svůj názor a zanechat na sebe telefon či e-mail, abychom se na něj mohli případně obrátit. Formulář by měl jít odeslat pouze při správně vyplněném e-mailu či telefonním čísle.

## Řešení

```html
<form>
	<h3>Zanechejte nám vzkaz!</h3>
	<textarea name="text"></textarea>
	<label>
		Váš e-mail: <input type="email" name="email" />
	</label>
	<label>
		nebo telefon: <input type="tel" name="tel" />
	</label>
	<label>
		<input type="submit" value="Poslat vzkaz" />
	</label>
</form>
```

```js
let form = document.querySelector("form");
let email = form.querySelector("[name=email]");
let tel = form.querySelector("[name=tel]");

const TEL_RE = /^\+?\d{5,12}$/;

function isEmpty(input) {
	return input.value.trim() == "";
}

function checkForm(e) {
	if (isEmpty(email) && isEmpty(tel)) {
		alert("Vyplňte e-mail nebo telefon");
		e.preventDefault();
		return;
	}

	if (!isEmpty(tel)) {
		let t = tel.value;
		if (!t.match(TEL_RE)) {
			tel.classList.add("error");
			e.preventDefault();
		}
	}
}

form.addEventListener("submit", checkForm);
```

První část řešení je opět fragment HTML dokumentu. Nebudeme se mu věnovat příliš zevrubně, protože znalost HTML u čtenáře předpokládáme a tato kniha se soustředí více na JavaScript. U formuláře pro jednoduchost nejsou specifikovány atributy `method` ani `action`, které by ve skutečnosti rozhodně chybět neměly (jejich hodnoty ovšem pro náš kód nejsou podstatné). Popisky pro jednotlivé značky `<input>` vkládáme do značek `<label>` (a tyto dva spolu propojíme zanořením). Tím jednak napomáháme přístupnosti dokumentu a jednak je pak kliknutím na popisek možno aktivovat jemu odpovídající formulářové pole.

Pro zadávání e-mailu je vhodný `<input type="email">`, který sám od sebe kontroluje korektní formát zadané adresy a zároveň na softwarové klávesnici (v mobilních zařízeních) rovnou nabízí nezbytný znak zavináče. Stejně tak pro zadávání telefonu se nabízí `<input type="tel">`, pro který se zobrazí klávesnice číselná. Zde ovšem žádná kontrola vstupu sama od sebe neproběhne, a tak ji budeme muset naimplementovat sami v JavaScriptu.

V tradiční úloze kontroly formulářových polí se pohybujeme na nejisté hranici mezi JavaScriptem a HTML. Atributy `required` a `pattern` nám dovolují definovat kontrolní podmínky přímo v HTML stránce bez nutnosti JavaScriptu, ale jejich schopnosti nejsou velké. HTML kontrola je prováděna jen pro konkrétní izolované pole (bez vazby na ostatní položky), jsme velmi omezeni možností zobrazení textu chyby a kontrolu můžeme specifikovat jen pomocí tzv. *regulárních výrazů*. Proto ji použijeme pro e-mailové pole a to telefonní zkontrolujeme pomocí JavaScriptu.

V něm nejprve na prvních třech řádcích používáme rozhraní DOM pro získání důležitých prvků -- formuláře a obou inputů. Metodě `querySelector` tentokrát předáváme složitější (atributové) selektory. Rozhodně to není jediný způsob; další možností by byl například výběr pomocí atributu `type`. Následuje naše první konstanta `TEL_RE`, ve které specifikujeme regulární výraz pro telefonní číslo. Jedná se o jakýsi *vzor* nebo *šablonu*, která speciálními znaky popisuje, jak má vypadat platná hodnota. Za zmínku stojí, že regulární výrazy mají v JavaScriptu vlastní datový typ a proměnné tohoto typu vznikají zápisem mezi dvě dopředná lomítka. Ve složitějších případech je můžeme vyrábět také funkcí `RegExp()`.

Jazyk a celý koncept regulárních výrazů převyšuje rozsah této knihy, takže si jen v rychlosti vyložíme části našeho jednoduchého výrazu:

  - Znaky `^` a `$` na začátku resp. konci výrazu říkají, že tomuto vzoru musí vyhovovat celý text kontrolovaného pole, tedy nikoliv jen nějaká podmnožina (kolem které by pak mohly být nesouvisející neplatné znaky).
  - Zápis `\+?` určuje, že text smí začínat jedním znakem plus (v telefonním čísle tzv. mezinárodní volací kód).
  - Zápis `\d{5,12}` určuje, že zbytek textu má obsahovat posloupnost pěti až dvanácti číslic.

Nejedná se o univerzálně spolehlivou kontrolu telefonního čísla, ale ilustraci toho, jak bychom mohli zhruba postupovat. Tuto konstantu použijeme hned za chvíli, jakmile si nachystáme kontrolní funkci.

V kódu se nám hodí funkce dvě: jedna pro ověření prázdnosti formulářového pole (`isEmpty`) a jedna pro celou kontrolu formuláře (`checkForm`). Hlavní kontrolní funkci pak předáme jako parametr do `addEventListener`, neboť kontrolu chceme provést až v důsledku nějaké události. V této úloze se jako událost nabízí `"submit"`, tedy okamžik, kdy se uživatel chystá formulář odeslat. Tato událost je vázána na HTML formulář a tak funkci `addEventListener` voláme jako metodu proměnné `form`, do které jsme formulář přiřadili výše.

Zbývá nastudovat tělo funkce `checkForm`. Obsahuje dvě kontroly, které odpovídají zadání úlohy. První kontrola prostě ověří, že bylo vyplněno alespoň jedno pole. Využíváme zde pomocné funkce `isEmpty`, která z předaného inputu vybere vyplněný text, odstraní z něj případné přebytečné mezery na začátku a konci (metoda `trim()`) a ověří, zda něco zbylo. Zvídavý čtenář si může povšimnout, že v porování se zadáním používáme obrácenou logiku: namísto testu *je nějaké pole vyplněné?* se ptáme *jsou obě pole prázdná?*. Vlastně tedy ověřujeme, zdali je formulář vyplněn špatně. To nám dovoluje použít programátorský koncept nazvaný anglicky *Return Early*: chceme přestat vykonávat funkci jakmile ověříme, že to nemá smysl. Při nesprávném vyplnění zakončíme kód voláním `e.preventDefault()`, k jehož vysvětlení se dostaneme za malý okamžik.

Druhý test využívá regulárního výrazu z konstanty `TEL_RE` a pokud mu zadané telefonní číslo neodpovídá, nastává opět chybový stav. Tentokrát neukážeme uživateli nehezký `alert`, ale pokusíme se problém naznačit vizuálně -- například vyplněním políčka červenou barvou. Z JavaScriptu bychom sice pomocí DOM mohli přímo ovlivňovat vzhledové atributy daného prvku, ale takový postup je nepraktický, protože pro definici vzhledu upřednostňujeme jazyk CSS a těžko se nám pak bude hluboko uvnitř souborů JS hledat, kde a jak se kterému poli nastavuje jaká barva. Proto volíme přístup, kdy JavaScriptem měníme hodnotu atributu `class`, který v HTML slouží právě k tomuto účelu. Označujeme pomocí něj prvky, které se svými vlastnostmi nějak odlišují od ostatních a chceme na ně aplikovat specifická stylová pravidla. Fanoušci lososové barvy pak mohou doplnit například následující CSS:

```css
.error { background-color: salmon }
```

Z JavaScriptu ovšem nechceme nastavit atribut `class` na novou hodnotu `error`, neboť tento atribut může mít hodnot více (oddělených mezerami) a náš kód dopředu nemusí vědět, zdali a proč už tam nějaké hodnoty jsou. Je proto praktičtější postupovat *defenzivněji* a k existující hodnotě `class` jen něco přidat. K takovému účelu nejlépe slouží objekt `classList`, jehož metody dovolují k atributu `class` přidávat další hodnoty či odebírat existující.

Poslední otázkou k vyřešení je metoda `e.preventDefault()`, volaná v obou dílčích kontrolách. Jedná se o tzv. *metodu objektu události*, tedy logiku, která nám je k dispozici jen ve speciálních chvilkách, konkrétně v průběhu zpracování nějaké události. Vzpomeňme si, že náš současný kód (funkce `checkForm`) byl naplánován k vykonání teprve tehdy, když se uživatel pokusí odeslat formulář. Jakmile tato situace nastane, je v prohlížeči vytvořen *objekt události*, který popisuje skutečnosti pro tuto událost relevantní. Při vykonávání všech *posluchačů* dané události je pak objekt události každému posluchači předán jako parametr.

V objektu události nalezneme řadu užitečných informací a také několik metod. Ta nejdůležitější je `preventDefault`, nemá žádné parametry a pokud ji kterýkoliv posluchač vykoná, **žádá tím prohlížeč, aby na tuto událost po vykonání posluchačů dále nereagoval**. To je smysluplné jen u takových událostí, které představují nějakou aktivitu pro prohlížeč samotný: může jít o událost kliknutí na odkaz (způsobí navigaci), stisk klávesy ve formulářovém poli (způsobí vložení znaku) nebo kliknutí na odesílací tlačítko (způsobí odeslání formuláře). Když v našem kódu kontrola selže, voláním `e.preventDefault()` zařídíme, aby nedošlo k odeslání formuláře s neplatnými daty.

## Co jsme se naučili

Po vyřešení třetí úlohy by měl čtenář chápat a ovládat:

  - zamezení zpracování události metodou `preventDefault`
  - použití regulárního výrazu pro kontrolu textu
  - použití rozhraní `classList` pro snadnou úpravu HTML atributu `class`

## Zelenáči: další druhy událostí

Svět DOM událostí je pestrý a nabízí nám nástroje k tvorbě uživatelsky přívětivých stránek a aplikací. V řešených úlohách jsme se zatím setkali se dvěma událostmi a jejich původci:

  - Událost `"click"` odpovídající kliknutí myší (či prstem, stylusem, &hellip;) na libovolný HTML prvek.
  - Událost `"submit"` odpovídající pokusu o odeslání formuláře, nastávájící jen na HTML formulářích. Tato událost může být vyvolána různými způsoby; zejména to je kliknutí na odesílací tlačítko nebo stisk klávesy Enter, pokud je aktivní některé formulářové pole.

V dokumentaci rozhraní DOM můžeme nalézt desítky dalších druhů událostí. V kontextu kontroly formulářových polí připadají v úvahu například tyto:

  - Událost `"focus"` nastává na HTML prvku `<input>`, jakmile tento začne být aktivní (uživatel do něj klikne, nebo se do něj přesune klávesou Tab). Symetricky s tím událost `"blur"` odpovídá ztrátě aktivity formulářového pole.

  - Na formulářových polích vznikají události související s klávesnicí. Při stisku klávesy je to `"keydown"`, při puštění následně `"keyup"`.

  - Pokud nás nezajímá, jakým způsobem ke změně formulářového pole došlo (klávesnicí, myší, vložením ze schránky, ...), můžeme použít událost `"input"`, která odpovídá libovolné úpravě daného pole.

Pro různé scénáře volíme různé události či jejich kombinace. Abychom vzorové řešení vylepšili, můžeme políčko pro telefon zkontrolovat dříve, než se uživatel pokusí formulář odeslat. Stisk každé klávesy (případně jiná změna hodnoty) je ovšem zbytečně agresivní, neboť bychom pak pole kontrolovali už od prvního zadaného znaku (a považovali ho za nesprávně vyplněné, i když jej uživatel plánuje vyplnit správně). Pro tento scénář je ideální událost `"blur"`, tedy opuštění aktivního pole.

K tomu se nám bude hodit nová funkce a nový posluchač události:

```js
function checkPhone() {
}
tel.addEventListener("blur", checkPhone);
```

Budeme v této funkci chtít volat `preventDefault`? Nikoliv, protože na tuto událost prohlížeč sám nijak nereaguje, takže mu nemáme co zakazovat. Proto bychom se patrně mohli obejít bez parametru `e`, tj. bez objektu události (tak, jako v druhé a třetí kapitole).

Tato kontrolní funkce nalezne telefonní pole v jednom ze tří stavů:

  1. prázdné &rarr; není potřeba kontrolovat, resp. pole neobsahuje chybu
  1. vyplněné špatně &rarr; je nutno označit jako chybné
  1. vyplněné správně &rarr; je nutno neoznačovat jako chybné

První implementace by mohla vypadat takto:

```js
function checkPhone() {
	if (isEmpty(tel)) {
		tel.classList.remove("error");
	} else {
		let t = tel.value;
		if (t.match(TEL_RE)) {
			tel.classList.remove("error");
		} else {
			tel.classList.add("error");
		}
	}
}
```

Kód je ovšem zbytečně košatý, zanořený a není snadné z něj rychle a snadno odhadnout, za jakých podmínek je pole považováno za špatně či správně vyplněné. Můžeme jej snadno zjednodušit, za použití dvou triků:

  - Operátor *nebo* (znaky `||`) platí, jen když je splněna libovolná ze dvou podmínek po jeho stranách. Tím dokážeme snadno popsat podmínku ze zadání, že *telefonní pole je správné, když je prázdné nebo vyplněné dle regulárního výrazu*.
  - Metoda `classList.toggle()` do atributu `class` přidá danou hodnotu, pokud je její druhý parametr pravdivý. V opačném případě danou hodnotu z `class` odebere.

Když už jsme v úpravách funkce `checkPhone`, všimneme si také, že její chování je závislé na proměnné `tel`, jejíž hodnota je ve funkci uzavřena (viz podkapitola pro profíky v předchozí kapitole). Zde je prostor pro zvýšení čitelnosti. V objektu události (který jsme plánovali ignorovat) je totiž mimo jiné obsažen také HTML prvek, na kterém událost nastala. Dozvíme se jej pomocí vlastnosti `e.target`. Proto můžeme vrátit parametr `e` a tím funkci explicitně dodat veškerá data, která potřebuje:

```js
function checkPhone(e) {
	let tel = e.target;
	let t = tel.value;
	let isOk = isEmpty(tel) || t.match(TEL_RE);
	tel.classList.toggle("error", !isOk);
}
tel.addEventListener("blur", checkPhone);
```

Tato funkce `checkPhone` je kratší, bez zanoření a také ji lze použít pro zpracování více telefonních polí naráz! Ale ještě ji musíme upravit jednou.

Pokud logiku kontroly telefonního pole přesuneme do `checkPhone`, znamená to, že ji budeme chtít volat i ve chvíli kontroly celého formuláře (funkce `checkForm`). Ale naše současná `checkPhone` není dobře připravena k zavolání z jiné funkce: nemá návratovou hodnotu a jako parametr očekává objekt události vyvolané na telefonním inputu. Přidáme proto funkci návratovou hodnotu a změníme její parametrizaci. Namísto objektu události jí předáme rovnou input, se kterým má pracovat. Tím zůstane zachována její obecnost a zároveň ji budeme moci použít nezávisle na tom, jaká událost probíhá.

Následující rošáda je v JavaScriptu velmi běžná. Máme konkrétní představu o tvaru naší funkce, ale zároveň ji chceme předat jako posluchač a proto musíme respektovat parametr s objektem události. Vytvoříme si proto jako posluchač malinkou *arrow funkci*, která tu opravdovou zavolá s upraveným parametrem:

```js
function checkPhone(tel) {
	let t = tel.value;
	let isOk = isEmpty(tel) || t.match(TEL_RE);
	tel.classList.toggle("error", !isOk);
	return isOk;
}
tel.addEventListener("blur", e => checkPhone(e.target));
```

Všimněme si, že v ukázce výše definujeme dvě různé funkce. Najdete je?

Zbývá upravit zbytek kódu tak, abychom uvnitř kontroly celého formuláře mohli znovupoužít naši dílčí kontrolní funkci `checkPhone`. Celé vylepšené řešení této kapitoly pak vypadá takto:

```js
let form = document.querySelector("form");
let email = form.querySelector("[name=email]");
let tel = form.querySelector("[name=tel]");

const TEL_RE = /^\+?\d{5,12}$/;

function isEmpty(input) {
	return input.value.trim() == "";
}

function checkPhone(tel) {
	let t = tel.value;
	let isOk = isEmpty(tel) || t.match(TEL_RE);
	tel.classList.toggle("error", !isOk);
	return isOk;
}
tel.addEventListener("blur", e => checkPhone(e.target));

function checkForm(e) {
	if (isEmpty(email) && isEmpty(tel)) {
		alert("Vyplňte e-mail nebo telefon");
		e.preventDefault();
		return;
	}

	if (!checkPhone(tel)) {
		e.preventDefault();
	}
}
form.addEventListener("submit", checkForm);
```

## Koumáci: cesta události stromem dokumentu

V této podkapitole se nebudeme věnovat dalším druhům událostí, ale prohloubíme znalosti o těch již známých. Celý systém DOM událostí se totiž značně zkomplikuje, jakmile si uvědomíme, že HTML prvky vytváří stromovou strukturu a že uživatelova interakce (tj. zdroj vzniku události) se proto může týkat více uzlů naráz. Konkrétněji, když máme například odstavec a v něm odkaz, na který klikneme, *kliknuli jsme na odstavec?*

```html
<p>
	Toto je odstavec. V něm je
	<a> odkaz, </a>
	na který klikneme. Bylo kliknuto (také) na odstavec?
</p>
```

Na tuto otázku je odpověď jednoznačná: **ano**, kliknutí na libovolný HTML prvek ve stránce zároveň znamená, že bylo kliknuto i na jeho rodiče (a všechny jeho předky). Bohužel, takto snadno ale nelze odpověďet i na obdobné situace s jinými událostmi. V této kapitole se věnujeme události `submit`, kterou uživatel vyvolal například interakcí s tlačítkem. A taková  událost nástává na HTML prvku `<form>` -- nikoliv na tlačítku a nikoliv na rodičích formuláře. Znamená to, že události dělíme do dvou hlavních kategorií: ty, které krom původního prvku nastávají i na všech rodičích (říkáme o nich, že *bublají*) a ty, které se odehrávají jen na jednom HTML prvku (říkáme, že *nebublají*). Toto pozoruhodné názvosloví snad vyjasníme za malou chvíli, ale nejprve se podívejme, k čemu se nám taková bublající událost může hodit.

Představme si, že náš kontaktní formulář je na začátku skrytý a uživatel si jej může zobrazit kliknutím na tlačítko. Zatím je to hračka:

```html
<form hidden> ... </form>
<button> Kontaktovat </button>
```
```js
let form = document.querySelector("form");
let button = document.querySelector("button");
button.addEventListener("click", e => form.hidden = false);
```

Situace se může zkomplikovat, když pak dostaneme za úkol *skrýt formulář, jakmile uživatel klikne mimo něj*. Protože událost `click` patří mezi bublající, můžeme přidat posluchač třeba na celý dokument. Tím se dozvíme o kliknutí *kdekoliv ve stránce* a formulář skryjeme.

```js
function hideForm(e) {
	// opravdu vzdy?
	form.hidden = true;
}
document.addEventListener("click", hideForm);
```

Toto řešení ovšem není funkční, neboť skrývá formulář při kliku kamkoliv, tedy i do formuláře. Naštěstí máme dva dobré způsoby, jak tomu zabránit:

  1. Víme, že vlastnost `e.target` odpovídá tomu HTML prvku, na kterém událost nastala. Pokud dokážeme ověřit, že se tento nachází někde uvnitř formuláře (nebo je to přímo formulář), můžeme za takové situace kliknutí ignorovat.

  1. Prohlížeč vykonává posluchače bublajících událostí v pevně definovaném pořadí *odspoda nahoru*, tedy od cílového prvku směrem ke kořeni stromu dokumentu. Když klikneme na HTML prvek, nejprve se vykoná posluchač přidaný přímo na něj (pokud nějaký je), pak na jeho rodiči, pak na rodiči jeho rodiče&hellip; až k poslednímu místu, tj. k celé proměnné `document`. Tento proces můžeme zastavit v rámci posluchače, který přidáme na formulář.

Druhé řešení je výrazně snazší. Potřebujeme k němu novou metodu `stopPropagation`, která je součástí objektu události. Jejím účelem je zastavit proces bublání:

```js
document.addEventListener("click", e => form.hidden = false);
form.addEventListener("click", e => e.stopPropagation());
```

Takový přístup můžeme popsat slovy *dokument se nedozví o tom, že bylo kliknuto na formulář*. Při kliku kamkoliv (do formuláře i mimo něj) se vykoná jen jeden ze dvou výše uvedených posluchačů.

Na úloze se skrýváním formuláře je vidět, že *bublání* je silná technika. Bohužel si ale vzpomínáme, že některé události nebublají. Nemusíme se však obávat, protože zpracování posluchačů pomocí bublání je ve skutečnosti jen polovina toho, jak prohlížeč na událost reaguje. Před vykonáváním našich posluchačů totiž ještě nastane okamžik, kterému se říká *zachytávání* (anglicky *capture*). Během něj prohlížeč projde stromem dokumentu *shora dolů* od kořene až k cílovému prvku (tedy v obráceném pořadí, než u bublání) a cestou vykoná ty posluchače právě zpracovávané události, u kterých jsme explicitně požádali o spuštění ve fázi zachytávání. K tomu slouží třetí, nepovinný parametr metody `addEventListener`. Pokud máme o zachytávání zájem, musíme jej nastavit buď na `true`, nebo na objekt, obsahující `capture:true`:

```js
// dve shodne varianty
document.addEventListener("focus", console.log, true);
document.addEventListener("focus", console.log, {capture:true});
```

Celý proces zpracování události si můžeme snadněji představit pomocí obrázku:

FIXME

Pojďme si shrnout důležité kroky v životě zpracovávané události.

  - Jakmile nastane DOM událost, prohlížeč vytvoří objekt události a začne vykonávat posluchače. Nejprve ve fázi zachytávání, pak ve fázi bublání.
  - Posluchače ve fázi zachytávání musí být explicitně označeny a jsou vykonávány v pořadí *shora dolů*.
  - Posluchače ve fázi bublání jsou vykonávány v pořadí *odspoda nahoru*. Pokud událost nebublá, vykoná se jen posluchač na cílovém HTML prvku a žádný další.
  - Procesy zachytávání i následného bublání lze v kterémkoliv posluchači zastavit voláním `stopPropagation()`.

U většiny JavaScriptových úloh si vystačíme s bubláním. Zachytávání se nám může hodit jen ve dvou situacích:

1. Když potřebujeme prohodit pořadí dvou posluchačů stejné události na různých HTML prvcích.
1. Když se potřebujeme na rodičovském prvku dozvědět o nebublající události jeho potomka.


## Profíci: kontrola při psaní, odebírání posluchačů
