# Kapitola 9: Web Components

## Ãšloha

V Å¡estÃ© kapitole jsme vytvoÅ™ili single-page aplikaci, kterÃ¡ zobrazuje vÃ½sledky hledÃ¡nÃ­ bez opakovanÃ©ho naÄÃ­tÃ¡nÃ­ strÃ¡nky. Upravte tento kÃ³d opÄ›t dle pravidel objektovÄ› orientovanÃ©ho programovÃ¡nÃ­, ale tentokrÃ¡t pomocÃ­ konceptu Web Components.


### Å˜eÅ¡enÃ­

OznaÄenÃ­ Web Components pouÅ¾Ã­vÃ¡me tam, kde se rozhodneme naÅ¡e tÅ™Ã­dy definovat jako potomky existujÃ­cÃ­ch HTML znaÄek. ZnamenÃ¡ to, Å¾e takto dokÃ¡Å¾eme vytvÃ¡Å™et vlastnÃ­ HTML znaÄky, kterÃ½m pomocÃ­ JavaScriptu dodÃ¡me specifickou funkcionalitu (a pomocÃ­ CSS specifickÃ½ vzhled). MyÅ¡lenka Web Components je znaÄnÄ› obsÃ¡hlÃ¡ a vydala by na samostatnou knihu; vzorovÃ© Å™eÅ¡enÃ­ tÃ©to kapitoly je pro nÃ¡s proto jen drobnou ochutnÃ¡vkou tÃ©to techniky.

HTML, kterÃ© potÅ™ebujeme vytvoÅ™it, sestÃ¡vÃ¡ ze tÅ™Ã­ ÄÃ¡stÃ­: hledacÃ­ho formulÃ¡Å™e, prostoru pro vÃ½sledky a jednotlivÃ½ch poloÅ¾ek nalezenÃ½ch pÃ­snÃ­. My zkusÃ­me vyvoÅ™it vlastnÃ­ HTML znaÄku pro formulÃ¡Å™ (ta bude obsahovat logiku souvisejÃ­cÃ­ s HTTP poÅ¾adavky) a dÃ¡le pro kaÅ¾dÃ½ vÃ½sledek hledÃ¡nÃ­.

```html
<!-- kapitola-9.html -->
<link rel="stylesheet" href="song-result.css" />

<h1>HledÃ¡nÃ­</h1>
<song-search></song-search>

<script src="song-search.js"></script>
<script src="song-result.js"></script>
```

```js
// song-search.js
class SongSearch extends HTMLElement {
	connectedCallback() {
		this.innerHTML = HTML;
		this.querySelector("form").addEventListener("submit", this);
	}

	async handleEvent(e) {
		e.preventDefault();
		let query = this.querySelector("[name=query]").value;
		let url = `/search?query=${encodeURIComponent(query)}`;
		let response = await fetch(url);
		let songs = await response.json();
		this.showResults(songs, query);
	}

	showResults(songs, query) {
		let parent = this.querySelector(".results");
		if (songs.length == 0) {
			parent.replaceChildren("Tomuto dotazu nevyhovujÃ­ Å¾Ã¡dnÃ© pÃ­snÄ› ğŸ™");
			return;
		}

		let heading = document.createElement("h2");
		heading.textContent = `NalezenÃ© pÃ­snÄ› pro dotaz: ${query}`;

		let ol = document.createElement("ol");
		parent.replaceChildren(heading, ol);

		let results = songs.map(item => {
			let result = document.createElement("song-result");
			result.setData(item);
			return result;
		});
		ol.replaceChildren(...results);
	}
}

const HTML = `<form>
	<label>
		HledanÃ½ vÃ½raz: <input type="text" name="query" />
	</label>
	<label><button>ğŸ”</button></label>
</form>
<div class="results"></div>`;

customElements.define("song-search", SongSearch);
```

```js
// song-result.js
class SongResult extends HTMLElement {
	setData(song) {
		this.innerHTML = `<a href="${song.url}">${song.title}</a> <br/> ${song.text}`;
	}
}

customElements.define("song-result", SongResult);
```

```css
/* song-result.css */
song-result {
	display: list-item;
}
```

Definice vlastnÃ­ch HTML znaÄek se pÅ™Ã­liÅ¡ neliÅ¡Ã­ od bÄ›Å¾nÃ½ch tÅ™Ã­d, se kterÃ½mi jsme se seznÃ¡mili v pÅ™edchozÃ­ kapitole. Aby se s naÅ¡Ã­ tÅ™Ã­dou dalo pracovat jako s HTML znaÄkou, musÃ­me vykonat tyto dva povinnÃ© kroky:

1. Definovat svou tÅ™Ã­du jako potomka nÄ›kterÃ© HTML znaÄky. Typicky toho docÃ­lÃ­me zÃ¡pisem `extends HTMLElement`, tedy dÄ›dÄ›nÃ­m z obecnÃ© HTML znaÄky.

1. **Zaregistrovat** vzniklou tÅ™Ã­du jako definici pro HTML parser. V tomto kroku takÃ© dodÃ¡me nÃ¡zev HTML znaÄky, kterou chceme pouÅ¾Ã­vat. K tomu slouÅ¾Ã­ globÃ¡lnÃ­ objekt `customElements` a jeho metoda `define`, pomocÃ­ kterÃ© spÃ¡rujeme tÅ™Ã­du a nÃ¡zev. Za zmÃ­nku stojÃ­, Å¾e v nÃ¡zvu musÃ­ bÃ½t obsaÅ¾ena pomlÄka. To garantuje tzv. *dopÅ™ednou kompatibilitu*: protoÅ¾e standardnÃ­ HTML znaÄky ve svÃ©m nÃ¡zvu nikdy pomlÄku neobsahujÃ­, nestane se v budoucnu, Å¾e by doÅ¡lo ke vzniku novÃ©ho HTML prvku, kterÃ½ by nÃ¡zvem kolidoval s tÃ­m naÅ¡Ã­m vlastnÃ­m.

TÅ™Ã­da `SongResult` je malinkÃ¡ a dovede jedinou vÄ›c: pÅ™evÃ©st data jednoho vÃ½sledku hledÃ¡nÃ­ na HTML. K tÃ©to novÃ© HTML znaÄce rovnou dodÃ¡me takÃ© definici stylu, ve kterÃ© zÃ¡pisem `display: list-item` zaÅ™Ã­dÃ­me, aby se naÅ¡e `<song-result>` korektnÄ› zobrazila jako poloÅ¾ka seznamu. To proto, Å¾e ji mÃ¡me v plÃ¡nu umÃ­stit do odrÃ¡Å¾kovÃ©ho seznamu, vytvoÅ™enÃ©ho v `<song-search>`.

Optikou objektovÄ› orientovanÃ©ho programovÃ¡nÃ­ je nezvyklÃ©, Å¾e potÅ™ebnÃ¡ data nepÅ™edÃ¡vÃ¡me konstruktoru tÅ™Ã­dy `SongResult` a namÃ­sto toho tak ÄinÃ­me pomocÃ­ metody `setData`. DÅ¯vod je ten, Å¾e tvorba instancÃ­ `SongResult` probÃ­hÃ¡ zÃ¡pisem `document.createElement("song-result")` uvnitÅ™ tÅ™Ã­dy `SongSearch`, pÅ™i kterÃ©m nelze Å¾Ã¡dnÃ¡ data pÅ™edÃ¡vat.

TÃ­m se dostÃ¡vÃ¡me k objemnÄ›jÅ¡Ã­ komponentÄ› `<song-search>`. VÄ›tÅ¡ina jejÃ­ implementace je pÅ™evzata z Å¡estÃ© kapitoly a neobsahuje nic novÃ©ho. Ani zde nevidÃ­me konstruktor; namÃ­sto toho jsme inicializaci (tvorbu formulÃ¡Å™e a pÅ™idÃ¡nÃ­ posluchaÄe) odloÅ¾ili do metody `connectedCallback`. Ta patÅ™Ã­ k nÄ›kolika tzv. *lifecycle callbackÅ¯m*; funkcÃ­m, kterÃ© volÃ¡ prohlÃ­Å¾eÄ, kdyÅ¾ HTML prvek vklÃ¡dÃ¡ do stromu strÃ¡nky, mÄ›nÃ­ jeho atributy Äi jej odebÃ­rÃ¡. Je dobrÃ½m zvykem vlastnÃ­ HTML znaÄky takto inicializovat prÃ¡vÄ› v okamÅ¾iku jejich pÅ™ipnutÃ­ do dokumentu.

VÃ½slednÃ© HTML je pak triviÃ¡lnÃ­ a hezky ukazuje, jak jsme funkcionalitu hledacÃ­ho formulÃ¡Å™e skryli, resp. zapouzdÅ™ili do implementace komponenty `SongSearch`.

DÄ›dÄ›nÃ­m z tÅ™Ã­dy `HTMLElement` jsme zÃ­skali praktickÃ© schopnosti rozhranÃ­ DOM (`this.innerHTML`, `this.querySelector`).

### Co jsme se nauÄili
## ZelenÃ¡Äi
## KoumÃ¡ci
## ProfÃ­ci
