# Kapitola 9: Web Components

## Ãšloha

V Å¡estÃ© kapitole jsme vytvoÅ™ili single-page aplikaci, kterÃ¡ zobrazuje vÃ½sledky hledÃ¡nÃ­ bez opakovanÃ©ho naÄÃ­tÃ¡nÃ­ strÃ¡nky. Upravte tento kÃ³d opÄ›t dle pravidel objektovÄ› orientovanÃ©ho programovÃ¡nÃ­, ale tentokrÃ¡t pomocÃ­ konceptu Web Components.


### Å˜eÅ¡enÃ­

OznaÄenÃ­ Web Components pouÅ¾Ã­vÃ¡me tam, kde se rozhodneme naÅ¡e tÅ™Ã­dy definovat jako potomky existujÃ­cÃ­ch HTML znaÄek. ZnamenÃ¡ to, Å¾e takto dokÃ¡Å¾eme vytvÃ¡Å™et vlastnÃ­ HTML znaÄky, kterÃ½m pomocÃ­ JavaScriptu dodÃ¡me specifickou funkcionalitu (a pomocÃ­ CSS specifickÃ½ vzhled). MyÅ¡lenka Web Components je znaÄnÄ› obsÃ¡hlÃ¡ a vydala by na samostatnou knihu; vzorovÃ© Å™eÅ¡enÃ­ tÃ©to kapitoly je pro nÃ¡s proto jen drobnou ochutnÃ¡vkou tÃ©to techniky.

HTML, kterÃ© potÅ™ebujeme vytvoÅ™it, sestÃ¡vÃ¡ ze tÅ™Ã­ ÄÃ¡stÃ­: hledacÃ­ho formulÃ¡Å™e, prostoru pro vÃ½sledky a jednotlivÃ½ch poloÅ¾ek nalezenÃ½ch pÃ­snÃ­. My zkusÃ­me vyvoÅ™it vlastnÃ­ HTML znaÄku pro formulÃ¡Å™ (ta bude obsahovat logiku souvisejÃ­cÃ­ s HTTP poÅ¾adavky) a dÃ¡le pro kaÅ¾dÃ½ vÃ½sledek hledÃ¡nÃ­.

```html
<!-- kapitola-9.html -->
<link rel="stylesheet" href="song-result.css" />

<h1>HledÃ¡nÃ­</h1>
<song-search></song-search>

<script src="song-search.js"></script>
<script src="song-result.js"></script>
```

```js
// song-search.js
class SongSearch extends HTMLElement {
	connectedCallback() {
		this.innerHTML = HTML;
		this.querySelector("form").addEventListener("submit", this);
	}

	async handleEvent(e) {
		e.preventDefault();
		let query = this.querySelector("[name=query]").value;
		let url = `/search?query=${encodeURIComponent(query)}`;
		let response = await fetch(url);
		let songs = await response.json();
		this.showResults(songs, query);
	}

	showResults(songs, query) {
		let parent = this.querySelector(".results");
		if (songs.length == 0) {
			parent.replaceChildren("Tomuto dotazu nevyhovujÃ­ Å¾Ã¡dnÃ© pÃ­snÄ› ğŸ™");
			return;
		}

		let heading = document.createElement("h2");
		heading.textContent = `NalezenÃ© pÃ­snÄ› pro dotaz: ${query}`;

		let ol = document.createElement("ol");
		parent.replaceChildren(heading, ol);

		let results = songs.map(item => {
			let result = document.createElement("song-result");
			result.setData(item);
			return result;
		});
		ol.replaceChildren(...results);
	}
}

const HTML = `<form>
	<label>
		HledanÃ½ vÃ½raz: <input type="text" name="query" />
	</label>
	<label><button>ğŸ”</button></label>
</form>
<div class="results"></div>`;

customElements.define("song-search", SongSearch);
```

```js
// song-result.js
class SongResult extends HTMLElement {
	setData(song) {
		this.innerHTML = `<a href="${song.url}">${song.title}</a> <br/> ${song.text}`;
	}
}

customElements.define("song-result", SongResult);
```

```css
/* song-result.css */
song-result {
	display: list-item;
}
```

Definice vlastnÃ­ch HTML znaÄek se pÅ™Ã­liÅ¡ neliÅ¡Ã­ od bÄ›Å¾nÃ½ch tÅ™Ã­d, se kterÃ½mi jsme se seznÃ¡mili v pÅ™edchozÃ­ kapitole. Aby se s naÅ¡Ã­ tÅ™Ã­dou dalo pracovat jako s HTML znaÄkou, musÃ­me vykonat tyto dva povinnÃ© kroky:

1. Definovat svou tÅ™Ã­du jako potomka nÄ›kterÃ© HTML znaÄky. Typicky toho docÃ­lÃ­me zÃ¡pisem `extends HTMLElement`, tedy dÄ›dÄ›nÃ­m z obecnÃ© HTML znaÄky.

1. **Zaregistrovat** vzniklou tÅ™Ã­du jako definici pro HTML parser. V tomto kroku takÃ© dodÃ¡me nÃ¡zev HTML znaÄky, kterou chceme pouÅ¾Ã­vat. K tomu slouÅ¾Ã­ globÃ¡lnÃ­ objekt `customElements` a jeho metoda `define`, pomocÃ­ kterÃ© spÃ¡rujeme tÅ™Ã­du a nÃ¡zev. Za zmÃ­nku stojÃ­, Å¾e v nÃ¡zvu musÃ­ bÃ½t obsaÅ¾ena pomlÄka. To garantuje tzv. *dopÅ™ednou kompatibilitu*: protoÅ¾e standardnÃ­ HTML znaÄky ve svÃ©m nÃ¡zvu nikdy pomlÄku neobsahujÃ­, nestane se v budoucnu, Å¾e by doÅ¡lo ke vzniku novÃ©ho HTML prvku, kterÃ½ by nÃ¡zvem kolidoval s tÃ­m naÅ¡Ã­m vlastnÃ­m.

TÅ™Ã­da `SongResult` je malinkÃ¡ a dovede jedinou vÄ›c: pÅ™evÃ©st data jednoho vÃ½sledku hledÃ¡nÃ­ na HTML. K tÃ©to novÃ© HTML znaÄce rovnou dodÃ¡me takÃ© definici stylu, ve kterÃ© zÃ¡pisem `display: list-item` zaÅ™Ã­dÃ­me, aby se naÅ¡e `<song-result>` korektnÄ› zobrazila jako poloÅ¾ka seznamu. To proto, Å¾e ji mÃ¡me v plÃ¡nu umÃ­stit do odrÃ¡Å¾kovÃ©ho seznamu, vytvoÅ™enÃ©ho v `<song-search>`.

Optikou objektovÄ› orientovanÃ©ho programovÃ¡nÃ­ je nezvyklÃ©, Å¾e potÅ™ebnÃ¡ data nepÅ™edÃ¡vÃ¡me konstruktoru tÅ™Ã­dy `SongResult` a namÃ­sto toho tak ÄinÃ­me pomocÃ­ metody `setData`. DÅ¯vod je ten, Å¾e tvorba instancÃ­ `SongResult` probÃ­hÃ¡ zÃ¡pisem `document.createElement("song-result")` uvnitÅ™ tÅ™Ã­dy `SongSearch`, pÅ™i kterÃ©m nelze Å¾Ã¡dnÃ¡ data pÅ™edÃ¡vat.

TÃ­m se dostÃ¡vÃ¡me k objemnÄ›jÅ¡Ã­ komponentÄ› `<song-search>`. VÄ›tÅ¡ina jejÃ­ implementace je pÅ™evzata z Å¡estÃ© kapitoly a neobsahuje nic novÃ©ho. Ani zde nevidÃ­me konstruktor; namÃ­sto toho jsme inicializaci (tvorbu formulÃ¡Å™e a pÅ™idÃ¡nÃ­ posluchaÄe) odloÅ¾ili do metody `connectedCallback`. Ta patÅ™Ã­ k nÄ›kolika tzv. *lifecycle callbackÅ¯m*; funkcÃ­m, kterÃ© volÃ¡ prohlÃ­Å¾eÄ, kdyÅ¾ HTML prvek vklÃ¡dÃ¡ do stromu strÃ¡nky, mÄ›nÃ­ jeho atributy Äi jej odebÃ­rÃ¡. Je dobrÃ½m zvykem vlastnÃ­ HTML znaÄky takto inicializovat prÃ¡vÄ› v okamÅ¾iku jejich pÅ™ipnutÃ­ do dokumentu.

VÃ½slednÃ© HTML je pak triviÃ¡lnÃ­ a hezky ukazuje, jak jsme funkcionalitu hledacÃ­ho formulÃ¡Å™e skryli, resp. zapouzdÅ™ili do implementace komponenty `SongSearch`.

DÄ›dÄ›nÃ­m z tÅ™Ã­dy `HTMLElement` jsme zÃ­skali praktickÃ© schopnosti rozhranÃ­ DOM (`this.innerHTML`, `this.querySelector`). TaktÃ©Å¾ jsme zÃ­skali moÅ¾nost na naÅ¡Ã­ vlastnÃ­ znaÄce poslouchat a zejmÃ©na vytvÃ¡Å™et vlastnÃ­ udÃ¡losti -- vÃ­ce si o tom povÃ­me v podkapitole pro profÃ­ky.

### Co jsme se nauÄili

Po vyÅ™eÅ¡enÃ­ osmÃ© Ãºlohy by mÄ›l ÄtenÃ¡Å™ chÃ¡pat a ovlÃ¡dat:

- definici vlastnÃ­ HTML znaÄky rozÅ¡Ã­Å™enÃ­m tÅ™Ã­dy `HTMLElement`
- registraci nÃ¡zvu vlastnÃ­ HTML znaÄky

## ZelenÃ¡Äi: gettery a settery

TÅ™Ã­da `SongResult` pro svÃ© fungovÃ¡nÃ­ potÅ™ebuje data, kterÃ¡ jÃ­ pÅ™edÃ¡vÃ¡me dedikovanou metodou `setData` (a nikoliv v konstruktoru, protoÅ¾e ten je zpravidla volÃ¡n bez parametrÅ¯). PÅ™i objektovÄ› orientovanÃ©m programovÃ¡nÃ­ se Äasto setkÃ¡vÃ¡me s podobnÃ½mi metodami, jejichÅ¾ ÃºÄelem je poskytovat Äi nastavovat data, se kterÃ½mi objekt pracuje. MluvÃ­me o tzv. *getterech* a *setterech*. V JavaScriptu existuje speciÃ¡lnÃ­ syntaxe, pomocÃ­ kterÃ© mÅ¯Å¾eme pro kaÅ¾dou vlastnost ve tÅ™Ã­dÄ› (Äi obecnÃ©m objektu) nadefinovat jejÃ­ vlastnÃ­ getter a setter -- funkci, volanou pÅ™i ÄtenÃ­ a zÃ¡pisu hodnoty danÃ© vlastnosti.

NaÅ¡i metodu `setData` bychom mohli pÅ™evÃ©st na setter takto:

```js
class SongResult extends HTMLElement {
	set data(song) {
		this.innerHTML = `<a href="${song.url}">${song.title}</a> <br/> ${song.text}`;
	}
}
```

VÅ¡imnÄ›me si klÃ­ÄovÃ©ho slovat `set`, uvedenÃ©ho pÅ™ed samotnou metodou. Jeho pÅ™Ã­tomnost Å™Ã­kÃ¡, Å¾e tato metoda bude volÃ¡na pÅ™i kaÅ¾dÃ©m pÅ™iÅ™azenÃ­ do vlastnosti `data`. S vzniklÃ½m HTML prvkem pak budeme pracovat nÃ¡sledovnÄ›:

```js
let songResult = document.createElement("song-result");
songResult.data = data;  // z odpovÄ›di HTTP poÅ¾adavku
```

PÅ™i ÄtenÃ­ vÃ½Å¡e uvedenÃ©ho kÃ³du nenÃ­ na prvnÃ­ pohled patrnÃ©, Å¾e pouhÃ½m pÅ™iÅ™azenÃ­m vykonÃ¡me nÄ›jakou logiku. To je cÃ­lem setterÅ¯: skrÃ½t pÅ™ed okolnÃ­m svÄ›tem skuteÄnost, Å¾e nastavenÃ­ vlastnosti `data` zpÅ¯sobÃ­ dalÅ¡Ã­ kroky, jako napÅ™. vykreslenÃ­ dalÅ¡Ã­ho HTML ve strÃ¡nce.

Symetricky je moÅ¾nÃ© definovat i getter. BÃ½vÃ¡ to obvyklÃ©, i kdyÅ¾ nikoliv nezbytnÃ©. NaÅ¡e tÅ™Ã­da `SongResult` v souÄasnÃ© podobÄ› getter pro vlastnost `data` mÃ­t ani nemÅ¯Å¾e, neboÅ¥ si zÃ­skanÃ¡ data nepamatuje (a proto je nemÅ¯Å¾e vrÃ¡tit). Museli bychom ji to nauÄit takto:

```js
class SongResult extends HTMLElement {
	get data() { return this._song; }

	set data(song) {
		this._song = song;
		this.innerHTML = `<a href="${song.url}">${song.title}</a> <br/> ${song.text}`;
	}
}

let songResult = document.createElement("song-result");
songResult.data = data;        // setter
console.log(songResult.data);  // getter
```

`SongResult` mÃ¡ nynÃ­ pro vlastnost `data` getter i setter. Objekt s vÃ½sledkem hledÃ¡nÃ­ uklÃ¡dÃ¡me do vlastnosti `_song`. PodtrÅ¾Ã­tko na zaÄÃ¡tku nemÃ¡ Å¾Ã¡dnÃ½ speciÃ¡lnÃ­ vÃ½znam, ale v praxi jeho pouÅ¾itÃ­m ÄtenÃ¡Å™i naznaÄujeme, Å¾e tato vlastnost je implementaÄnÃ­ detail tÅ™Ã­dy a zvenÄÃ­ by k nÃ­ nemÄ›l pÅ™istupovat (prÃ¡vÄ› proto jsme mu za tÃ­mto ÃºÄelem naimplementovali getter). Je to tedy jakÃ¡si alternativa *privÃ¡tnÃ­ch vlastnostÃ­*, kterÃ© se objevujÃ­ v jinÃ½ch jazycÃ­ch. V JavaScriptu privÃ¡tnÃ­ vlastnosti tÅ™Ã­d takÃ© existujÃ­ (staÄÃ­, aby jejich nÃ¡zev zaÄÃ­nal znakem mÅ™Ã­Å¾ky `#`), ale nejsou tak populÃ¡rnÃ­, protoÅ¾e je nelze pouÅ¾Ã­t v rÃ¡mci dÄ›diÄnosti.

ZvÃ­davÃ© ÄtenÃ¡Å™e moÅ¾nÃ¡ napadne, zdali bychom si pÅ™edanÃ¡ data mohli uloÅ¾it do `this.data`? KÃ³d by vypadal takto:

```js
class SongResult extends HTMLElement {
	set data(song) {
		this.data = song;
	}
}
```

TakovÃ½ zÃ¡pis ovÅ¡em nedÃ¡vÃ¡ smysl, respektive vede na tzv. *nekoneÄnou rekurzi*: v rÃ¡mci pÅ™iÅ™azenÃ­ `this.data` je opÄ›t volÃ¡n setter, takÅ¾e skonÄÃ­me v nekoneÄnÃ© smyÄce a nÃ¡slednÄ› s vÃ½jimkou o pÅ™Ã­liÅ¡ hlubokÃ©m zanoÅ™enÃ­ zÃ¡sobnÃ­ku volÃ¡nÃ­.


## KoumÃ¡ci: pÅ™edÃ¡vÃ¡nÃ­ hodnotou a odkazem

PÅ™i pÅ™edÃ¡vÃ¡nÃ­ dat tÅ™Ã­dÄ› se jeÅ¡tÄ› zastavÃ­me u otÃ¡zky, jakÃ¡ data se dostanou dovnitÅ™ volanÃ© funkce (aÅ¥ uÅ¾ je to setter z pÅ™edchozÃ­ podkapitoly, nebo bÄ›Å¾nÃ¡ metoda `setData` z pÅ¯vodnÃ­ho Å™eÅ¡enÃ­). Budou to jistÄ› ta samÃ¡, kterÃ¡ jsme dostali od serveru, ale dostane objekt `SongResult` jejich kopii, nebo je bude sdÃ­let s objektem `SongSearch`? A lze toto chovÃ¡nÃ­ nÄ›jak ovlivnit?

OdpovÄ›Ä na tyto otÃ¡zky je pÅ™Ã­moÄarÃ¡:

1. PrimitivnÃ­ datovÃ© typy (ÄÃ­sla, Å™etÄ›zce, pravdivostnÃ­ hodnoty, undefined, null) jsou *pÅ™edÃ¡vÃ¡ny hodnotou*. Do funkce se dostane kopie hodnoty, resp. uvnitÅ™ funkce nÃ¡slednÄ› nedokÃ¡Å¾eme ovlivnit hodnotu mimo funkci.
1. SloÅ¾itÃ© datovÃ© typy (zejmÃ©na objekty, pole, funkce) jsou *pÅ™edÃ¡vÃ¡ny odkazem*. Parametr ve funkci nabÃ½vÃ¡ tÃ© samÃ© hodnoty, jako promÄ›nnÃ¡ pÅ™edanÃ¡ pÅ™i volÃ¡nÃ­ (mÅ¯Å¾eme si jej pÅ™edstavit jako odkaz, referenci, ukazatel&hellip; podle toho, jakÃ¡ terminologie nÃ¡m vyhovuje). Pokud pak ve funkci nÄ›jak pÅ™edanÃ½ parametr pozmÄ›nÃ­me (zmÄ›nÃ­me jeho vlastnost, pÅ™idÃ¡me novou), projevÃ­ se to i vnÄ› funkce.

Tato pravidla jsou pevnÃ¡ a nelze je upravit. ZejmÃ©na druhÃ½ bod stojÃ­ za povÅ¡imnutÃ­. DÃ­ky tomuto zpÅ¯sobu pÅ™edÃ¡vÃ¡nÃ­ Å¡etÅ™Ã­me pamÄ›Å¥ (i kdyz promÄ›nnÃ¡ obsahuje velikÃ© mnoÅ¾stvÃ­ dat, pÅ™i jejÃ­m pÅ™edÃ¡nÃ­ do funkce se nemusÃ­ nikam kopÃ­rovat), ale zÃ¡roveÅˆ se vystavujeme riziku, Å¾e pÅ™edÃ¡nÃ­m dat dojde k jejich zmÄ›nÄ›, aniÅ¾ bychom to Äekali.

PÅ™edstavme si napÅ™Ã­klad Ãºlohu, pÅ™i kterÃ© dostaneme od serveru pole uÅ¾ivatelÅ¯ (u kaÅ¾dÃ©ho bude uvedeno jmÃ©no a vÄ›k). MÃ¡me je nÃ¡slednÄ› vypsat a taktÃ©Å¾ sdÄ›lit, kolik let je nejmladÅ¡Ã­mu z nich:

```js
let users = [
	{name:"Eva", age: 30},
	{name:"Jana", age: 50},
	{name:"Mirek", age: 10}
];

let minAge = getMinAge(users);
console.log("NejniÅ¾Å¡Ã­ vÄ›k: ", minAge);

users.forEach(console.log);
```

Jak naimplementovat funkci `getMinAge`? NejsnazÅ¡Ã­ Å™eÅ¡enÃ­ je seÅ™adit uÅ¾ivatele dle vÄ›ku vzestupnÄ› a pak se podÃ­vat na prvnÃ­ho z nich. KaÅ¾dÃ© JavaScriptovÃ© pole disponuje metodou `sort`, kterÃ© staÄÃ­ pÅ™edat vhodnou *porovnÃ¡vacÃ­ funkci* (protoÅ¾e Å™azenÃ­ Äehokoliv je vlastnÄ› jen opakovanÃ© porovnÃ¡vÃ¡nÃ­). PorovnÃ¡vacÃ­ funkce dostane dva vzorky a jejÃ­m Ãºkolem je vrÃ¡tit ÄÃ­selnou hodnotu, kterÃ¡ vyjadÅ™uje jejich vzÃ¡jemnÃ½ pomÄ›r:

  - nulu, kdyÅ¾ jsou stejnÃ©
  - kladnÃ© ÄÃ­slo, kdyÅ¾ je prvnÃ­ vzorek vÄ›tÅ¡Ã­
  - zÃ¡pornÃ© ÄÃ­slo, kdyÅ¾ je prvnÃ­ vzorek menÅ¡Ã­

V naÅ¡em pÅ™Ã­padÄ› pak implementace `getMinAge` mÅ¯Å¾e vypadat takto:

```js
function compareUsers(u1, u2) {
	return u1.age - u2.age;
}

function getMinAge(users) {
	users.sort(compareUsers);
	return users[0].age;
}
```

JenÅ¾e pozor! Metoda `sort` pole pozmÄ›nila (seÅ™adila). Stalo se tak uvnitÅ™ funkce `getMinAge`, nicmÃ©nÄ› parametr `users` je sloÅ¾itÃ½ datovÃ½ typ, takÅ¾e zmÄ›ny na nÄ›m provÃ¡dÄ›nÃ© uvnitÅ™ `getMinAge` se projevÃ­ i mimo funkci. Jakmile pak uÅ¾ivatele (globÃ¡lnÃ­ promÄ›nnou `users`) vypÃ­Å¡eme cyklem `forEach`, zjistÃ­me, Å¾e je vypisujeme seÅ™azenÃ© -- coÅ¾ v zadÃ¡nÃ­ rozhodnÄ› nebylo.

Co s tÃ­m? NechtÄ›nÃ© zmÄ›nÄ› mÅ¯Å¾eme pÅ™edchÃ¡zet na stranÄ› volajÃ­cÃ­ho (ten, kdo chce zavolat `getMinAge`, ji musÃ­ pÅ™edat nÄ›jakÃ¡ data, u kterÃ½ch nevadÃ­ zmÄ›na) i na stranÄ› volanÃ©ho (funkce `getMinAge` se zavÃ¡Å¾e, Å¾e pÅ™edanÃ¡ data nebude mÄ›nit). V praxi bÃ½vÃ¡ zvykem druhÃ½ pÅ™Ã­stup, neboÅ¥ v naprostÃ© vÄ›tÅ¡Ã­nÄ› pÅ™Ã­padÅ¯ se od funkcÃ­ neoÄekÃ¡vÃ¡, Å¾e by mÄ›nily data, se kterÃ½mi majÃ­ pracovat. Je tedy nutnÃ© upravit `getMinAge`, aby se chovala zodpovÄ›dnÄ›ji. Toho mÅ¯Å¾eme docÃ­lit dvÄ›ma zpÅ¯soby:

1. UniverzÃ¡lnÃ­ Å™eÅ¡enÃ­ je, aby si `getMinAge` pÅ™ed seÅ™azenÃ­m vytvoÅ™ila duplikÃ¡t dat. To nelze prostÃ½m pÅ™iÅ™azenÃ­m (bystrÃ½ ÄtenÃ¡Å™ uhodne, proÄ je zÃ¡pis `let users2 = users; users2.sort()` k niÄemu) a v JavaScriptu nenÃ­ Å¾Ã¡dnÃ½ obecnÃ½ mechanismus na klonovÃ¡nÃ­. ProtoÅ¾e je ovÅ¡em `users` pole, mÅ¯Å¾eme snadno vytvoÅ™it jeho kopii napÅ™Ã­klad metodou `slice`, kterÃ¡ vracÃ­ podmnoÅ¾inu. Bez zadÃ¡nÃ­ parametrÅ¯ (odkud-kam) vytvoÅ™Ã­ kopii:

	```js
	let users2 = users.slice()
	```

1. AlternativnÄ› mÅ¯Å¾eme hledat takovou metodu na seÅ™azenÃ­ pole, kterÃ¡ zadanÃ½ parametr nezmÄ›nÃ­, ale vrÃ¡tÃ­ novÃ© (seÅ™azenÃ©) pole. TakovÃ¡ se do JavaScriptu dostala jako Å¾havÃ¡ novinka v roce 2023 a lze ji volat takto:

	```js
	let sortedUsers = users.toSorted(compareUsers);
	```

Z pÅ™Ã­kladu v tÃ©to podkapitole si bereme ponauÄenÃ­, Å¾e bychom mÄ›li naÅ¡e funkce vÃ©st k zodpovÄ›dnÃ©mu chovÃ¡nÃ­, pokud jako parametry dostÃ¡vajÃ­ sloÅ¾itÃ© datovÃ© typy. VolajÃ­cÃ­ bude v naprostÃ© vÄ›tÅ¡inÄ› pÅ™Ã­padÅ¯ oÄekÃ¡vat, Å¾e jeho data Å¾Ã¡dnÃ½m zpÅ¯sobem nepozmÄ›nÃ­me.

## ProfÃ­ci: vlastnÃ­ udÃ¡losti

PouÅ¾itÃ­m techniky *Custom Elements* vytvÃ¡Å™Ã­me takovÃ© tÅ™Ã­dy, kterÃ© dovedou zpracovÃ¡vat naÅ¡e data a pÅ™itom zÅ¯stÃ¡vajÃ­ bÄ›Å¾nÃ½mi obyvateli HTML dokumentu. DÄ›dÄ›nÃ­m z `HTMLElement` dostÃ¡vajÃ­ vlastnosti a metody, kterÃ© jsme doposud vÃ­dali jen u vestavÄ›nÃ½ch HTML znaÄek. Metodu `addEventListener` nemusÃ­me pÅ™edstavovat, ale pro plnohodnotnÃ© vyuÅ¾itÃ­ systÃ©mu udÃ¡lostÃ­ si ukÃ¡Å¾eme druhou stranu tÃ©to mince: moÅ¾nost udÃ¡losti vytvÃ¡Å™et a vyvolÃ¡vat.

ZatÃ­m takovÃ¡ potÅ™eba nebyla, neboÅ¥ tÃ©mÄ›Å™ veÅ¡kerÃ© udÃ¡losti v knize probÃ­ranÃ© vznikaly na zÃ¡kladÄ› uÅ¾ivatelovy interakce, tj. za jejich vytvoÅ™enÃ­ byl zodpovÄ›dnÃ½ prohlÃ­Å¾eÄ. Pokud ale pÅ™istoupÃ­me na skladbu aplikace, pÅ™i kterÃ© jsou jednotlivÃ© komponenty realizovÃ¡ny HTML znaÄkami, mÅ¯Å¾ou se nÃ¡m udÃ¡losti hodit jako notifikaÄnÃ­ mechanismus.

Na udÃ¡lost mÅ¯Å¾eme nahlÃ­Å¾et jako na zprÃ¡vu, kterÃ¡ mÃ¡ prÃ¡vÄ› jednoho odesÃ­latele (HTML prvek, na kterÃ©m vznikla) a libovolnÃ© mnoÅ¾stvÃ­ ÄtenÃ¡Å™Å¯ (posluchaÄÅ¯). OdesÃ­latel pÅ™itom o ÄtenÃ¡Å™Ã­ch nevÃ­, nestarÃ¡ se o jejich poÄet ani existenci. Je to velmi blÃ­zkÃ© nÃ¡vrhovÃ©mu vzoru *PubSub (Published-Subscriber)*. V minulÃ© kapitole jsme uvaÅ¾ovali, jak by moderovanÃ½ diskuznÃ­ pÅ™Ã­spÄ›vek mohl dÃ¡t svÃ©mu okolÃ­ najevo, Å¾e je nutnÃ© pÅ™Ã­spÄ›vky znovu naÄÃ­st -- vlastnÃ­ udÃ¡losti by poslouÅ¾ily jako funkÄnÃ­ Å™eÅ¡enÃ­.

V tÃ©to podkapitole mÃ¡me tÅ™Ã­du `SongResult` reprezentujÃ­cÃ­ vÃ½sledek hledÃ¡nÃ­. PÅ™edstavme si, Å¾e bychom chtÄ›li dÃ¡t uÅ¾ivateli moÅ¾nost zpÄ›tnÃ© vazby, pÅ™i kterÃ© by jednotlivÃ© vÃ½sledky mohl oznaÄovat jako *dobrÃ©* a *Å¡patnÃ©*. Tuto informaci bychom pÅ™edali serveru (aby mohl zlepÅ¡ovat svÃ© vyhledÃ¡vacÃ­ algoritmy) a zÃ¡roveÅˆ bychom Å¡patnÃ© vÃ½sledky rovnou nahradili nÄ›jakÃ½mi dalÅ¡Ã­mi.

TakovÃ© hodnocenÃ­ vÃ½sledkÅ¯ bude jistÄ› iniciovÃ¡no uÅ¾ivatelskou interakcÃ­, tj. kliknutÃ­m na tlaÄÃ­tko. KterÃ¡ z naÅ¡ich dvou tÅ™Ã­d by mÄ›la realizovat takovÃ½ posluchaÄ? Argumenty mÃ¡me pro obÄ› dvÄ›:

- Poslouchat by mÄ›la tÅ™Ã­da `SongResult`, neboÅ¥ po kliknutÃ­ budeme muset server informovat o uÅ¾ivatelovÄ› hodnocenÃ­ tohoto konkrÃ©tnÃ©ho vÃ½sledku.
- Poslouchat by mÄ›la tÅ™Ã­da `SongSearch`, neboÅ¥ pokud pÅ¯jde o oznaÄenÃ­ *Å¡patnÃ©ho* vÃ½sledku, bude pak muset vyvolat novÃ© hledÃ¡nÃ­.

KlÃ­ÄovÃ½ argument je ovÅ¡em ve prospÄ›ch tÅ™Ã­dy `SongResult`. Skladbu HTML vÃ½sledku hledÃ¡nÃ­ jsme *zapouzdÅ™ili* do tÃ©to tÅ™Ã­dy jako jejÃ­ vlastnÃ­ implementaÄnÃ­ detail a ostatnÃ­ objekty o jejÃ­ vnitÅ™nÃ­ struktuÅ™e nemajÃ­ ponÄ›tÃ­. Abychom dali tÅ™Ã­dÄ› `SongSearch` vÄ›dÄ›t o nutnosti doplnÄ›nÃ­ dalÅ¡Ã­ch vÃ½sledkÅ¯, nechÃ¡me tÅ™Ã­du `SongResult` prostÄ› vygenerovat vlastnÃ­ udÃ¡lost, jakmile dokonÄÃ­me komunikaci se serverem. ZaÄneme obohacenÃ­m setteru z prvnÃ­ podkapitoly:

```js
class SongResult extends HTMLElement {
	set data(song) {
		this._song = song;
		this.innerHTML = `<a href="${song.url}">${song.title}</a> <br/> ${song.text}`;

		let ok = document.createElement("button");
		ok.textContent = "ğŸ‘";
		ok.addEventListener("click", () => this.sendRating("ok"));

		let ko = document.createElement("button");
		ko.textContent = "ğŸ‘";
		ko.addEventListener("click", () => this.sendRating("ko"));

		this.append(ok, ko);
	}
}
```

SamotnÃ¡ implementace hodnocenÃ­ nenÃ­ zajÃ­mavÃ¡. Bude se jistÄ› jednat o asynchronnÃ­ funkci, neboÅ¥ potÅ™ebuje komunikovat se serverem. NÃ¡s ale zajÃ­mÃ¡ jen ta ÄÃ¡st, kdy po dokonÄenÃ­ komunikace vytvoÅ™Ã­me a poÅ¡leme vlastnÃ­ udÃ¡lost:

```js
class SongResult extends HTMLElement {
	async sendRating(rating) {
		// await fetch(...)

		let event = new CustomEvent("rating", {
			detail: {rating},
			bubbles: true
		});
		this.dispatchEvent(event);
	}
}
```

TÅ™Ã­da `CustomEvent` vytvoÅ™Ã­ objekt udÃ¡losti, kterÃ½ jsme navyklÃ­ pÅ™ijÃ­mat jako parametr posluchaÄe. PrvnÃ­ parametr `CustomEvent` je nÃ¡zev udÃ¡losti, druhÃ½ je volitelnÃ½ konfiguraÄnÃ­ objekt. Z jeho klÃ­ÄÅ¯ je pro nÃ¡s zajÃ­mavÃ¡ hodnota `bubbles` (zdali udÃ¡lost bublÃ¡, nebo je na ostatnÃ­ch HTML prvcÃ­ch dostupnÃ¡ jen prostÅ™ednictvÃ­m zachytÃ¡vÃ¡nÃ­) a pak `detail`, do kterÃ©ho mÅ¯Å¾eme vloÅ¾it libovolnÃ¡ data. ÄŒinÃ­me tak proto, aby posluchaÄ udÃ¡losti poznal, k jakÃ©mu hodnocenÃ­ doÅ¡lo. Nakonec udÃ¡lost vyvolÃ¡me metodou `dispatchEvent`, coÅ¾ zpÅ¯sobÃ­ volÃ¡nÃ­ dÅ™Ã­ve pÅ™idanÃ½ch posluchaÄÅ¯.

Ve tÅ™Ã­dÄ› `SongSearch` pak budeme tuto udÃ¡lost poslouchat. PosluchaÄe na ni bychom mohli pÅ™idÃ¡vat individuÃ¡lnÄ› na kaÅ¾dÃ½ vzniklÃ½ `<song-result>` (pak by udÃ¡lost nemusela bublat), ale stejnÄ› dobÅ™e jej mÅ¯Å¾eme pÅ™idat napÅ™Ã­klad na prvek `.results`, nebo pÅ™Ã­mo na celÃ½ `<song-search>`. V takovÃ© situaci staÄÃ­ posluchaÄ pÅ™idat jen jednou, nezÃ¡visle na tom, kdy a kolik vÃ½sledkÅ¯ zobrazujeme:

```js
class SongSearch extends HTMLElement {
	connectedCallback() {
		this.innerHTML = HTML;
		this.querySelector("form").addEventListener("submit", this);
		this.addEventListener("rating", this);
	}

	handleEvent(e) {
		switch (e.type) {
			case "submit":
				// existujÃ­cÃ­ kÃ³d souvisejÃ­cÃ­ s provedenÃ­m hledÃ¡nÃ­
			break;

			case "rating":
				if (e.detail.rating == "ko") {
					// donaÄtenÃ­ novÃ½ch vÃ½sledkÅ¯
				}
			break;
		}
	}
```

PrÃ¡ce s vlastnÃ­mi udÃ¡lostmi nabÃ­zÃ­ ideÃ¡lnÃ­ mechanismus pro podobnÃ© notifikace o komponentÃ¡ch napÅ™Ã­Ä naÅ¡Ã­ aplikacÃ­. VyuÅ¾Ã­vÃ¡me k tomu pÅ™itom infrastrukturu, kterou uÅ¾ velmi dobÅ™e znÃ¡me z udÃ¡lostÃ­ typu *click* a podobnÄ›. Pro Ãºplnost jeÅ¡tÄ› dodejme, Å¾e pokud bychom chtÄ›li dÃ¡t naÅ¡im tÅ™Ã­dÃ¡m moÅ¾nost pracovat s udÃ¡lostmi (tj. metody `addEventListener` a `dispatchEvent`), nemusÃ­me je kvÅ¯li tomu nutnÄ› definovat jako Custom Elements. StaÄÃ­, aby byly potomkem tÅ™Ã­dy `EventTarget`. To je k prÃ¡ci s udÃ¡lostmi dostaÄujÃ­cÃ­, i kdyÅ¾ tÃ­m pÅ™ijdeme o moÅ¾nost propagace udÃ¡lostÃ­ stromem strÃ¡nky -- toto chovÃ¡nÃ­ je dostupnÃ© jen HTML znaÄkÃ¡m.
