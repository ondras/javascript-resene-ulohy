# Kapitola 9: Web Components

## Úloha

V šesté kapitole jsme vytvořili single-page aplikaci, která zobrazuje výsledky hledání bez opakovaného načítání stránky. Upravte tento kód opět dle pravidel objektově orientovaného programování, ale tentokrát pomocí konceptu Web Components.


### Řešení

Označení Web Components používáme tam, kde se rozhodneme naše třídy definovat jako potomky existujících HTML značek. Znamená to, že takto dokážeme vytvářet vlastní HTML značky, kterým pomocí JavaScriptu dodáme specifickou funkcionalitu (a pomocí CSS specifický vzhled). Myšlenka Web Components je značně obsáhlá a vydala by na samostatnou knihu; vzorové řešení této kapitoly je pro nás proto jen drobnou ochutnávkou této techniky.

HTML, které potřebujeme vytvořit, sestává ze tří částí: hledacího formuláře, prostoru pro výsledky a jednotlivých položek nalezených písní. My zkusíme vyvořit vlastní HTML značku pro formulář (ta bude obsahovat logiku související s HTTP požadavky) a dále pro každý výsledek hledání.

```html
<!-- kapitola-9.html -->
<link rel="stylesheet" href="song-result.css" />

<h1>Hledání</h1>
<song-search></song-search>

<script src="song-search.js"></script>
<script src="song-result.js"></script>
```

```js
// song-search.js
class SongSearch extends HTMLElement {
	connectedCallback() {
		this.innerHTML = HTML;
		this.querySelector("form").addEventListener("submit", this);
	}

	async handleEvent(e) {
		e.preventDefault();
		let query = this.querySelector("[name=query]").value;
		let url = `/search?query=${encodeURIComponent(query)}`;
		let response = await fetch(url);
		let songs = await response.json();
		this.showResults(songs, query);
	}

	showResults(songs, query) {
		let parent = this.querySelector(".results");
		if (songs.length == 0) {
			parent.replaceChildren("Tomuto dotazu nevyhovují žádné písně 🙁");
			return;
		}

		let heading = document.createElement("h2");
		heading.textContent = `Nalezené písně pro dotaz: ${query}`;

		let ol = document.createElement("ol");
		parent.replaceChildren(heading, ol);

		let results = songs.map(item => {
			let result = document.createElement("song-result");
			result.setData(item);
			return result;
		});
		ol.replaceChildren(...results);
	}
}

const HTML = `<form>
	<label>
		Hledaný výraz: <input type="text" name="query" />
	</label>
	<label><button>🔎</button></label>
</form>
<div class="results"></div>`;

customElements.define("song-search", SongSearch);
```

```js
// song-result.js
class SongResult extends HTMLElement {
	setData(song) {
		this.innerHTML = `<a href="${song.url}">${song.title}</a> <br/> ${song.text}`;
	}
}

customElements.define("song-result", SongResult);
```

```css
/* song-result.css */
song-result {
	display: list-item;
}
```

Definice vlastních HTML značek se příliš neliší od běžných tříd, se kterými jsme se seznámili v předchozí kapitole. Aby se s naší třídou dalo pracovat jako s HTML značkou, musíme vykonat tyto dva povinné kroky:

1. Definovat svou třídu jako potomka některé HTML značky. Typicky toho docílíme zápisem `extends HTMLElement`, tedy děděním z obecné HTML značky.

1. **Zaregistrovat** vzniklou třídu jako definici pro HTML parser. V tomto kroku také dodáme název HTML značky, kterou chceme používat. K tomu slouží globální objekt `customElements` a jeho metoda `define`, pomocí které spárujeme třídu a název. Za zmínku stojí, že v názvu musí být obsažena pomlčka. To garantuje tzv. *dopřednou kompatibilitu*: protože standardní HTML značky ve svém názvu nikdy pomlčku neobsahují, nestane se v budoucnu, že by došlo ke vzniku nového HTML prvku, který by názvem kolidoval s tím naším vlastním.

Třída `SongResult` je malinká a dovede jedinou věc: převést data jednoho výsledku hledání na HTML. K této nové HTML značce rovnou dodáme také definici stylu, ve které zápisem `display: list-item` zařídíme, aby se naše `<song-result>` korektně zobrazila jako položka seznamu. To proto, že ji máme v plánu umístit do odrážkového seznamu, vytvořeného v `<song-search>`.

Optikou objektově orientovaného programování je nezvyklé, že potřebná data nepředáváme konstruktoru třídy `SongResult` a namísto toho tak činíme pomocí metody `setData`. Důvod je ten, že tvorba instancí `SongResult` probíhá zápisem `document.createElement("song-result")` uvnitř třídy `SongSearch`, při kterém nelze žádná data předávat.

Tím se dostáváme k objemnější komponentě `<song-search>`. Většina její implementace je převzata z šesté kapitoly a neobsahuje nic nového. Ani zde nevidíme konstruktor; namísto toho jsme inicializaci (tvorbu formuláře a přidání posluchače) odložili do metody `connectedCallback`. Ta patří k několika tzv. *lifecycle callbackům*; funkcím, které volá prohlížeč, když HTML prvek vkládá do stromu stránky, mění jeho atributy či jej odebírá. Je dobrým zvykem vlastní HTML značky takto inicializovat právě v okamžiku jejich připnutí do dokumentu.

Výsledné HTML je pak triviální a hezky ukazuje, jak jsme funkcionalitu hledacího formuláře skryli, resp. zapouzdřili do implementace komponenty `SongSearch`.

Děděním z třídy `HTMLElement` jsme získali praktické schopnosti rozhraní DOM (`this.innerHTML`, `this.querySelector`).

### Co jsme se naučili
## Zelenáči
## Koumáci
## Profíci
