# Kapitola 14: Co se nevešlo

Úlohy z minulých kapitol byly vybrány tak, abychom si jejich prostřednictvím prohlédli a vyzkoušli různé partie JavaScriptu. Pro vážné zájemce tu ještě zbylo několik témat, která nemají společnou úlohu a do celkové architektury knihy tak úplně nezapadají. Abychom zvídavého čtenáře o tyto doplňkové zajímavosti nepřipravili, podíváme se na ně nyní formou neorganizovaného bonusu.

## Pro zelenáče: SVG

## Pro koumáky: ???

## Pro profíky: iterační protokol

Ve třetí kapitole jsme se seznamovali s různými formami iterace. Při použití syntaxe `for-of` dochází k *programovatelné iteraci*, kdy procházený objekt sám specifikuje, co to znamená *vrátit další položku*.

Představme si značný objem textu, který potřebujeme zpracovávat po řádkách. Může jít o velký dokument získaný prostřednictvím HTTP požadavku, logovací soubor nebo cokoliv jiného. Rozdělit text na jednotlivé řádky je triviální (stačí použít metodu `split`, které předáme rozdělovací podřetězec), ale zároveň nešikovné s ohledem na výkon. Při převodu řetězce na pole vznikne fakticky duplikát původního textu, takže touto operací zabereme alespoň dvojnásobek paměti. Chytřejší je v původním textu postupně vyhledávat oddělovače řádků a soustředit se na jednotlivé podřetězce mezi nimi.

Toto chytřejší procházení můžeme vytvořit jako iterovatelný objekt. Zadáme mu velký vstupní text a oddělovač; pak mu budeme opakovaně říkat *„dej další kousek!“* tak dlouho, než dojdeme na konec procházených dat.

Přesně takhle funguje iterační protokol. Musíme vytvořit objekt s metodou `next()`, která vrátí další iterovanou položku a také příznak, zdali už jsme na konci, nebo můžeme pokračovat. Jeho návratovou hodnotou proto bude objekt s vlastnostmi `value` (vrácená hodnota) a `done` (bool, jsme-li na konci). Proces iterace je stavový (mezi jednotlivými voláními `next()` si musíme pamatovat, kde jsme minule oddělovač nalezli), takže pro jeho realizaci často používáme uzávěru:

```js
function createIterator(text) {
	let separator = "\n";
	let lastIndex = 0;
	return {
		next() {
			if (lastIndex > text.length) {
				return { value: undefined, done: true };
			}

			let index = text.indexOf(separator, lastIndex);
			if (index == -1) {  // oddelovac nenalezen
				let value = text.slice(lastIndex);
				lastIndex = text.length+1;
				return { value, done: false };
			} else {            // oddelovac nalezen
				let value = text.slice(lastIndex, index);
				lastIndex = index + separator.length;
				return { value, done: false };
			}
		}
	}
}
```

Při hledání oddělovače využíváme volitelného druhého parametru metody `indexOf`, který říká, od kolikátého znaku hledáme. V proměnné `lastIndex` si pamatujeme, kde jsme minule hledání skončili. Při zavolání `next()` se tak můžou stát tři různé věci:

1. Pokud jsme se minulým hledáním dostali na konec textu, vrátíme v odpovědi `done:true` (hodnota není relevantní, náš iterátor již nic nevrací).

1. Pokud jsme v neprozkoumané části textu našli oddělovač, vrátíme podřetězec (od minulého oddělovače k novému) a zapamatujeme si pozici jeho konce oddělovače.

1. Pokud jsme už žádný další oddělovač nenašli, vrátíme zbytek textu (od minulého oddělovače do konce).

Z toho plyne, že i když v textu žádný oddělovač nenalezneme, metoda `next()` vždy vrátí alespoň jednu hodnotu (poslední položka v seznamu výše).

Abychom tento objekt (když má metodu `next()`, říkáme mu *iterátor*) mohli při iteraci použít, zbyvá ho vložit na správné předem dohodnuté místo. Konkrétně jej musí *vrátit funkce, kterou do iterovaného datového typu vložíme pod klíč `Symbol.iterator`*. Zní to složitě, ale implementace je jednoduchá. Můžeme si pomoci například třídou:

```js
class LineIterator {
	constructor(text) {
		this.text = text;
	}

	[Symbol.iterator]() {
		return createIterator(this.text);
	}
}
```

Tím je obřad tvorby iterátoru dokončen a my jej můžeme s velkou slávou použít:

```js
let data = "a\nb\nc";
let iterator = new LineIterator(data);
for (let line of iterator) console.log(line);
```

Mimochodem: výše uvedený kód implementuje tzv. *synchronní iterační protokol*. V praxi se můžeme setkat s variantou, kdy je funkce `next()` asynchronní (tj. vrací Promise, protože například stahuje data HTTP požadavkem a podobně). Takový asynchronní iterátor pak umístíme pod klíč `Symbol.asyncIterator` a pracujeme s ním syntaxí `for await (let x of ...)`.
