# Kapitola 12: JavaScript mimo prohlížeč

Většinu knihy jsme se věnovali JavaScriptu v prostředí webového prohlížeče, dokumentu HTML a rozhraní DOM. JavaScript je však univerzální jazyk a tak není překvapivé, že ho lze používat i v jiných situacích. Často se použití bez prohlížeče týká serverového prostředí, ale ukážeme si, že se nám může hodit i pro bežné programátorské úkony zcela mimo provoz webových aplikací.

Proč bychom chtěli používat JavaScript tam, kde máme na výběr téměř všechny ostatní myslitelné programovací jazyky? Důvodů může být více: pokud už ovládáme JavaScript v prohlížeči, můžeme získané dovednosti znovupoužít na serveru. Může nám také vyhovovat koncept asynchronního programování, na kterém je JavaScript vystaven. A konečně, díky JavaScriptu připadá v úvahu možnost sdílení některého kódu mezi serverovou a klientskou částí aplikace. Tuto vlastnost se pokusíme využít i v úloze, kterou za malou chvíli vyřešíme.

Co to technologicky znamená, JavaScript bez prohlížeče? Potřebujeme implementaci jazyka samotného a k tomu takovou sadu rozhraní, abychom dokázali přistupovat k souborům, obrazovce, síti a dalším komponentám počítače. Zdaleka nejpopulárnější možností je v tomto směru projekt Node.js, který staví na jádře V8 (stejně jako prohlížeče Chrome a Edge) a přidává k němu bohatou sadu vestavěných knihoven. Výsledek je k dispozici pro všechny operační systémy a navíc zdarma (open source). Můžeme si jej stáhnout, nainstalovat a pak spouštět pomocí příkazu `node` v příkazové řádce.


## Úloha

Vytvořte základ HTTP serveru, který bude umožňovat registraci uživatelských účtů. Založené účty evidujte v souboru `accounts.json`.

### Řešení

```js
// kapitola-12.js
import * as fs from "node:fs";
import * as http from "node:http";
import validateUsername from "./validate-username.js";


let accounts = [];
try {
	let data = fs.readFileSync("accounts.json");
	accounts = JSON.parse(data);
} catch (e) {}

function processRequest(req, res) {
	if (req.method != "POST") {
		res.writeHead(204);
		res.end();
		return;
	}

	let body = "";
	req.on("data", chunk => body += chunk.toString());

	req.on("end", () => {
		let data = JSON.parse(body);

		if (validateUsername(data.username)) {
			accounts.push(data);
			res.writeHead(200);
			fs.writeFile("accounts.json", JSON.stringify(accounts), e => {});
		} else {
			res.writeHead(400);
		}

		res.end();
	});
}

const server = http.createServer(processRequest);
server.listen(8000);
```

```js
// validate-username.js
export default function(username) {
	return username.match(/^[a-z]/);
}
```

```json
// package.json
{
  "type":"module"
}
```

Přestože se jedná o JavaScript, můžeme být překvapeni některými odlišnostmi od kódu, který jsme zvyklí psát v prohlížeči. Začněme malinkatým souborem `package.json`, který je v ukázce až úplně na konci, a který bývá součástí každého projektu pro Node.js. Je určen pro různá metadata naší aplikace, výčet závislostí a další konfiguraci. My do něj do začátku přidáme jedinou konfigurační položku (`"type":"module"`), která říká, že kód plánujeme dělit do souboru pomocí ES modulů (poprvé jsme je potkali v osmé kapitole). Prostředí Node.js je relativně staré a historicky nabízí i odlišný způsob členění kódu do knihoven. Protože je ale jedním z našich cílů možnost sdílení kódu mezi serverm a prohlížečem, rozhodně chceme používat ES moduly, tj. klíčová slova `export` a `import`.

Samotný kód serveru je v souboru `kapitola-12.js`. Rozdělme si jej do menších částí. Hned na začátku importujeme potřebné knihovny:

```js
import * as fs from "node:fs";
import * as http from "node:http";
import validateUsername from "./validate-username.js";
```

První dva importy odpovídají vestavěným knihovnám, které jsou součástí Node.js. Proto jejich identifikace začíná tzv. pseudo-protokolem `node:` -- a hned vidíme první rozdíl, oproti klientskému JavaScriptu, ve kterém lze importovat jen soubory z webových adres (HTTP/HTTPS), případně relativní vůči aktuálnímu skriptu (s tečkou na začátku). Třetí import je naše vlastní miniaturní knihovna, která obsahuje jedinou funkci `validateUsername`. Tu plánujeme použít pro kontrolu zadaného uživatelského jména. Do vlastního souboru jsme ji umístili právě proto, abychom tento mohli následně importovat i do HTML dokumentu a kontrolní funkci mohli používat i při klientské kontrole před odesláním formuláře (viz kapitola 4).

Namísto opravdové databáze budeme uživatelské účty spravovat v obyčejném souboru. Kód našeho serveru proto začíná načtením existujících dat z tohoto souboru. K tomu se hodí funkce `readFileSync`. Blok try-catch je přítomen pro případ, že by soubor neexistoval:

```js
let accounts = [];
try {
	let data = fs.readFileSync("accounts.json");
	accounts = JSON.parse(data);
} catch (e) {}
```

Dostáváme se k hlavní části aplikace. HTTP server je dlouho-běžící program (spustíme jej a očekáváme, že bude spuštěn stále, dokud je sami ručně nevypneme), jehož úkolem je zpracovávat požadavky, přicházející po síti. V rámci standardní knihovny Node.js jsme získali modul `http`, který většinu této práce udělá za nás. Stačí pak dodat vlastní funkci, která jako parametr získá data příchozího požadavku a jejím úkolem bude vyrobit odpověď. Pojmenovali jsme ji `processRequest` a server je zavolá pro každý příchozí HTTP požadavek.

Nejprve musíme rozpoznat, jestli se skutečně jedná o požadavek na registraci uživatelského účtu. Naše kontrola je jednoduchá:

```js
if (req.method != "POST") {
	res.writeHead(204);
	res.end();
	return;
}
```

Pro jednoduchost jen ověřujeme, zdali je požadavek realizován HTTP metodou `POST`. V praxi bychom typicky chtěli ještě kontrolovat URL, formát dat (hlavičku `Content-Type`) a další. Nevhodné požadavky zodpovíme stavovým kódem 204 (tzv. *No Content*; tento předdefinovaný stav informuje klienta, že server na požadavek nemá žádnou odpověď) a metodou `res.end()` odešleme zpět klientovi.

Následuje několik řádků věnovaných zpracování těla požadavku:

```js
let body = "";
req.on("data", chunk => body += chunk.toString());
req.on("end", () => { ... })
```

Předpokládáme, že klient nám data posílá ve formátu JSON. V kontextu HTTP serveru je ovšem tělo požadavku představováno prostým řetězcem, který navíc může po síti přicházet v menších kouscích (paketech). Proto tyto části postupně přidáváme do velkého řetězce. Teprve když data od klienta dorazí všechna, můžeme pokračovat dále.

Můžeme si přitom všimnout, že funkce `processRequest` je asynchronní. Její vykonávání už dávno skončilo, server může zpracovávat další požadavky, ale my mezitím čekáme na data. V knihovně `node:http` se o datech dozvídáme prostřednictím událostí -- obdobně, jako v rozhraní DOM metodou `addEventListener`. Ve světě serverového JavaScriptu ale není žádný strom dokumentu a proto se s událostmi pracuje odlišně; mimo jiné i jinak pojmenovanými metodami. V tomto případě přidáváme posluchač metodou `on` a zajímají nás dvě události: příchod další části dat (událost `data`) a ukončení HTTP požadavku (událost `end`).

Poslední část funkce `processRequest` následně zpracuje získaná data:

```js
let data = JSON.parse(body);

if (validateUsername(data.username)) {
	accounts.push(data);
	res.writeHead(200);
	fs.writeFile("accounts.json", JSON.stringify(accounts), e => {});
} else {
	res.writeHead(400);
}

res.end();
```

Pro kontrolu získaných dat použijeme importovanou funkci `validateUsername`, která vrací pravdivnostní hodnotu. Při neúspěchu jen vrátíme stavový kód 400 (tzn. *Bad Request*, tedy chyba klienta). Pokud kontrola dopadne dobře, přidáme získaná data do pole `accounts` a jeho obsah následně zapíšeme do souboru. Zápis tentokrát realizujeme asynchronní funkcí `writeFile`, která neblokuje další vykonávání kódu -- to proto, abychom zápisem na disk neoddalovali odpověď klientovi a zpracování dalších požadavků. Třetí parametr pro `writeFile` je *callback*; funkce, která bude vykonána po zapsání a jako parametr dostane informaci o případné chybě.

Výše uvedený kód je funkční, ale rozhodně není robustní. Za domácí úkol je možné naimplementovat celou řadu jeho vylepšení:

1. Neprovádíme žádnou kontrolu duplicity uživatelských jmen.
1. Do pole `accounts` ukládáme veškerá příchozí data, aniž bychom se podívali, kolik jich je (a co je jejich obsahem).
1. Pokud v rámci registrace ukládáme také heslo, jistě bychom jej měli vhodným způsobem zabezpečit (uložit jej hashované a osolené).
1. Pokud selže kontrola uživ. jména, měli bychom v odpovědi klientovi sdělit také informaci o tom, co přesně bylo v poslaném jménu špatně.

Úplně na konci vzorového řešení zbývá samotné spuštění serveru:

```js
const server = http.createServer(processRequest);
server.listen(8000);
```

Parametr pro funkci `listen` je číslo TCP portu, na kterém bude server poslouchat. Naši aplikaci můžeme spustit např. příkazem

```sh
node kapitola-12.js
```

Protože v aplikaci nevypisujeme na obrazovku serveru žádné informace, budeme muset její spuštění a běh sledovat jinak. Připomeňme, že naše aplikace je navržená specificky pro příjem HTTP požadavků POST, které mají v těle JSON s klíčem `username`. Pro ověření tedy můžeme použít například nástroj `curl`:

```sh
curl -v --data '{"username":"test"}' http://localhost:8000
```

Pokud je vše správně, dostaneme odpověď s kódem 200 (OK) a v souboru `accounts.json` se objeví nový záznam.


### Co jsme se naučili

Po vyřešení jedenácté úlohy by měl čtenář chápat a ovládat:

  - spuštění JS aplikace pomocí Node.js
  - import funkcionality ze standardních knihoven Node.js
  - koncepty obsluhy HTTP požadavků


## Zelenáči: npm

## Koumáci: tooling

## Profíci: alternativy k Node.js

node
	npm
	bundling, testovani
	deno? bun?


