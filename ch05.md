# Kapitola 5: HTTP na pozadí

## Zadání

Pro hudební fanoušky nyní chystáme webovou službu, ve které budou moci sdílet své kulturní zážitky. Bude přístupná jen registrovaným uživatelům, kterých očekáváme velké množství. Při registraci si vyberou uživatelské jméno a heslo; těmito údaji se budou následně přihlašovat. S ohledem ná plánovaný zájem je nutné uživatele v průběhu procesu registrace zavčasu varovat, pokud je jimi zvolené uživatelské jméno již zabráno někým jiným. Za tímto účelem jsme nechali vytvořit **backendové JSON HTTP API**, které je nutno využít.

## Řešení

U této úlohy si napřed musíme ujasnit, co se po nás vlastně chce. V textu zadání se objevuje řada zkratek a méně zkušený čtenář by se mohl zaleknout. Naštěstí nejde o nic složitého.

Podstatou úlohy je opět kontrola formuláře. Tentokrát ale není možné jen pomocí JavaScriptu rozhodnout, zdali je požadované uživatelské jméno dostupné. K tomu bychom museli v rámci webové stránky znát veškerá zaregistrovaná jména, což určitě nechceme (dle slov zadání jich bude veliké množství) ani nemůžeme (tím bychom je prozradili každému kolemjdoucímu). Proto nezbývá, než testované uživatelské jméno poslat po síti na server, který má k dispozici databázi uživatelů a o existenci může rozhodnout. Co víc, pokud bude jméno zabrané, dokáže vyprodukovat dostupnou alternativu.

Komunikace po síti je ve světě webových stránek v 99 % případů realizována protokolem HTTP. Se serverovou stranou tedy budeme komunikovat tímto způsobem; v zadání se dále píše, že data dostaneme ve formátu JSON. To je jednoduchý, užitečný a poměrně praktický způsob, jak zapsat libovolně komplexní data tak, aby se snadno zpracovávala v JavaScriptu (resp. dnes už víceméně v libovolném dalším jazyce). Poslední použitá zkratka je API -- anglicky Application Programming Interface. Tím se myslí, že existuje dohoda o tom, jak mají vypadat data přenášená od klienta na server a stejně tak jak má vypadat odpověď od serveru. Při opravdovém programování bychom se na konrétní tvar API šli zeptat backendového programátora (případně si jej přečetli v dokumentaci, nebo jej dokonce sami navrhli). V této testovací úloze budiž naše API takovéto:

1. data odesílaná na server budou realizována požadavkem na URL `/username-check?username=...`
1. pokud je uživatelské jméno volné k registraci, server odpoví daty ve formátu JSON:
	```json
	{
		"available": true
	}
	```
1. pokud je uživatelské jméno zabrané, server odpoví daty ve formátu JSON:
	```json
	{
		"available": true,
		"suggested": "navrzene-jmeno"
	}
	```

S takto upřesněným zadáním se již můžeme podívat, jak lze danou úlohu vzorově vyřešit.


```html
<form>
	<h3>Registrujte se!</h3>
	<label>
		Uživatelské jméno: <input type="text" name="username" />
	</label>
	<label>
		Heslo: <input type="password" name="password" />
	</label>
	<label>
		<input type="submit" value="Vytvořit účet" />
	</label>
</form>
```

```js
function getError() {
	return username.labels[0].querySelector(".error");
}

function hideError() {
	let error = getError();
	if (error) { error.remove(); }
}

function showError(suggested) {
	hideError();
	let error = document.createElement("div");
	error.className = "error";
	error.textContent = `Jméno je již zabráno, zkuste třeba "${suggested}"`;
	username.labels[0].append(error);
}

function onLoad(e) {
	let data = e.target.response;
	if (data.available) {
		hideError();
	} else {
		showError(data.suggested);
	}
}

function checkUsername() {
	let xhr = new XMLHttpRequest();
	let u = encodeURIComponent(username.value);
	let url = `/check-username?username=${u}`;
	xhr.responseType = "json";
	xhr.open("GET", url);
	xhr.send();
	xhr.addEventListener("load", onLoad);
}

let username = form.querySelector("[name=username]");
username.addEventListener("blur", checkUsername);
```

V tomto řešení jsme použili větší množství funkcí. Pro snazší pochopení se na ně podíváme odspodu, protože v takovém pořadí budou volány.

Na konci máme přidání posluchače události `blur` (seznámili jsme se s ní v minulé podkapitole pro zelenáče), profíci by zde možná použili kontrolu během psaní pomocí události `input`. Staráme se jen o pole `username`, zbytek HTML formuláře je uveden jen pro úplnost.

Funkce `checkUsername` představuje první část kontroly. Potřebujeme v ní vykonat HTTP požadavek. V klientském JavaScriptu jsou za tímto účelem dostupné dvě funkce: starší `XMLHttpRequest` (často zkracována na `XHR`) a novější `fetch`. My si zatím předvedeme XHR, na fetch narazíme později v kapitole FIXME. Nenecháme se zastrašit dlouhým názvem s pochybnou velikostí písmen; tento objekt pochází z doby, kdy se po síti data často přenášela ve formátu XML. To dnes tolik neplatí a `XMLHttpRequest` rádi použijeme na přenos dat jiných (napr. ve formátu JSON).

Proměnná `xhr` zastřešuje naplánovaný HTTP požadavek. Nejprve mu musíme v souladu s použitým API nastavit adresu. Její součástí je hodnota z formulářového pole (proč? protože musíme serveru sdělit, jaké že jméno se uživatel pokouší zaregistrovat). K sestavení výsledného URL jsme použili dva triky:

1. Funkce `encodeURIComponent` upraví zadaný řetězec tak, aby bylo bezpečné jej použít jako hodnotu v *URL query stringu*, tj. v části webové adresy za otazníkem. Data v tomto prostoru používají speciální syntaxi postavenou mj. na znacích `=` a `&`. Pokud by se takové znaky náhodou nacházely v `username.value`, rozbilo by to strukturu výsledné adresy. Proto tyto problémové znaky nejprve pomocí `encodeURIComponent` převedeme na jejich bezpečnější zápis.
1. Proměnnou `url` definujeme jako řetězec ohraničený dvojicí *zpětných apostrofů* (anglicky *backtick*). Jedná se o méně obvyklý znak, který se na anglické klávesnici nachází nalevo od jedničky. Tyto řetězce mají v JavaScriptu speciální funkcionalitu: pokud se v nich objeví znak dolaru a složené závorky, je tato posloupnost nahrazena hodnotou uvnitř závorek. Jedná se o ideální způsob, jak kombinovat více řetězců, nebo doplňovat proměnné hodnoty na místa v pevně definovaných šablonách.

Jakmile máme nachystáno cílové URL, dokončíme konfiguraci proměnné `xhr` v těchto krocích:

- Vlastnost `responseType` říká, v jakém datovém typu očekáváme odpověď od serveru. Výchozí hodnota `"text"` je vhodná pro přenos textových dat; náš backend vrací data strukturovaná pomocí JSON. Pokud budou data skutečně v tomto formátu, XMLHttpRequest je rovnou převede na JavaScriptový slovník.
- Metoda `open` určuje použitou HTTP metodu a cílové URL.
- Metoda `send` slouží především k předání dat, která potřebujeme na server odeslat v těle požadavku. My žádná taková nemáme (pro metodu `GET` ani mít nemůžeme), neboť poptávané uživatelské jméno předáme již v URL.
- Objekt XMLHttpRequest generuje DOM události, takže přidáme posluchač na `load`. To je událost, která vznikne, jakmile server vrátí námi vyžádaná data.

V tomto místě je dobré na chvíli pozastavit a všimnout si, že vykonání HTTP požadavku je *asynchronní operace*. Takto označujeme funkcionalitu, která je vykonávána *na pozadí*, tedy paralelně s JavaScriptovým kódem, který po ní následuje. Zkušenější programátor by možná očekával, že metoda `xhr.send()` bude *synchronní* (někdy též *blokující*), tj. že prohlížeč během jejího vykonávání provede zmíněný HTTP požadavek a teprve po jeho dokončení se bude pokračovat. Jenže to by mohlo trvat velmi dlouho a došlo by tak k pozastavení našeho kódu, který by kvuli čekání na HTTP požadavek nemohl dělat nic dalšího. Proto je objekt XMLHttpRequest asynchronní. Tato jeho vlastnost dokonce vedla ke vzniku hovorového označení **Ajax**, které bylo kdysi módní používat právě pro tento způsob přenosu dat (Ajax = Asynchronous JavaScript and XML).

Následující, resp. předchozí funkce `onLoad` je tedy posluchač události a jako taková dostává parametr s objektem události. To je pro nás dobrý způsob, jak se v ní dostat k proměnné `xhr` (připomeňme, že `e.target` je objekt, který událost vyvolal). Vlastnost `response` pak odpovídá datům, která poslal server. Pokud se cestou nic nepokazilo, bude to slovník odpovídající vzorovým datům z úvodu kapitoly. O dalším chování pak rozhodneme podle jeho vlastnosti `available`.

Když už máme data ze serveru, chceme na jejich základě uživatele informovat o (ne)dostupnosti uživatelského jména. Za tímto účelem zobrazíme pod formulářovým polem varovnou hlášku, pokud je jméno zabráno. Musíme si dát ale pozor na situaci, kdy tato kontrola probíhá opakovaně a tak je možné, že tato hláška už ve formuláři je. Vlastně mohou nastat celkem čtyři situace:

1. Žádnou hlášku nezobrazujeme a podle odpovědi serveru ani nemusíme: v takovém případě neděláme nic.
1. Žádnou hlášku nezobrazujeme, ale podle odpovědi serveru bychom nově měli: bude nutné ji vyrobit a zobrazit.
1. Hláška už je zobrazena, ale uživatel změnil jméno a to nové už je v pořádku: starou hlášku budeme muset skrýt.
1. Hláška už je zobrazena a ze serveru přišla opět instrukce k jejímu ukázání: budeme muset vyrobit novou hlášku s novým textem a tu starou s ní nahradit.

Vzorové řešení má pro tyto případy funkce `hideError` a `showError`, které voláme dle získaných instrukcí. Obě jsou připraveny na situaci, že už chybový text zobrazujeme: pokud nějaký naleznou, tak jej nejprve odstraní. K nalezení se hodí poslední pomocná mini-funkce `getError`, v jejíž implementaci se můžeme setkat s další drobnou novinkou z rozhraní DOM. Jedná se o vlastnost `labels`, která je dostupná u všech formulářových prvků a odpovídá poli HTML značek `<label>`, které jsou s daným prvkem spárovány v roli popisku.

## Co jsme se naučili

Po vyřešení čtvrté úlohy by měl čtenář chápat a ovládat:

  - koncept komunikace se serverem pomocí HTTP JSON API
  - práci s asynchronním objektem `XMLHttpRequest`
  - vlastnost `labels` u formulářových polí

## Zelenáči: řízení toku kódu pomocí operátorů

V našich funkcích se často rozhoduje o chování programu na základě hodnot, uložených v proměnných. Typickým představitelem takového rozhodování je klíčové slovo `if`, resp. konstrukce `if (podmínka) { ... } else { ... }`. Využijme tuto podkapitolu, abychom si ukázali další možnosti, jak realizovat podmínky a větvení kódu.

Budeme k tomu potřebovat *operátory*. Jsou to syntaktické prvky, zpravidla tvořeny jedním či dvěma speciálními znaky, které slouží především k provedení nějaké operace s jednou či více veličinami. Dobrým příkladem je operátor `+` (sčítání či řetězení), se kterým se setkáváme od základní školy. Operátory dělíme do skupin podle toho, s kolika hodnotami (říkáme jim *operandy*) pracují. Unární operátory (např. `!`) mají jen jeden operand, binární dva, ternární operátor potřebuje operandy tři.

A právě ternární operátor (znaky `?` a `:`) nás nyní zajímá. Jeho tradiční použití vypadá takto:

```js
let mince = Math.random();
let text = (mince < 0.5 ? "panna" : "orel");
```

Funkce `Math.random()` vrátí náhodnou hodnotu mezi nulou a jedničkou. Ternární operátor na druhém řádku jsme pro zvýšení čitelnosti vložili do kulatých závorek, ale není to nutné. Jeho první operand -- výraz před otazníkem -- je testovaná podmínka. Pokud platí, ternární operátor vrátí svůj druhý operand, zapsaný mezi otazníkem a dvojtečkou. V opačném případě vrátí třetí operand (uvedený za dvojtečkou).

A zde je vlastnost, která se nám může hodit: jako druhý a třetí operand nemusíme použít jen prostou hodnotu, ale libovolně složitý JavaScriptový výraz. Hodnota celého ternárního operátoru pak bude podle podmínky vybrána jako hodnota prvního či druhého výrazu. Pojďme zkusit použít ternární operátor jako alternativu `if` v rámci funkce `onLoad`. Její stávající tvar je tento:

```js
function onLoad(e) {
	let data = e.target.response;
	if (data.available) {
		hideError();
	} else {
		showError(data.suggested);
	}
}
```

Použitím ternárního operátoru se kód zkrátí:

```js
function onLoad(e) {
	let data = e.target.response;
	data.available ? hideError() : showError(data.suggested);
}
```

Za zmínku stojí, že návratová hodnota ternárního operátoru je v tuto chvíli nepodstatná. Abychom ještě více rozšířili svůj programátorský arzenál, prozkoumáme ještě dva další -- tentokrát binární -- operátory.


## Koumáci: falsy values a operátor porovnání

## Profíci: *same-origin policy* a CORS

