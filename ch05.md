# Kapitola 5: HTTP na pozadí

## Zadání

Pro hudební fanoušky nyní chystáme webovou službu, ve které budou moci sdílet své kulturní zážitky. Bude přístupná jen registrovaným uživatelům, kterých očekáváme velké množství. Při registraci si vyberou uživatelské jméno a heslo; těmito údaji se budou následně přihlašovat. S ohledem ná plánovaný zájem je nutné uživatele v průběhu procesu registrace zavčasu varovat, pokud je jimi zvolené uživatelské jméno již zabráno někým jiným. Za tímto účelem jsme nechali vytvořit **backendové JSON HTTP API**, které je nutno využít.

## Řešení

U této úlohy si napřed musíme ujasnit, co se po nás vlastně chce. V textu zadání se objevuje řada zkratek a méně zkušený čtenář by se mohl zaleknout. Naštěstí nejde o nic složitého.

Podstatou úlohy je opět kontrola formuláře. Tentokrát ale není možné jen pomocí JavaScriptu rozhodnout, zdali je požadované uživatelské jméno dostupné. K tomu bychom museli v rámci webové stránky znát veškerá zaregistrovaná jména, což určitě nechceme (dle slov zadání jich bude veliké množství) ani nemůžeme (tím bychom je prozradili každému kolemjdoucímu). Proto nezbývá, než testované uživatelské jméno poslat po síti na server, který má k dispozici databázi uživatelů a o existenci může rozhodnout. Co víc, pokud bude jméno zabrané, dokáže vyprodukovat dostupnou alternativu.

Komunikace po síti je ve světě webových stránek v 99 % případů realizována protokolem HTTP. Se serverovou stranou tedy budeme komunikovat tímto způsobem; v zadání se dále píše, že data dostaneme ve formátu JSON. To je jednoduchý, užitečný a poměrně praktický způsob, jak zapsat libovolně komplexní data tak, aby se snadno zpracovávala v JavaScriptu (resp. dnes už víceméně v libovolném dalším jazyce). Poslední použitá zkratka je API -- anglicky Application Programming Interface. Tím se myslí, že existuje dohoda o tom, jak mají vypadat data přenášená od klienta na server a stejně tak jak má vypadat odpověď od serveru. Při opravdovém programování bychom se na konrétní tvar API šli zeptat backendového programátora (případně si jej přečetli v dokumentaci, nebo jej dokonce sami navrhli). V této testovací úloze budiž naše API takovéto:

1. data odesílaná na server budou realizována požadavkem na URL `/username-check?username=...`
1. pokud je uživatelské jméno volné k registraci, server odpoví daty ve formátu JSON:
	```json
	{
		"available": true
	}
	```
1. pokud je uživatelské jméno zabrané, server odpoví daty ve formátu JSON:
	```json
	{
		"available": true,
		"suggested": "navrzene-jmeno"
	}
	```

S takto upřesněným zadáním se již můžeme podívat, jak lze danou úlohu vzorově vyřešit.


```html
<form>
	<h3>Registrujte se!</h3>
	<label>
		Uživatelské jméno: <input type="text" name="username" />
	</label>
	<label>
		Heslo: <input type="password" name="password" />
	</label>
	<label>
		<input type="submit" value="Vytvořit účet" />
	</label>
</form>
```

```js
function getError() {
	return username.labels[0].querySelector(".error");
}

function hideError() {
	let error = getError();
	if (error) { error.remove(); }
}

function showError(suggested) {
	hideError();
	let error = document.createElement("div");
	error.className = "error";
	error.textContent = `Jméno je již zabráno, zkuste třeba ${suggested}`;
	username.labels[0].append(error);
}

function onLoad(e) {
	let data = e.target.response;
	if (data.available) {
		hideError();
	} else {
		showError(data.suggested);
	}
}

function checkUsername() {
	let xhr = new XMLHttpRequest();
	let u = encodeURIComponent(username.value);
	let url = `/check-username?username=${u}`;
	xhr.responseType = "json";
	xhr.open("GET", url);
	xhr.send();
	xhr.addEventListener("load", onLoad);
}

let username = form.querySelector("[name=username]");
username.addEventListener("blur", checkUsername);
```

V tomto řešení jsme použili větší množství funkcí. Pro snazší pochopení se na ně podíváme odspodu, protože v takovém pořadí budou volány.

Na konci máme přidání posluchače události `blur` (seznámili jsme se s ní v minulé podkapitole pro zelenáče), profíci by zde možná použili kontrolu během psaní pomocí události `input`. Staráme se jen o pole `username`, zbytek HTML formuláře je uveden jen pro úplnost.

Funkce `checkUsername` představuje první část kontroly. Potřebujeme v ní vykonat HTTP požadavek. V klientském JavaScriptu jsou za tímto účelem dostupné dvě funkce: starší `XMLHttpRequest` (často zkracována na `XHR`) a novější `fetch`. My si zatím předvedeme XHR, na fetch narazíme později v kapitole FIXME. Nenecháme se zastrašit dlouhým názvem s pochybnou velikostí písmen; tento objekt pochází z doby, kdy se po síti data často přenášela ve formátu XML. To dnes tolik neplatí a `XMLHttpRequest` rádi použijeme na přenos dat jiných (napr. ve formátu JSON).

Proměnná `xhr` zastřešuje naplánovaný HTTP požadavek. Nejprve mu musíme v souladu s použitým API nastavit adresu. Její součástí je hodnota z formulářového pole (proč? protože musíme serveru sdělit, jaké že jméno se uživatel pokouší zaregistrovat). K sestavení výsledného URL jsme použili dva triky:

1. Funkce `encodeURIComponent` upraví zadaný řetězec tak, aby bylo bezpečné jej použít jako hodnotu v *URL query stringu*, tj. v části webové adresy za otazníkem. Data v tomto prostoru používají speciální syntaxi postavenou mj. na znacích `=` a `&`. Pokud by se takové znaky náhodou nacházely v `username.value`, rozbilo by to strukturu výsledné adresy. Proto tyto problémové znaky nejprve pomocí `encodeURIComponent` převedeme na jejich bezpečnější zápis.
1. Proměnnou `url` definujeme jako řetězec ohraničený dvojicí *zpětných apostrofů* (anglicky *backtick*). Jedná se o méně obvyklý znak, který se na anglické klávesnici nachází nalevo od jedničky. Tyto řetězce mají v JavaScriptu speciální funkcionalitu: pokud se v nich objeví znak dolaru a složené závorky, je tato posloupnost nahrazena hodnotou uvnitř závorek. Jedná se o ideální způsob, jak kombinovat více řetězců, nebo doplňovat proměnné hodnoty na místa v pevně definovaných šablonách.


## Co jsme se naučili

## Zelenáči: alternativní řízení toku kódu

## Koumáci: falsy values

## Profíci: *same-origin policy* a CORS

