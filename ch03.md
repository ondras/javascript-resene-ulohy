# Kapitola 3: Pole a iterace

## Zadání

Kód z předchozí kapitoly se osvědčil! Rádi bychom jej nyní použili i na další stránce, kde bude naráz vypsáno několik písní. Zkrácení (a zobrazení pomocí tlačítka) je proto nutné provést na všech textech písní, které se v dokumentu objeví.

## Řešení

V souboru `songs.html`:

```html
<h2>Mám styl Čendy</h2>
<pre class="song"> ... </pre>

<h2>Hříšné bolero</h2>
<pre class="song"> ... </pre>

<script src="songs.js"></script>
```

V souboru `songs.js`:

```js
const LIMIT = 50;

function shortenSong(song) {
	let text = song.textContent;

	let button = document.createElement("button");
	button.textContent = "zobrazit celý text";
	song.replaceChildren(text.substring(0, LIMIT), "…", button);

	function showCompleteText() {
		song.textContent = text;
	}
	button.addEventListener("click", showCompleteText);
}

let songs = document.querySelectorAll(".song");
for (let i=0; i<songs.length; i++) {
	shortenSong(songs[i]);
}
```

Po zbytek knihy už budeme vždy uvažovat JavaScriptový kód oddělený od HTML. Trochu se tím komplikuje možnost přímočaře si uvedená řešení vyzkoušet, ale zase se jedná o přístup, který v praxi vídáme nejčastěji.

Výše uvedené řešení je motivováno přímočarou úvahou: chceme vzít hotový kód (z minulé kapitoly) a aplikovat jej opakovaně. Dopředu není jisté, kolikrát to bude, protože náš výsledek by měl fungovat u stránky se dvěma písněmi, stejně jako když jich tam bude padesát. V takovém případě je logické sáhnout po nějaké formě *cyklu*. JavaScript nabízí různé formy iterace (více o tom v podkapitole pro zelenáče) a my můžeme použít hned tu nejsnazší &ndash; pomocí syntaxe `for` s iterační proměnnou. Tento zápis je známý z mnoha jiných programovacích jazyků. Používáme v něm tzv. *iterační proměnnou* (zde `i`), kterou nejprve nastavíme na nulu a následně v každé iteraci zvýšíme o jedničku (operátor `++`). To děláme tak dlouho, dokud je hodnota této proměnné menší, než zadaný limit.

Naše data jsou v proměnné `songs`, pro jejíž naplnění jsme zvolili metodu `document.querySelectorAll`. Jedná se o hodnotu typu *statický NodeList*, tedy něco jako *posloupnost HTML uzlů*. V mnoha ohledech bychom takovou proměnnou mohli považovat za pole (datový typ zpravidla užívaný pro řady hodnot), ale pozor &ndash; JavaScriptové pole to není. Nelze proto použít např. funkcionální iteraci (viz dále). Nám ovšem stačí, když:

  1. umíme ověřit, kolik má `songs` hodnot (pomocí vlastnosti `length`),
  1. dokážeme získat konkrétní N-tou položku z této posloupnosti (pomocí operátoru hranatých závorek)

Pro potřeby této ukázky kódu jsme použili selektor `.song`, kterému vyhovují všechny HTML prvky, jejichž atribut `class` obsahuje slovo `song`. To rozhodně není jediný způsob, jak v dokumentu písně nalézt. Je to předmětem dohody mezi autorem HTML a autorem skriptu; ve stránce musí být písně zapsány takovým způsobem, aby je pak v JavaScriptu šlo všechny *najít*. Kdybychom použili například selektor `pre`, je možné, že by kód fungoval stejně dobře. Trochu bychom se tím ale vystavili riziku, že do HTML stránky někdo následně vloží značku `<pre>`, která ovšem vůbec nebude použitá k výpisu textu písně. I takovou bychom pak považovali za píseň a pokoušeli se její obsah zkrátit. Proto bude šikovnější v HTML explicitně označit (atributem `class`) jen ta správná místa, co si zaslouží zpracovat.

V každé iteraci nakonec zavoláme funkci `shortenSong`, která je jen obalem kolem kódu z minulé kapitoly. Její zodpovědností je zkrácení textu konkrétní písně a tvorba interaktivního tlačítka.


## Co jsme se naučili

Po vyřešení druhé úlohy by měl čtenář chápat a ovládat:

  - spolupráci mezi HTML a JS pomocí `querySelector` a `querySelectorAll`
  - zápis iterace s pomocnou proměnnou
  - definice arrow funkce FIXME
  - definice funkce uvnitř funkce FIXME


## Zelenáči: druhy iterací

Cyklus `for` s iterační proměnnou je jen jedna z celé řady možností, jak v JavaScriptu opakovaně vykonávat potřebnou logiku. Jeho charakteristickým rysem je, že pro jeho konstrukci vůbec nepotřebujeme žádný pokročilejší datový typ. Kdybychom například chtěli vypsat prvních deset čísel, mohli bychom:

```js
for (let i=1; i<=10; i++) {
	console.log(i);
}
```

Tuto vlastnost obsahuje také druhý elementární cyklus `while`:

```js
let i=1;
while (i <= 10) {
	console.log(i);
}
```

V obou případech stačí jedna číselná proměnná, nemusíme mít žádné pole ani jinou datovou strukturu. Jakmile máme zpracovávaná data uložená v nějaké složitější proměnné, můžeme uvažovat pokročilejší syntaxi pro iteraci. Další v řadě je cyklus `for-in`:

```js
let data = {
	name: "Jan",
	age: 42
}

for (let p in data) {
	console.log(p);       // "name", "age"
	console.log(data[p])  // "Jan", 42
}
```

Pomocná proměnná `p` nabývá postupně hodnot všech *klíčů* v iterovaném objektu. Pro použití této syntaxe proto potřebujeme cokoliv, co odpovídá JavaScriptové definici *objektu*. Zde se trochu rozcházíme s terminologií objektově-orientovaného programování, kde slovo *objekt* značí *instanci třídy*. V JavaScriptu se objektem nazývá každý datový typ, který má *klíče* a jim odpovídající *hodnoty*. Spadají sem pole, funkce, množiny, třídy i jejich instance. Zejména se nám pak cyklus `for-in` hodí u proměnné `data` z této ukázky; její datový typ se formálně nazývá *objekt ex nihilo*, ale mnohem častěji mu říkáme *slovník* nebo *záznam*.

Ve slovníku ukládáme data jako dvojice klíč-hodnota, kde klíč je vždy řetězec (i když kolem něj zpravidla nemusíme psát uvozovky) a hodnota je libovolná. O slovnících a jejich schopnostech si více povíme v kapitole FIXME.

Protože JS pole je také objekt, nabízí se možnost iterovat proměnnou typu pole také pomocí syntaxe `for-in`. Jeho klíče by pak byly jednotlivé číselné indexy (hodnoty 0, 1, 2, ...). Takový postup ovšem nemůžeme vždy doporučit, protože v poli by se mohly objevit i další klíče, které naše iterace neočekává (viz kapitola FIXME). Pokud jsou naše data uložena v opravdovém poli, je o něco lepší variantou *funkcionální iterace*:

```js
let todo = ["nakoupit", "zamést", "zpívat"];

function show(task) {
	console.log("Je pořeba", task);
}

todo.forEach(show);

```




## Koumáci: scope a closure

## Profíci: delegování událostí
