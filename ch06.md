# Kapitola 6: Cesta k SPA, riziko XSS

## Zad치n칤

Na na코em webu, kter칳 fanou코k콢m poskytuje texty p칤sn칤 Karla Gotta, nab칤z칤me funkci *hled치n칤*: u쬴vatel zad치 do formul치콏ov칠ho pole hledan칳 text a my mu po odesl치n칤 na nov칠 str치nce zobraz칤me v코echny souvisej칤c칤 p칤sn캩. R치di bychom sou캜asn칠 콏e코en칤 upravili na modern캩j코칤 SPA (single-page application), kdy p콏i zobrazen칤 v칳sledk콢 nedoch치z칤 k na캜ten칤 nov칠 str치nky. Backend bude data op캩t nab칤zet formou HTTP JSON API.

## 콎e코en칤

Stejn캩 jako v minul칠 kapitole, i zde budeme pracovat s daty z칤skan칳mi z backendu. Komunikace m콢쬰 vypadat t콏eba takto:

  - data odes칤lan치 na server budou realizov치na po쬬davkem na URL `/search?query=...`
  - server odpov칤 daty ve form치tu JSON a bude to pole; jeho jednotliv칠 polo쬶y budou vypadat takto:
	```json
	{
		"title": "M치m styl 캛endy",
		"text": "Mezi n치mi je <em>mnoho</em> chvil",
		"url": "..."  // odkaz na cel칳 text p칤sn캩
	}
	```

Pod kl칤캜em *text* je ulo쬰na 캜치st textu p칤sn캩, d칤ky kter칠 se p칤se켿 dostala do v칳sledk콢. Konkr칠tn캩 server zna캜kou `<em>` ozna캜칤 tu 캜치st textu, kter치 odpov칤d치 hledan칠mu term칤nu.

Mimochodem: je nezbytn칠, aby to d캩lal server, kdy i klient zn치 hledan칳 term칤n a mohl by jej v textu naj칤t a ozna캜it? Ano, v naprost칠 v캩t코in캩 p콏칤pad콢 je zodpov캩dnost칤 serveru, aby data takto p콏ipravil. Jen on toti v칤, pro캜 se p칤se켿 dostala do v칳sledk콢; mo쬹치 쬰 je v n칤 hledan칳 term칤n v jin칠m p치du, bez diakritiky nebo s jinou velikost칤 p칤smen.

Vzorov칠 콏e코en칤 pak m콢쬰 vypadat takto:

```html
<h1>Hled치n칤</h1>
<form>
	<label>
		Hledan칳 v칳raz: <input type="text" name="query" />
	</label>
	<label>
		<button>游댍</button>
	</label>
</form>

<section id="results"></section>
```

```js
let form = document.querySelector("form");
let results = document.querySelector("#results");

function buildSong(song) {
	let item = document.createElement("li");
	item.innerHTML = `<a href="${song.url}">${song.title}</a> <br/> ${song.text}`;
	return item;
}

function showResults(xhr, query) {
	let songs = xhr.response;
	if (songs.length == 0) {
		results.replaceChildren("Tomuto dotazu nevyhovuj칤 쮂멳n칠 p칤sn캩 游뗴");
		return;
	}

	let heading = document.createElement("h2");
	heading.textContent = `Nalezen칠 p칤sn캩 pro dotaz: ${query}`;

	let ul = document.createElement("ul");
	results.replaceChildren(heading, ul);

	for (let i=0; i<songs.length; i++) {
		let song = buildSong(songs[i]);
		ul.append(song);
	}
}

function onSubmit(e) {
	e.preventDefault();
	let xhr = new XMLHttpRequest();
	let query = form.querySelector("[name=query]").value;
	let url = `/search?query=${encodeURIComponent(query)}`;
	xhr.responseType = "json";
	xhr.open("GET", url);
	xhr.send();
	xhr.addEventListener("load", e => showResults(xhr, query));
}

form.addEventListener("submit", onSubmit);
```

K칩d neobsahuje 쮂멳n칠 velk칠 novinky. Jedn치 se o kombinaci minul칳ch dvou kapitol (pou쬴t칤 `XMLHttpRequest` a ud치losti `submit`). Za zm칤nku stoj칤:

- Ve formul치콏i jsme pou쬴li HTML prvek `<button>`, kter칳 ve v칳choz칤m nastaven칤 t칠 funguje jako odes칤lac칤 tla캜칤tko.
- V r치mci poslucha캜e `onSubmit` v쬯y vol치me `e.preventDefault()`, abychom tak zamezili odesl치n칤. V kontextu t칠to 칰lohy to neznamen치 chybu u쬴vatele, ale snahu z콢stat na stejn칠 str치nce a po쬬dovanou funkcionalitu n치sledn캩 vykonat pomoc칤 JavaScriptu.
- Data z hledac칤ho pole p콏ed vlo쬰n칤m do URL op캩t upravujeme funkc칤 `encodeURIComponent`, pro p콏칤pad, 쬰 by obsahovala znaky, kter칠 do URL nepat콏칤.
- Poslucha캜 ud치losti `load` je mal치 anonymn칤 arrow funkce, kter치 uzav칤r치 prom캩nn칠 `xhr` a `query`. D칤ky tomu m콢쬰me do `showResults` p콏edat libovoln칠 parametry.

V HTML dokumentu jsme si nachystali pr치zdn칳 prvek `<section id="results"></section>`, jeho obsah n치sledn캩 pln칤me na z치klad캩 dat ze serveru. To je velmi 캜ast칳 postup: v HTML p콏iprav칤me jen kostru 캜i 코ablonu v칳sledn칠 str치nky, JavaScriptem do n칤 pozd캩ji dod치me pot콏ebn칠 informace. V t캩chto p콏칤padech je dobr칠 nezapomenout na dva sc칠n치콏e:

1. Co u쬴vatel vid칤, dokud se 캜ek치 na odpov캩캞 od serveru? Jestli to je n캩jak치 ne칰pln치 HTML struktura, m캩la by b칳t skryta. V na코em p콏칤pad캩 nevid칤 nic.
1. Co u쬴vatel vid칤, pokud se pr치zdn칳 prostor ve str치nce pln칤 opakovan캩? P콏i ka쬯칠m hled치n칤 je nutn칠 obsah prvku `#results` nahradit. Nam칤sto p콏id치v치n칤 nov칳ch uzl콢 proto pou쮂셨치me `results.replaceChildren()`.

V t칠to kapitole se poj캞me pod칤vat pozorn캩ji na funkci `buildSong`, kter치 slou쮂 k v칳rob캩 HTML prvku odpov칤daj칤c칤ho jednomu v칳sledku hled치n칤. Poprv칠 se v n칤 setk치v치me s vlastnost칤 `innerHTML`, kter치 pat콏칤 mezi nejsiln캩j코칤 sou캜치sti rozhran칤 DOM. Kdy n캩jak칠mu HTML prvku p콏i콏azujeme do vlastnosti `innerHTML`, 콏칤k치me t칤m, 쬰 prohl칤쬰코 m치 cel칳 obsah (potomky) tohoto prvku nahradit nov칳m podstromem, kter칳 vznikne parsov치n칤m zadan칠ho 콏et캩zce. Je to skoro stejn칠, jako kdy nech치v치me prohl칤쬰캜 sestavit strom dokumentu p콏i prvn칤m na캜ten칤 str치nky.

Jedn치 se o velmi pohodln칳 zp콢sob tvorby slo쬴t캩j코칤 komponenty webov칠 str치nky. Porovnejme, o kolik by bylo zdlouhav캩j코칤 v칳sledek hled치n칤 vyrobit a sestavit pomoc칤 n캩kolika `createElement` a `append`. Z치rove켿 je pro n치s 콏e코en칤 pomoc칤 `innerHTML` nezbytn칠, proto쬰 od serveru ji dost치v치me mal칠 캜치sti HTML -- vlastnost `text` s 칰ryvkem textu p칤sn캩 obsahuje zna캜ku pro zv칳razn캩n칤.

I p콏es nezpochybniteln칠 pohodl칤 vlasnosti `innerHTML` si ale mus칤me d치t velk칳 pozor na jej칤 pou쬴t칤. Jedn치 se toti bohu쬰l o 캜ast칳 vstupn칤 bod pro zranitelnost typu XSS (*cross-site scripting*). Abychom l칠pe pochopili, o캜 jde, m콢쬰me se pod칤vat hned o p치r 콏치dk콢 vedle, do funkce `showResults`. Tam se vyr치b칤 nadpis pro v칳sledky:

```js
let heading = document.createElement("h2");
heading.textContent = `Nalezen칠 p칤sn캩 pro dotaz: ${query}`;
```

Tentokr치t se nam칤sto `innerHTML` pou쮂셨치 `textContent`, kter칳 takt칠 nahrad칤 dan칠mu uzlu obsah, ale prost칳m textem. Zadan칳 콏et캩zec nen칤 parsov치n jako HTML, tj. p콏칤padn칠 HTML zna캜ky v n캩m obsa쬰n칠 se zobraz칤 jen jako text. A je to tak spr치vn캩, nebo콘 p콏i pou쬴t칤 `innerHTML` by pak mohl z치ludn칳 u쬴vatel do hledac칤ho pole napsat nap콏칤klad:

```
<img src="...">
```

N치코 k칩d by pak v nadpisu nam칤sto zadan칠ho 콏et캩zce uk치zal obr치zek. A to je velk치 chyba, nebo콘 u쬴vatel sv칳m vstupem dok치zal **pozm캩nit strukturu dokumentu**. Od toho je pak u jen kr콢캜ek k tomu, aby t칤mto zp콢sobem mohl vlo쬴t vlastn칤 skript. Jak p콏esn캩 by toho doc칤lil a jak칠 nebezpe캜칤 by z toho mohlo plynout -- to je mimo rozsah t칠to knihy. N치m bohat캩 sta캜칤, 쬰 bychom tak nechali u쬴vatele do n치mi p콏ipraven칠ho dokumentu vkl치dat jeho zna캜ky. To je v naprost칠 v캩t코in캩 p콏칤pad콢 z치klad pro bezpe캜nostn칤 mal칠r.

Bereme si z toho velmi d콢le쬴t칠 ponau캜en칤: jakmile vytv치콏칤me HTML dokument nebo jeho 캜치st, mus칤me uva쬺vat, jak치 data v n칤 zobraz칤me. Pokud existuje mo쬹ost, 쬰 tato data nepoch치z칤 z d콢v캩ryhodn칠ho zdroje (tj. mohou obsahovat neo캜ek치van칠 HTML znaky), pracujeme defenzivn캩 a tato data vkl치d치me pomoc칤 `textContent` (nebo jako parametry do `append()`). Jen tak je zaru캜eno, 쬰 prohl칤쬰캜 zadan칳 콏et캩zec nebude pova쬺vat za HTML. A teprve kdy jsme si absolutn캩 jisti, 쬰 v zobrazovan칳ch prom캩nn칳ch jsou jen ne-HTML data, sm칤me pou쮂셦 mocnou vlastnost `innerHTML`.

Pro 칰plnost: je v칳코e uvedenou optikou bezpe캜n칠 na코e pou쬴t칤 `innerHTML` ve funkci `buildSong`? Z치le쮂 na tom, odkud se berou data ulo쬰n치 pod kl칤캜i `url`, `text` a `title`. Pokud bychom uva쬺vali variantu, 쬰 by Karel Gott do n캩jak칠ho sv칠ho textu um칤stil z치ludn칳 kousek HTML, museli bychom od serveru vy쬬dovat, aby vr치cen치 data n치le쬴t캩 zabezpe캜il (probl칠mov칠 znaky nahradil za HTML entity).


## Co jsme se nau캜ili

Po vy콏e코en칤 p치t칠 칰lohy by m캩l 캜ten치콏 ch치pat a ovl치dat:

  - podstatu zranitelnost칤 XSS
  - rozd칤l mezi vlasnostmi `textContent` a `innerHTML`

## Zelen치캜i: pr치ce s adresn칤m 콏치dkem

SPA, tedy jednostr치nkov칠 webov칠 aplikace, stav칤 na technice *nahrazov치n칤 obsahu JavaScriptem*, nam칤sto tradi캜n칤ho mechanismu *navigace* mezi v칤ce r콢zn칳mi str치nkami. V porovn치n칤 s b캩쬹캩 odes칤lan칳m formul치콏em je ale na코e sou캜asn칠 콏e코en칤 je코t캩 po콏치d trochu nemotorn칠. P콏i hled치n칤 toti nedoch치z칤 ke zm캩n캩 URL v adresn칤m 콏치dku prohl칤쬰캜e. A to je 코koda, proto쬰 tak p콏ich치z칤me o:

- mo쬹ost ulo쬰n칤 adresy s v칳sledky do z치lo쬰k,
- mo쬹ost posl치n칤 takov칠 adresy n캩komu jin칠mu,
- mo쬹ost reloadu (op캩tovn칠ho na캜ten칤) str치nky s v칳sledky,
- pohyb v historii prohl칤쬰캜e (tj. tla캜칤tko *Zp캩t*).

U쬴vatel se st치le nach치z칤 na t칠 sam칠 str치nce, tak쬰 v adresn칤m 콏치dku je st치le jen nap콏. `search.html`. P콏itom zobrazovan치 data se m캩n칤, tak쬰 by d치valo smysl, aby se m캩nilo i zobrazovan칠 URL.

콎e코en칤 nen칤 komplikovan칠, by콘 na n캩j v칳voj치콏i 캜asto a r치di zapom칤naj칤. Sest치v치 z t캩chto krok콢:

1. Po proveden칤 hled치n칤 mus칤me informaci o hledan칠m term칤nu vlo쬴t do URL v adresn칤m 콏치dku. To mj. zp콢sob칤 z치znam do historie prohl칤쬰캜e, tak쬰 pak bude mo쬹칳 n치vrat tla캜칤tkem *Zp캩t*.
1. Jakmile u쬴vatel toto tla캜칤tko pou쬴je, URL se zm캩n칤 (na p콏edchoz칤 hodnotu), ale my z콢st치v치me na stejn칠 str치nce. Mus칤me proto zobrazit obsah koresponduj칤c칤 s nov칳m URL.
1. Pokud u쬴vatel na캜te novou str치nku, v jej칤m URL bude n치mi poznamenan치 hledan치 hodnota, mus칤me prov칠st hled치n칤.

Poj캞me 캜치st vzorov칠ho 콏e코en칤 v tomto smyslu upravit a roz코칤콏it. Nejprve rozd캩l칤me *odesl치n칤 formul치콏e* a *hled치n칤* do dvou funkc칤:

```js
function search(query) {
	let xhr = new XMLHttpRequest();
	let url = `/search?query=${encodeURIComponent(query)}`;
	xhr.responseType = "json";
	xhr.open("GET", url);
	xhr.send();
	xhr.addEventListener("load", e => showResults(xhr, query));
}

function onSubmit(e) {
	e.preventDefault();
	let query = form.querySelector("[name=query]").value;
	search(query);
}
```

To odpov칤d치 pl치nu, 쬰 hled치n칤 bude vyvol치no i jin칳mi mechanismy, ne jen odesl치n칤m formul치콏e. D치le, po odesl치n칤 formul치콏e bude pot콏eba zm캩nit URL v adresn칤m 콏치dku:

```js
function onSubmit(e) {
	e.preventDefault();
	let query = form.querySelector("[name=query]").value;

	let url = new URL(location.href);
	url.searchParams.set("query", query);
	history.pushState(FIXME);

	search(query);
}
```

Zde vid칤me dv캩 novinky: objekt `URL` pro pohodlnou pr치ci s webov칳mi adresami a d치le prom캩nnou `history`, kter치 n치m mj. dovoluje m캩nit hodnotu v adresn칤m 콏치dku bez nutnosti navigace na nov칳 dokument.

T칤m jsme vy콏e코ili prvn칤 krok ze t콏칤. Pro ten druh칳 se mus칤me dozv캩d캩t o tom, 쬰 do코lo k u쬴vatelem vyvolan칠 zm캩n캩 adresn칤ho 콏치dku. K tomu slou쮂 ud치lost `popstate`:

```js
function load() {
	let url = new URL(location.href);
	let query = url.searchParams.get("query");
	query && search(query);
}
FIXME.addEventListener("popstate", e => load());
```

Jedn치 se o proces symetrick칳 k odesl치n칤 formul치콏e. Prohl칠dneme aktu치ln칤 adresu a pokud je v n칤 zaznamen치n hledan칳 text, provedeme hled치n칤.

Posledn칤 krok je jen pomysln치 t콏e코ni캜ka na dortu, proto쬰 k jeho spln캩n칤 sta캜칤 novou funkci `load` zavolat po prvn칤m na캜ten칤 str치nky. Cel칳 upraven칳 k칩d proto bude vypadat takto:

```js
function search(query) {
	let xhr = new XMLHttpRequest();
	let url = `/search?query=${encodeURIComponent(query)}`;
	xhr.responseType = "json";
	xhr.open("GET", url);
	xhr.send();
	xhr.addEventListener("load", e => showResults(xhr, query));
}

function onSubmit(e) {
	e.preventDefault();
	let query = form.querySelector("[name=query]").value;

	let url = new URL(location.href);
	url.searchParams.set("query", query);
	history.pushState(FIXME);

	search(query);
}

function load() {
	let url = new URL(location.href);
	let query = url.searchParams.get("query");
	query && search(query);
}

form.addEventListener("submit", onSubmit);
FIXME.addEventListener("popstate", e => load());

load();
```

## Koum치ci: funkcion치ln칤 iterace


## Prof칤ci: fetch, Promises a async/await
