# Kapitola 6: Cesta k SPA, riziko XSS

## ZadÃ¡nÃ­

Na naÅ¡em webu, kterÃ½ fanouÅ¡kÅ¯m poskytuje texty pÃ­snÃ­ Karla Gotta, nabÃ­zÃ­me funkci *hledÃ¡nÃ­*: uÅ¾ivatel zadÃ¡ do formulÃ¡Å™ovÃ©ho pole hledanÃ½ text a my mu po odeslÃ¡nÃ­ na novÃ© strÃ¡nce zobrazÃ­me vÅ¡echny souvisejÃ­cÃ­ pÃ­snÄ›. RÃ¡di bychom souÄasnÃ© Å™eÅ¡enÃ­ upravili na modernÄ›jÅ¡Ã­ single-page systÃ©m, kdy pÅ™i zobrazenÃ­ vÃ½sledkÅ¯ nedochÃ¡zÃ­ k naÄtenÃ­ novÃ© strÃ¡nky. Backend bude data opÄ›t nabÃ­zet formou HTTP JSON API.

## Å˜eÅ¡enÃ­

StejnÄ› jako v minulÃ© kapitole, i zde budeme pracovat s daty zÃ­skanÃ½mi z backendu. Komunikace mÅ¯Å¾e vypadat tÅ™eba takto:

  - data odesÃ­lanÃ¡ na server budou realizovÃ¡na poÅ¾adavkem na URL `/search?query=...`
  - server odpovÃ­ daty ve formÃ¡tu JSON a bude to pole; jeho jednotlivÃ© poloÅ¾ky budou vypadat takto:
	```json
	{
		"title": "MÃ¡m styl ÄŒendy",
		"text": "Mezi nÃ¡mi je <em>mnoho</em> chvil",
		"url": "..."  // odkaz na celÃ½ text pÃ­snÄ›
	}
	```

Pod klÃ­Äem *text* je uloÅ¾ena ÄÃ¡st textu pÃ­snÄ›, dÃ­ky kterÃ© se pÃ­seÅˆ dostala do vÃ½sledkÅ¯. KonkrÃ©tnÄ› server znaÄkou `<em>` oznaÄÃ­ tu ÄÃ¡st textu, kterÃ¡ odpovÃ­dÃ¡ hledanÃ©mu termÃ­nu.

Mimochodem: je nezbytnÃ©, aby to dÄ›lal server, kdyÅ¾ i klient znÃ¡ hledanÃ½ termÃ­n a mohl by jej v textu najÃ­t a oznaÄit? Ano, v naprostÃ© vÄ›tÅ¡inÄ› pÅ™Ã­padÅ¯ je zodpovÄ›dnostÃ­ serveru, aby data takto pÅ™ipravil. Jen on totiÅ¾ vÃ­, proÄ se pÃ­seÅˆ dostala do vÃ½sledkÅ¯; moÅ¾nÃ¡ Å¾e je v nÃ­ hledanÃ½ termÃ­n v jinÃ©m pÃ¡du, bez diakritiky nebo s jinou velikostÃ­ pÃ­smen.

VzorovÃ© Å™eÅ¡enÃ­ pak mÅ¯Å¾e vypadat takto:

```html
<h1>HledÃ¡nÃ­</h1>
<form>
	<label>
		HledanÃ½ vÃ½raz: <input type="text" name="query" />
	</label>
	<label>
		<button>ğŸ”</button>
	</label>
</form>

<section id="results"></section>
```

```js
let form = document.querySelector("form");
let results = document.querySelector("#results");

function buildSong(song) {
	let item = document.createElement("li");
	item.innerHTML = `<a href="${song.url}">${song.title}</a> <br/> ${song.text}`;
	return item;
}

function showResults(xhr, query) {
	let songs = xhr.response;
	if (songs.length == 0) {
		results.replaceChildren("Tomuto dotazu nevyhovujÃ­ Å¾Ã¡dnÃ© pÃ­snÄ› ğŸ™");
		return;
	}

	let heading = document.createElement("h2");
	heading.textContent = `NalezenÃ© pÃ­snÄ› pro dotaz: ${query}`;

	let ul = document.createElement("ul");
	results.replaceChildren(heading, ul);

	for (let i=0; i<songs.length; i++) {
		let song = buildSong(songs[i]);
		ul.append(song);
	}
}

function onSubmit(e) {
	e.preventDefault();
	let xhr = new XMLHttpRequest();
	let query = form.querySelector("[name=query]").value;
	let url = `/search?query=${encodeURIComponent(query)}`;
	xhr.responseType = "json";
	xhr.open("GET", url);
	xhr.send();
	xhr.addEventListener("load", e => showResults(xhr, query));
}

form.addEventListener("submit", onSubmit)
```

KÃ³d neobsahuje Å¾Ã¡dnÃ© velkÃ© novinky. JednÃ¡ se o kombinaci minulÃ½ch dvou kapitol (pouÅ¾itÃ­ `XMLHttpRequest` a udÃ¡losti `submit`). Za zmÃ­nku stojÃ­:

- Ve formulÃ¡Å™i jsme pouÅ¾ili HTML prvek `<button>`, kterÃ½ ve vÃ½chozÃ­m nastavenÃ­ tÃ©Å¾ funguje jako odesÃ­lacÃ­ tlaÄÃ­tko.
- V rÃ¡mci posluchaÄe `onSubmit` vÅ¾dy volÃ¡me `e.preventDefault()`, abychom tak zamezili odeslÃ¡nÃ­. V kontextu tÃ©to Ãºlohy to neznamenÃ¡ chybu uÅ¾ivatele, ale snahu zÅ¯stat na stejnÃ© strÃ¡nce a poÅ¾adovanou funkcionalitu nÃ¡slednÄ› vykonat pomocÃ­ JavaScriptu.
- Data z hledacÃ­ho pole pÅ™ed vloÅ¾enÃ­m do URL opÄ›t upravujeme funkcÃ­ `encodeURIComponent`, pro pÅ™Ã­pad, Å¾e by obsahovala znaky, kterÃ© do URL nepatÅ™Ã­.

V HTML dokumentu jsme si nachystali prÃ¡zdnÃ½ prvek `<section id="results"></section>`, jehoÅ¾ obsah nÃ¡slednÄ› plnÃ­me na zÃ¡kladÄ› dat ze serveru. To je velmi ÄastÃ½ postup: v HTML pÅ™ipravÃ­me jen kostru Äi Å¡ablonu vÃ½slednÃ© strÃ¡nky, JavaScriptem do nÃ­ pozdÄ›ji dodÃ¡me potÅ™ebnÃ© informace. V tÄ›chto pÅ™Ã­padech je dobrÃ© nezapomenout na dva scÃ©nÃ¡Å™e:

1. Co uÅ¾ivatel vidÃ­, dokud se ÄekÃ¡ na odpovÄ›Ä od serveru? Jestli to je nÄ›jakÃ¡ neÃºplnÃ¡ HTML struktura, mÄ›la by bÃ½t skryta. V naÅ¡em pÅ™Ã­padÄ› nevidÃ­ nic.
1. Co uÅ¾ivatel vidÃ­, pokud se prÃ¡zdnÃ½ prostor ve strÃ¡nce plnÃ­ opakovanÄ›? PÅ™i kaÅ¾dÃ©m hledÃ¡nÃ­ je nutnÃ© obsah prvku `#results` nahradit. NamÃ­sto pÅ™idÃ¡vÃ¡nÃ­ novÃ½ch uzlÅ¯ proto pouÅ¾Ã­vÃ¡me `results.replaceChildren()`.

V tÃ©to kapitole se pojÄme podÃ­vat pozornÄ›ji na funkci `buildSong`, kterÃ¡ slouÅ¾Ã­ k vÃ½robÄ› HTML prvku odpovÃ­dajÃ­cÃ­ho jednomu vÃ½sledku hledÃ¡nÃ­.



## Co jsme se nauÄili

Po vyÅ™eÅ¡enÃ­ ÄtvrtÃ© Ãºlohy by mÄ›l ÄtenÃ¡Å™ chÃ¡pat a ovlÃ¡dat:

  - koncept komunikace se serverem pomocÃ­ HTTP JSON API
  - prÃ¡ci s asynchronnÃ­m objektem `XMLHttpRequest`
  - vlastnost `labels` u formulÃ¡Å™ovÃ½ch polÃ­
