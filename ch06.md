# Kapitola 6: Cesta k SPA, riziko XSS

## Zadání

Na našem webu, který fanouškům poskytuje texty písní Karla Gotta, nabízíme funkci *hledání*: uživatel zadá do formulářového pole hledaný text a my mu po odeslání na nové stránce zobrazíme všechny související písně. Rádi bychom současné řešení upravili na modernější single-page systém, kdy při zobrazení výsledků nedochází k načtení nové stránky. Backend bude data opět nabízet formou HTTP JSON API.

## Řešení

Stejně jako v minulé kapitole, i zde budeme pracovat s daty získanými z backendu. Komunikace může vypadat třeba takto:

  - data odesílaná na server budou realizována požadavkem na URL `/search?query=...`
  - server odpoví daty ve formátu JSON a bude to pole; jeho jednotlivé položky budou vypadat takto:
	```json
	{
		"title": "Mám styl Čendy",
		"text": "Mezi námi je <em>mnoho</em> chvil",
		"url": "..."  // odkaz na celý text písně
	}
	```

Pod klíčem *text* je uložena část textu písně, díky které se píseň dostala do výsledků. Konkrétně server značkou `<em>` označí tu část textu, která odpovídá hledanému termínu.

Mimochodem: je nezbytné, aby to dělal server, když i klient zná hledaný termín a mohl by jej v textu najít a označit? Ano, v naprosté většině případů je zodpovědností serveru, aby data takto připravil. Jen on totiž ví, proč se píseň dostala do výsledků; možná že je v ní hledaný termín v jiném pádu, bez diakritiky nebo s jinou velikostí písmen.

Vzorové řešení pak může vypadat takto:

```html
<h1>Hledání</h1>
<form>
	<label>
		Hledaný výraz: <input type="text" name="query" />
	</label>
	<label>
		<button>🔎</button>
	</label>
</form>

<section id="results"></section>
```

```js
let form = document.querySelector("form");
let results = document.querySelector("#results");

function buildSong(song) {
	let item = document.createElement("li");
	item.innerHTML = `<a href="${song.url}">${song.title}</a> <br/> ${song.text}`;
	return item;
}

function showResults(xhr, query) {
	let songs = xhr.response;
	if (songs.length == 0) {
		results.replaceChildren("Tomuto dotazu nevyhovují žádné písně 🙁");
		return;
	}

	let heading = document.createElement("h2");
	heading.textContent = `Nalezené písně pro dotaz: ${query}`;

	let ul = document.createElement("ul");
	results.replaceChildren(heading, ul);

	for (let i=0; i<songs.length; i++) {
		let song = buildSong(songs[i]);
		ul.append(song);
	}
}

function onSubmit(e) {
	e.preventDefault();
	let xhr = new XMLHttpRequest();
	let query = form.querySelector("[name=query]").value;
	let url = `/search?query=${encodeURIComponent(query)}`;
	xhr.responseType = "json";
	xhr.open("GET", url);
	xhr.send();
	xhr.addEventListener("load", e => showResults(xhr, query));
}

form.addEventListener("submit", onSubmit)
```

Kód neobsahuje žádné velké novinky. Jedná se o kombinaci minulých dvou kapitol (použití `XMLHttpRequest` a události `submit`). Za zmínku stojí:

- Ve formuláři jsme použili HTML prvek `<button>`, který ve výchozím nastavení též funguje jako odesílací tlačítko.
- V rámci posluchače `onSubmit` vždy voláme `e.preventDefault()`, abychom tak zamezili odeslání. V kontextu této úlohy to neznamená chybu uživatele, ale snahu zůstat na stejné stránce a požadovanou funkcionalitu následně vykonat pomocí JavaScriptu.
- Data z hledacího pole před vložením do URL opět upravujeme funkcí `encodeURIComponent`, pro případ, že by obsahovala znaky, které do URL nepatří.

V HTML dokumentu jsme si nachystali prázdný prvek `<section id="results"></section>`, jehož obsah následně plníme na základě dat ze serveru. To je velmi častý postup: v HTML připravíme jen kostru či šablonu výsledné stránky, JavaScriptem do ní později dodáme potřebné informace. V těchto případech je dobré nezapomenout na dva scénáře:

1. Co uživatel vidí, dokud se čeká na odpověď od serveru? Jestli to je nějaká neúplná HTML struktura, měla by být skryta. V našem případě nevidí nic.
1. Co uživatel vidí, pokud se prázdný prostor ve stránce plní opakovaně? Při každém hledání je nutné obsah prvku `#results` nahradit. Namísto přidávání nových uzlů proto používáme `results.replaceChildren()`.

V této kapitole se pojďme podívat pozorněji na funkci `buildSong`, která slouží k výrobě HTML prvku odpovídajícího jednomu výsledku hledání.



## Co jsme se naučili

Po vyřešení čtvrté úlohy by měl čtenář chápat a ovládat:

  - koncept komunikace se serverem pomocí HTTP JSON API
  - práci s asynchronním objektem `XMLHttpRequest`
  - vlastnost `labels` u formulářových polí
