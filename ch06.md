# Kapitola 6: Cesta k SPA, riziko XSS

## Zadání

Na našem webu, který fanouškům poskytuje texty písní Karla Gotta, nabízíme funkci *hledání*: uživatel zadá do formulářového pole hledaný text a my mu po odeslání na nové stránce zobrazíme všechny související písně. Rádi bychom současné řešení upravili na modernější SPA (single-page application), kdy při zobrazení výsledků nedochází k načtení nové stránky. Backend bude data opět nabízet formou HTTP JSON API.

## Řešení

Stejně jako v minulé kapitole, i zde budeme pracovat s daty získanými z backendu. Komunikace může vypadat třeba takto:

  - data odesílaná na server budou realizována požadavkem na URL `/search?query=...`
  - server odpoví daty ve formátu JSON a bude to pole; jeho jednotlivé položky budou vypadat takto:
	```json
	{
		"title": "Mám styl Čendy",
		"text": "Mezi námi je <em>mnoho</em> chvil",
		"url": "..."  // odkaz na celý text písně
	}
	```

Pod klíčem *text* je uložena část textu písně, díky které se píseň dostala do výsledků. Konkrétně server značkou `<em>` označí tu část textu, která odpovídá hledanému termínu.

Mimochodem: je nezbytné, aby to dělal server, když i klient zná hledaný termín a mohl by jej v textu najít a označit? Ano, v naprosté většině případů je zodpovědností serveru, aby data takto připravil. Jen on totiž ví, proč se píseň dostala do výsledků; možná že je v ní hledaný termín v jiném pádu, bez diakritiky nebo s jinou velikostí písmen.

Vzorové řešení pak může vypadat takto:

```html
<h1>Hledání</h1>
<form>
	<label>
		Hledaný výraz: <input type="text" name="query" />
	</label>
	<label>
		<button>🔎</button>
	</label>
</form>

<section id="results"></section>
```

```js
let form = document.querySelector("form");
let results = document.querySelector("#results");

function buildSong(song) {
	let item = document.createElement("li");
	item.innerHTML = `<a href="${song.url}">${song.title}</a> <br/> ${song.text}`;
	return item;
}

function showResults(xhr, query) {
	let songs = xhr.response;
	if (songs.length == 0) {
		results.replaceChildren("Tomuto dotazu nevyhovují žádné písně 🙁");
		return;
	}

	let heading = document.createElement("h2");
	heading.textContent = `Nalezené písně pro dotaz: ${query}`;

	let ul = document.createElement("ul");
	results.replaceChildren(heading, ul);

	for (let i=0; i<songs.length; i++) {
		let song = buildSong(songs[i]);
		ul.append(song);
	}
}

function onSubmit(e) {
	e.preventDefault();
	let xhr = new XMLHttpRequest();
	let query = form.querySelector("[name=query]").value;
	let url = `/search?query=${encodeURIComponent(query)}`;
	xhr.responseType = "json";
	xhr.open("GET", url);
	xhr.send();
	xhr.addEventListener("load", e => showResults(xhr, query));
}

form.addEventListener("submit", onSubmit);
```

Kód neobsahuje žádné velké novinky. Jedná se o kombinaci minulých dvou kapitol (použití `XMLHttpRequest` a události `submit`). Za zmínku stojí:

- Ve formuláři jsme použili HTML prvek `<button>`, který ve výchozím nastavení též funguje jako odesílací tlačítko.
- V rámci posluchače `onSubmit` vždy voláme `e.preventDefault()`, abychom tak zamezili odeslání. V kontextu této úlohy to neznamená chybu uživatele, ale snahu zůstat na stejné stránce a požadovanou funkcionalitu následně vykonat pomocí JavaScriptu.
- Data z hledacího pole před vložením do URL opět upravujeme funkcí `encodeURIComponent`, pro případ, že by obsahovala znaky, které do URL nepatří.
- Posluchač události `load` je malá anonymní arrow funkce, která uzavírá proměnné `xhr` a `query`. Díky tomu můžeme do `showResults` předat libovolné parametry.

V HTML dokumentu jsme si nachystali prázdný prvek `<section id="results"></section>`, jehož obsah následně plníme na základě dat ze serveru. To je velmi častý postup: v HTML připravíme jen kostru či šablonu výsledné stránky, JavaScriptem do ní později dodáme potřebné informace. V těchto případech je dobré nezapomenout na dva scénáře:

1. Co uživatel vidí, dokud se čeká na odpověď od serveru? Jestli to je nějaká neúplná HTML struktura, měla by být skryta. V našem případě nevidí nic.
1. Co uživatel vidí, pokud se prázdný prostor ve stránce plní opakovaně? Při každém hledání je nutné obsah prvku `#results` nahradit. Namísto přidávání nových uzlů proto používáme `results.replaceChildren()`.

V této kapitole se pojďme podívat pozorněji na funkci `buildSong`, která slouží k výrobě HTML prvku odpovídajícího jednomu výsledku hledání. Poprvé se v ní setkáváme s vlastností `innerHTML`, která patří mezi nejsilnější součásti rozhraní DOM. Když nějakému HTML prvku přiřazujeme do vlastnosti `innerHTML`, říkáme tím, že prohlížeš má celý obsah (potomky) tohoto prvku nahradit novým podstromem, který vznikne parsováním zadaného řetězce. Je to skoro stejné, jako když necháváme prohlížeč sestavit strom dokumentu při prvním načtení stránky.

Jedná se o velmi pohodlný způsob tvorby složitější komponenty webové stránky. Porovnejme, o kolik by bylo zdlouhavější výsledek hledání vyrobit a sestavit pomocí několika `createElement` a `append`. Zároveň je pro nás řešení pomocí `innerHTML` nezbytné, protože od serveru již dostáváme malé části HTML -- vlastnost `text` s úryvkem textu písně obsahuje značku pro zvýraznění.

I přes nezpochybnitelné pohodlí vlasnosti `innerHTML` si ale musíme dát velký pozor na její použití. Jedná se totiž bohužel o častý vstupní bod pro zranitelnost typu XSS (*cross-site scripting*). Abychom lépe pochopili, oč jde, můžeme se podívat hned o pár řádků vedle, do funkce `showResults`. Tam se vyrábí nadpis pro výsledky:

```js
let heading = document.createElement("h2");
heading.textContent = `Nalezené písně pro dotaz: ${query}`;
```

Tentokrát se namísto `innerHTML` používá `textContent`, který taktéž nahradí danému uzlu obsah, ale prostým textem. Zadaný řetězec není parsován jako HTML, tj. případné HTML značky v něm obsažené se zobrazí jen jako text. A je to tak správně, neboť při použití `innerHTML` by pak mohl záludný uživatel do hledacího pole napsat například:

```
<img src="...">
```

Náš kód by pak v nadpisu namísto zadaného řetězce ukázal obrázek. A to je velká chyba, neboť uživatel svým vstupem dokázal **pozměnit strukturu dokumentu**. Od toho je pak už jen krůček k tomu, aby tímto způsobem mohl vložit vlastní skript. Jak přesně by toho docílil a jaké nebezpečí by z toho mohlo plynout -- to je mimo rozsah této knihy. Nám bohatě stačí, že bychom tak nechali uživatele do námi připraveného dokumentu vkládat jeho značky. To je v naprosté většině případů základ pro bezpečnostní malér.

Bereme si z toho velmi důležité ponaučení: jakmile vytváříme HTML dokument nebo jeho část, musíme uvažovat, jaká data v ní zobrazíme. Pokud existuje možnost, že tato data nepochází z důvěryhodného zdroje (tj. mohou obsahovat neočekávané HTML znaky), pracujeme defenzivně a tato data vkládáme pomocí `textContent` (nebo jako parametry do `append()`). Jen tak je zaručeno, že prohlížeč zadaný řetězec nebude považovat za HTML. A teprve když jsme si absolutně jisti, že v zobrazovaných proměnných jsou jen ne-HTML data, smíme použít mocnou vlastnost `innerHTML`.

Pro úplnost: je výše uvedenou optikou bezpečné naše použití `innerHTML` ve funkci `buildSong`? Záleží na tom, odkud se berou data uložená pod klíči `url`, `text` a `title`. Pokud bychom uvažovali variantu, že by Karel Gott do nějakého svého textu umístil záludný kousek HTML, museli bychom od serveru vyžadovat, aby vrácená data náležitě zabezpečil (problémové znaky nahradil za HTML entity).


## Co jsme se naučili

Po vyřešení páté úlohy by měl čtenář chápat a ovládat:

  - podstatu zranitelností XSS
  - rozdíl mezi vlasnostmi `textContent` a `innerHTML`

## Zelenáči: práce s adresním řádkem

SPA, tedy jednostránkové webové aplikace, staví na technice *nahrazování obsahu JavaScriptem*, namísto tradičního mechanismu *navigace* mezi více různými stránkami. V porovnání s běžně odesílaným formulářem je ale naše současné řešení ještě pořád trochu nemotorné. Při hledání totiž nedochází ke změně URL v adresním řádku prohlížeče. A to je škoda, protože tak přicházíme o:

- možnost uložení adresy s výsledky do záložek,
- možnost poslání takové adresy někomu jinému,
- možnost reloadu (opětovného načtení) stránky s výsledky,
- pohyb v historii prohlížeče (tj. tlačítko *Zpět*).

Uživatel se stále nachází na té samé stránce, takže v adresním řádku je stále jen např. `search.html`. Přitom zobrazovaná data se mění, takže by dávalo smysl, aby se měnilo i zobrazované URL.

Řešení není komplikované, byť na něj vývojáři často a rádi zapomínají. Sestává z těchto kroků:

1. Po provedení hledání musíme informaci o hledaném termínu vložit do URL v adresním řádku. To mj. způsobí záznam do historie prohlížeče, takže pak bude možný návrat tlačítkem *Zpět*.
1. Jakmile uživatel toto tlačítko použije, URL se změní (na předchozí hodnotu), ale my zůstáváme na stejné stránce. Musíme proto zobrazit obsah korespondující s novým URL.
1. Pokud uživatel načte novou stránku, v jejímž URL bude námi poznamenaná hledaná hodnota, musíme provést hledání.

Pojďme část vzorového řešení v tomto smyslu upravit a rozšířit. Nejprve rozdělíme *odeslání formuláře* a *hledání* do dvou funkcí:

```js
function search(query) {
	let xhr = new XMLHttpRequest();
	let url = `/search?query=${encodeURIComponent(query)}`;
	xhr.responseType = "json";
	xhr.open("GET", url);
	xhr.send();
	xhr.addEventListener("load", e => showResults(xhr, query));
}

function onSubmit(e) {
	e.preventDefault();
	let query = form.querySelector("[name=query]").value;
	search(query);
}
```

To odpovídá plánu, že hledání bude vyvoláno i jinými mechanismy, než jen odesláním formuláře. Dále, po odeslání formuláře bude potřeba změnit URL v adresním řádku:

```js
function onSubmit(e) {
	e.preventDefault();
	let query = form.querySelector("[name=query]").value;

	let url = new URL(location.href);
	url.searchParams.set("query", query);
	history.pushState(FIXME);

	search(query);
}
```

Zde vidíme dvě novinky: objekt `URL` pro pohodlnou práci s webovými adresami a dále proměnnou `history`, která nám mj. dovoluje měnit hodnotu v adresním řádku bez nutnosti navigace na nový dokument.

Tím jsme vyřešili první krok ze tří. Pro ten druhý se musíme dozvědět o tom, že došlo k uživatelem vyvolané změně adresního řádku. K tomu slouží událost `popstate`:

```js
function load() {
	let url = new URL(location.href);
	let query = url.searchParams.get("query");
	query && search(query);
}
FIXME.addEventListener("popstate", e => load());
```

Jedná se o proces symetrický k odeslání formuláře. Prohlédneme aktuální adresu a pokud je v ní zaznamenán hledaný text, provedeme hledání.

Poslední krok je jen pomyslná třešnička na dortu, protože k jeho splnění stačí novou funkci `load` zavolat po prvním načtení stránky. Celý upravený kód proto bude vypadat takto:

```js
function search(query) {
	let xhr = new XMLHttpRequest();
	let url = `/search?query=${encodeURIComponent(query)}`;
	xhr.responseType = "json";
	xhr.open("GET", url);
	xhr.send();
	xhr.addEventListener("load", e => showResults(xhr, query));
}

function onSubmit(e) {
	e.preventDefault();
	let query = form.querySelector("[name=query]").value;

	let url = new URL(location.href);
	url.searchParams.set("query", query);
	history.pushState(FIXME);

	search(query);
}

function load() {
	let url = new URL(location.href);
	let query = url.searchParams.get("query");
	query && search(query);
}

form.addEventListener("submit", onSubmit);
FIXME.addEventListener("popstate", e => load());

load();
```

## Koumáci: funkcionální iterace


## Profíci: fetch, Promises a async/await
