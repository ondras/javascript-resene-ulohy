# Cesta k&nbsp;SPA, riziko XSS

## 칔loha

Na na코em webu, kter칳 fanou코k콢m poskytuje texty p칤sn칤 Karla Gotta, nab칤z칤me funkci **hled치n칤:** u쬴vatel zad치 do formul치콏ov칠ho pole hledan칳 text a&nbsp;my mu po odesl치n칤 na nov칠 str치nce zobraz칤me v코echny souvisej칤c칤 p칤sn캩. R치di bychom sou캜asn칠 콏e코en칤 upravili na modern캩j코칤 SPA (single-page application), kdy p콏i zobrazen칤 v칳sledk콢 nedoch치z칤 k&nbsp;na캜ten칤 nov칠 str치nky. Backend bude data op캩t nab칤zet formou HTTP JSON API.

### 콎e코en칤

Stejn캩 jako v&nbsp;minul칠 kapitole, i&nbsp;zde m치me v&nbsp;pl치nu pracovat s&nbsp;daty, kter치 z칤sk치me JavaScriptov칳m po쬬davkem z&nbsp;backendu. Komunikace m콢쬰 vypadat t콏eba takto:

- data odes칤lan치 na server budou realizov치na HTTP po쬬davkem poslan칳m na adresu `/search?query=...`

- server odpov칤 daty ve form치tu JSON a&nbsp;bude to pole; jeho jednotliv칠 polo쬶y budou vypadat takto:

	```json
	{
		"title": "M치m styl 캛endy",
		"text": "Mezi n치mi je <em>mnoho</em> chvil",
		"url": "..."  // odkaz na cel칳 text p칤sn캩
	}
	```

Pod kl칤캜em `text` je ulo쬰na 캜치st textu p칤sn캩, d칤ky kter칠 se p칤se켿 dostala do v칳sledk콢. Konkr칠tn캩 server zna캜kou `<em>` ozna캜칤 tu 캜치st textu, kter치 odpov칤d치 hledan칠mu term칤nu.

Mimochodem: je nezbytn칠, aby to d캩lal server, kdy i&nbsp;klient zn치 hledan칳 term칤n a&nbsp;mohl by jej v&nbsp;textu naj칤t a&nbsp;ozna캜it? Ano, v&nbsp;naprost칠 v캩t코in캩 p콏칤pad콢 je zodpov캩dnost칤 serveru, aby data takto p콏ipravil. Jen on toti v칤, pro캜 se p칤se켿 dostala do v칳sledk콢; mo쬹치 쬰 je v&nbsp;n칤 hledan칳 term칤n v&nbsp;jin칠m p치du, bez diakritiky nebo s&nbsp;jinou velikost칤 p칤smen.

Vzorov칠 콏e코en칤 pak m콢쬰 vypadat takto:

```html
<!-- kapitola-6.html -->
<h1>Hled치n칤</h1>
<form>
	<label>
		Hledan칳 v칳raz: <input type="text" name="query" />
	</label>
	<label>
		<button>游댍</button>
	</label>
</form>

<section id="results"></section>

<script src="kapitola-6.js"></script>
```

```js
// kapitola-6.js
let form = document.querySelector("form");
let results = document.querySelector("#results");

function buildSong(song) {
	let item = document.createElement("li");
	item.innerHTML = `
		<a href="${song.url}">${song.title}</a>
		<br/> ${song.text}
	`;
	return item;
}

function showResults(xhr, query) {
	let songs = xhr.response;
	if (songs.length == 0) {
		results.replaceChildren("Dotazu nevyhovuj칤 쮂멳n칠 p칤sn캩 游뗴");
		return;
	}

	let heading = document.createElement("h2");
	heading.textContent = `Nalezen칠 p칤sn캩 pro dotaz: ${query}`;

	let ol = document.createElement("ol");
	results.replaceChildren(heading, ol);

	for (let i=0; i<songs.length; i++) {
		let song = buildSong(songs[i]);
		ol.append(song);
	}
}

function onSubmit(e) {
	e.preventDefault();
	let xhr = new XMLHttpRequest();
	let query = form.querySelector("[name=query]").value;
	let url = `/search?query=${encodeURIComponent(query)}`;
	xhr.responseType = "json";
	xhr.open("GET", url);
	xhr.send();
	xhr.addEventListener("load", e => showResults(xhr, query));
}

form.addEventListener("submit", onSubmit);
```

K칩d neobsahuje 쮂멳n칠 velk칠 novinky. Jedn치 se o&nbsp;kombinaci minul칳ch dvou kapitol (pou쬴t칤 `XMLHttpRequest` a&nbsp;ud치losti `submit`). Za zm칤nku stoj칤:

- Ve formul치콏i jsme pou쬴li HTML prvek `<button>`, kter칳 ve v칳choz칤m nastaven칤 t칠 funguje jako odes칤lac칤 tla캜칤tko.

- V&nbsp;r치mci poslucha캜e `onSubmit` v쬯y vol치me `e.preventDefault()`, abychom tak zamezili odesl치n칤. V&nbsp;kontextu t칠to 칰lohy to neznamen치 chybu u쬴vatele, ale snahu z콢stat na stejn칠 str치nce a&nbsp;po쬬dovanou funkcionalitu n치sledn캩 vykonat pomoc칤 JavaScriptu.

- Data z&nbsp;hledac칤ho pole p콏ed vlo쬰n칤m do URL op캩t upravujeme funkc칤 `encodeURIComponent`, pro p콏칤pad, 쬰 by obsahovala znaky, kter칠 do URL nepat콏칤.

- Poslucha캜 ud치losti `load` je mal치 anonymn칤 arrow funkce, kter치 uzav칤r치 prom캩nn칠 `xhr` a&nbsp;`query`. D칤ky tomu m콢쬰me do `showResults` p콏edat libovoln칠 parametry.

V&nbsp;HTML dokumentu jsme si nachystali pr치zdn칳 prvek `<section id="results">`, jeho obsah n치sledn캩 pln칤me na z치klad캩 dat ze serveru. To je velmi 캜ast칳 postup: v&nbsp;HTML p콏iprav칤me jen kostru 캜i 코ablonu v칳sledn칠 str치nky, JavaScriptem do n칤 pozd캩ji dod치me pot콏ebn칠 informace. V&nbsp;t캩chto p콏칤padech je dobr칠 nezapomenout na dva sc칠n치콏e:

1. Co u쬴vatel vid칤, dokud se 캜ek치 na odpov캩캞 od serveru? Jestli to je n캩jak치 ne칰pln치 HTML struktura, m캩la by b칳t skryta. V&nbsp;na코em p콏칤pad캩 nevid칤 nic.

1. Co u쬴vatel vid칤, pokud se pr치zdn칳 prostor ve str치nce pln칤 opakovan캩? P콏i ka쬯칠m hled치n칤 je nutn칠 obsah prvku `#results` nahradit. Nam칤sto p콏id치v치n칤 nov칳ch uzl콢 proto pou쮂셨치me `results.replaceChildren()`.

V&nbsp;t칠to kapitole se poj캞me pod칤vat pozorn캩ji na funkci `buildSong`, kter치 slou쮂 k&nbsp;v칳rob캩 HTML prvku odpov칤daj칤c칤ho jednomu v칳sledku hled치n칤. Poprv칠 se v&nbsp;n칤 setk치v치me s&nbsp;vlastnost칤 `innerHTML`, kter치 pat콏칤 mezi nejsiln캩j코칤 sou캜치sti rozhran칤 DOM. Kdy n캩jak칠mu HTML prvku p콏i콏azujeme do vlastnosti `innerHTML`, 콏칤k치me t칤m, 쬰 prohl칤쬰캜 m치 cel칳 obsah (potomky) tohoto prvku nahradit nov칳m podstromem, kter칳 vznikne parsov치n칤m zadan칠ho 콏et캩zce. Je to skoro stejn칠, jako kdy nech치v치me prohl칤쬰캜 sestavit strom dokumentu p콏i prvn칤m na캜ten칤 str치nky.

Jedn치 se o&nbsp;velmi pohodln칳 zp콢sob tvorby slo쬴t캩j코칤 komponenty webov칠 str치nky. Porovnejme, o&nbsp;kolik by bylo zdlouhav캩j코칤 v칳sledek hled치n칤 vyrobit a&nbsp;sestavit pomoc칤 n캩kolika vol치n칤 `createElement` a&nbsp;`append`. Z치rove켿 je pro n치s 콏e코en칤 pomoc칤 `innerHTML` nezbytn칠, proto쬰 od serveru ji dost치v치me mal칠 캜치sti HTML -- vlastnost `text` s&nbsp;칰ryvkem textu p칤sn캩 obsahuje zna캜ku pro zv칳razn캩n칤.

I&nbsp;p콏es nezpochybniteln칠 pohodl칤 vlastnosti `innerHTML` si ale mus칤me d치t velk칳 pozor na jej칤 pou쬴t칤. Jedn치 se toti bohu쬰l o&nbsp;캜ast칳 vstupn칤 bod pro zranitelnost typu **XSS** *(cross-site scripting)*. Abychom l칠pe pochopili, o캜 jde, m콢쬰me se pod칤vat hned o&nbsp;p치r 콏치dk콢 vedle, do funkce `showResults`. Tam se vyr치b칤 nadpis pro v칳sledky:

```js
let heading = document.createElement("h2");
heading.textContent = `Nalezen칠 p칤sn캩 pro dotaz: ${query}`;
```

Tentokr치t se nam칤sto `innerHTML` pou쮂셨치 `textContent`, kter칳 takt칠 nahrad칤 dan칠mu uzlu obsah, ale prost칳m textem. Zadan칳 콏et캩zec nen칤 parsov치n jako HTML, tj. p콏칤padn칠 HTML zna캜ky v&nbsp;n캩m obsa쬰n칠 se zobraz칤 jen jako text. A&nbsp;je to tak spr치vn캩, nebo콘 p콏i pou쬴t칤 `innerHTML` by pak mohl z치ludn칳 u쬴vatel do hledac칤ho pole napsat nap콏칤klad:

```html
<img src="...">
```

N치코 k칩d by pak v&nbsp;nadpisu nam칤sto zadan칠ho 콏et캩zce uk치zal obr치zek. A&nbsp;to je velk치 chyba, nebo콘 u쬴vatel sv칳m vstupem dok치zal **pozm캩nit strukturu dokumentu**. Od toho je pak u jen kr콢캜ek k&nbsp;tomu, aby t칤mto zp콢sobem mohl vlo쬴t vlastn칤 skript. Jak p콏esn캩 by toho doc칤lil a&nbsp;jak칠 nebezpe캜칤 by z&nbsp;toho mohlo plynout -- to je mimo rozsah t칠to knihy. N치m bohat캩 sta캜칤, 쬰 bychom tak nechali u쬴vatele do n치mi p콏ipraven칠ho dokumentu vkl치dat jeho zna캜ky. To je v&nbsp;naprost칠 v캩t코in캩 p콏칤pad콢 z치klad pro bezpe캜nostn칤 mal칠r.

Bereme si z&nbsp;toho velmi d콢le쬴t칠 ponau캜en칤: jakmile vytv치콏칤me HTML dokument nebo jeho 캜치st, mus칤me uva쬺vat, jak치 data v&nbsp;n칤 zobraz칤me. Pokud existuje mo쬹ost, 쬰 tato data nepoch치z칤 z&nbsp;d콢v캩ryhodn칠ho zdroje (tj. mohou obsahovat neo캜ek치van칠 HTML znaky), pracujeme defenzivn캩 a&nbsp;tato data vkl치d치me pomoc칤 `textContent` (nebo jako parametry do `append()`). Jen tak je zaru캜eno, 쬰 prohl칤쬰캜 zadan칳 콏et캩zec nebude pova쬺vat za HTML. A&nbsp;teprve kdy jsme si absolutn캩 jisti, 쬰 v&nbsp;zobrazovan칳ch prom캩nn칳ch jsou jen ne-HTML data, sm칤me pou쮂셦 mocnou vlastnost `innerHTML`.

Pro 칰plnost: je v칳코e uvedenou optikou bezpe캜n칠 na코e pou쬴t칤 `innerHTML` ve funkci `buildSong`? Z치le쮂 na tom, odkud se berou data ulo쬰n치 pod kl칤캜i `url`, `text` a&nbsp;`title`. Pokud bychom uva쬺vali variantu, 쬰 by Karel Gott do n캩jak칠ho sv칠ho textu um칤stil z치ludn칳 kousek HTML, museli bychom od serveru vy쬬dovat, aby vr치cen치 data n치le쬴t캩 zabezpe캜il (probl칠mov칠 znaky nahradil za HTML entity).

### Co jsme se nau캜ili

Po vy콏e코en칤 p치t칠 칰lohy by m캩l 캜ten치콏 ch치pat a&nbsp;ovl치dat:

- podstatu zranitelnost칤 XSS

- rozd칤l mezi vlastnostmi `textContent` a&nbsp;`innerHTML`

## Zelen치캜i: pr치ce s&nbsp;adresn칤m 콏치dkem

SPA, tedy jednostr치nkov칠 webov칠 aplikace, stav칤 na technice *nahrazov치n칤 obsahu JavaScriptem*, nam칤sto tradi캜n칤ho mechanismu *navigace* mezi v칤ce r콢zn칳mi str치nkami. V&nbsp;porovn치n칤 s&nbsp;b캩쬹캩 odes칤lan칳m formul치콏em je ale na코e sou캜asn칠 콏e코en칤 je코t캩 po콏치d trochu nemotorn칠. P콏i hled치n칤 toti nedoch치z칤 ke zm캩n캩 URL v&nbsp;adresn칤m 콏치dku prohl칤쬰캜e. A&nbsp;to je 코koda, proto쬰 tak p콏ich치z칤me o:

- mo쬹ost ulo쬰n칤 adresy s&nbsp;v칳sledky do z치lo쬰k,

- mo쬹ost posl치n칤 takov칠 adresy n캩komu jin칠mu,

- mo쬹ost reloadu (op캩tovn칠ho na캜ten칤) str치nky s&nbsp;v칳sledky,

- pohyb v&nbsp;historii prohl칤쬰캜e (tj. tla캜칤tko *Zp캩t*).

U쬴vatel se st치le nach치z칤 na t칠 sam칠 str치nce, tak쬰 v&nbsp;adresn칤m 콏치dku je st치le jen nap콏. `search.html`. P콏itom zobrazovan치 data se m캩n칤, tak쬰 by d치valo smysl, aby se m캩nilo i&nbsp;zobrazovan칠 URL.

콎e코en칤 nen칤 komplikovan칠, by콘 na n캩j v칳voj치콏i 캜asto a&nbsp;r치di zapom칤naj칤. Sest치v치 z&nbsp;t캩chto krok콢:

1. Po proveden칤 hled치n칤 mus칤me informaci o&nbsp;hledan칠m term칤nu vlo쬴t do URL v&nbsp;adresn칤m 콏치dku. To mj. zp콢sob칤 z치znam do historie prohl칤쬰캜e, tak쬰 pak bude mo쬹칳 n치vrat tla캜칤tkem *Zp캩t*.

1. Jakmile u쬴vatel toto tla캜칤tko pou쬴je, URL se zm캩n칤 (na p콏edchoz칤 hodnotu), ale my z콢st치v치me na stejn칠 str치nce. Mus칤me proto zobrazit obsah koresponduj칤c칤 s&nbsp;nov칳m URL.

1. Pokud u쬴vatel na캜te novou str치nku, v&nbsp;jej칤m URL bude n치mi poznamenan치 hledan치 hodnota, mus칤me prov칠st hled치n칤.

Poj캞me 캜치st vzorov칠ho 콏e코en칤 v&nbsp;tomto smyslu upravit a&nbsp;roz코칤콏it. Nejprve rozd캩l칤me *odesl치n칤 formul치콏e* a&nbsp;*hled치n칤* do dvou funkc칤:

```js
function search(query) {
	let xhr = new XMLHttpRequest();
	let url = `/search?query=${encodeURIComponent(query)}`;
	xhr.responseType = "json";
	xhr.open("GET", url);
	xhr.send();
	xhr.addEventListener("load", e => showResults(xhr, query));
}

function onSubmit(e) {
	e.preventDefault();
	let query = form.querySelector("[name=query]").value;
	search(query);
}
```

To odpov칤d치 pl치nu, 쬰 hled치n칤 bude vyvol치no i&nbsp;jin칳mi mechanismy, ne jen odesl치n칤m formul치콏e. D치le, po odesl치n칤 formul치콏e bude pot콏eba zm캩nit URL v&nbsp;adresn칤m 콏치dku:

```js
function onSubmit(e) {
	e.preventDefault();
	let query = form.querySelector("[name=query]").value;

	let url = new URL(location.href);
	url.searchParams.set("query", query);
	history.pushState("", "", url);

	search(query);
}
```

Zde vid칤me dv캩 novinky:

1. Objekt `URL` nab칤z칤 pohodlnou pr치ci s&nbsp;webov칳mi adresami. V&nbsp;na코em p콏칤pad캩 je nejzaj칤mav캩j코칤 pod-objekt `searchParams`, pomoc칤 kter칠ho m콢쬰me snadno p콏istupovat k&nbsp;캜치sti URL za otazn칤kem. Zpravidla se j칤 콏칤k치 *search parameters* a&nbsp;tradi캜n캩 do n칤 vkl치d치me 콏et캩zce ve tvaru kl칤캜-hodnota. Jejich konkr칠tn칤 form치t nemus칤me 콏e코it, nebo콘 to za n치s za콏칤d칤 pr치v캩 objekt `URL`.

1. Prom캩nnou `history`, kter치 n치m mj. dovoluje m캩nit hodnotu v&nbsp;adresn칤m 콏치dku bez nutnosti navigace na nov칳 dokument.

T칤m jsme vy콏e코ili prvn칤 krok ze t콏칤. Pro ten druh칳 se mus칤me dozv캩d캩t o&nbsp;tom, 쬰 do코lo k&nbsp;u쬴vatelem vyvolan칠 zm캩n캩 adresn칤ho 콏치dku. K&nbsp;tomu slou쮂 ud치lost `popstate`, kter치 nast치v치 na glob치ln칤m objektu `window`:

```js
function load() {
	let url = new URL(location.href);
	let query = url.searchParams.get("query");
	query && search(query);
}
window.addEventListener("popstate", e => load());
```

Jedn치 se o&nbsp;proces symetrick칳 k&nbsp;odesl치n칤 formul치콏e. Prohl칠dneme aktu치ln칤 adresu a&nbsp;pokud je v&nbsp;n칤 zaznamen치n hledan칳 text, provedeme hled치n칤.

Posledn칤 krok je jen pomysln치 t콏e코ni캜ka na dortu, proto쬰 k&nbsp;jeho spln캩n칤 sta캜칤 novou funkci `load` zavolat po prvn칤m na캜ten칤 str치nky. Cel칳 upraven칳 k칩d proto bude vypadat takto:

```js
function search(query) {
	let xhr = new XMLHttpRequest();
	let url = `/search?query=${encodeURIComponent(query)}`;
	xhr.responseType = "json";
	xhr.open("GET", url);
	xhr.send();
	xhr.addEventListener("load", e => showResults(xhr, query));
}

function onSubmit(e) {
	e.preventDefault();
	let query = form.querySelector("[name=query]").value;

	let url = new URL(location.href);
	url.searchParams.set("query", query);
	history.pushState("", "", url);

	search(query);
}

function load() {
	let url = new URL(location.href);
	let query = url.searchParams.get("query");
	query && search(query);
}

form.addEventListener("submit", onSubmit);
window.addEventListener("popstate", e => load());

load();
```

Pozorn칠ho 캜ten치콏e mo쬹치 napadla ot치zka, kdy je spr치vn치 chv칤le na props치n칤 pr치v캩 hledan칠ho term칤nu do URL. Jist칳m pohledem by d치valo smysl tuto akci vykonat uvnit콏 funkce `search`, proto쬰 pr치v캩 p콏i hled치n칤 m치 doj칤t ke zm캩n캩 v&nbsp;adresn칤m 콏치dku. Nab칤dneme dva argumenty, pro캜 je na코e sou캜asn칠 콏e코en칤 vhodn캩j코칤:

1. Funkce `search` z콢st치v치 ur캜en치 pouze k&nbsp;proveden칤 hled치n칤. Pokud bychom do n칤 vlo쬴li i&nbsp;zm캩nu URL, do코lo by k&nbsp;p콏칤li코n칠mu roz코칤콏en칤 jej칤 zodpov캩dnosti (byla by *moc chytr치*). Znamenalo by to nap콏칤klad, 쬰 nen칤 mo쬹칠 prov칠st hled치n칤 bez zm캩ny URL.

1. Funkci `search` vol치me i&nbsp;v&nbsp;situac칤ch, kdy zm캩na URL nen칤 nutn치, resp. 쮂멳ouc칤. Je to jednak p콏i prvn칤m na캜ten칤 str치nky (v&nbsp;d콢sledku vol치n칤 funkce `load`) a&nbsp;jednak p콏i zm캩n캩 v&nbsp;adresn칤m 콏치dku (v&nbsp;d콢sledku ud치losti `popstate`). V&nbsp;obou t캩chto p콏칤padech u v&nbsp;URL spr치vn치 data jsou.

V칳코e uveden칠 pozorov치n칤 m콢쬰me shrnout do pou캜ky, kter치 plat칤 t칠m캩콏 ve v코ech podobn칳ch situac칤ch: **Zm캩na hodnoty v&nbsp;adresn칤m 콏치dku by m캩la b칳t vyvol치na jen v&nbsp;d콢sledku u쬴vatelovy interakce.**


## Koum치ci: funkcion치ln칤 iterace

Ve t콏et칤 kapitole jsme si p콏edvedli alternativn칤 mo쬹osti iterace pol칤. Poj캞me si nyn칤 na 칰loze z&nbsp;t칠to kapitoly vyzkou코et refactoring k칩du pomoc칤 funkcion치ln칤 iterace.

Podstatou funkcion치ln칤 iterace je opakovan칠 pou쮂셨치n칤 mal칳ch funkc칤, vykon치van칳ch automaticky nad polo쬶ami v&nbsp;poli. Ide치ln칤m startovn칤m bodem je funkce `showResults`, ve kter칠 se vytv치콏칤 jednotliv칠 v칳sledky hled치n칤. Zaj칤m치 n치s tato jej칤 캜치st:

```js
for (let i=0; i<songs.length; i++) {
	let song = buildSong(songs[i]);
	ol.append(song);
}
```

Proch치z칤me pole `songs` a&nbsp;pro ka쬯ou jeho polo쬶u vyrob칤me HTML prvek. To je 칰loha pro funkcion치ln캩-itera캜n칤 metodu `map`. Jej칤 pou쬴t칤 nad polem vr치t칤 nov칠 pole, jeho ka쬯치 polo쬶a vznikla vykon치n칤m mal칠 itera캜n칤 funkce nad polo쬶ou p콢vodn칤ho pole. V&nbsp;na코em p콏칤pad캩 by to mohlo vypadat takto:

```js
let items = songs.map(buildSong);
ol.append(...items);
```

Funkce `buildSong` dost치v치 jako (prvn칤) parametr jednotliv칠 polo쬶y odpov캩di a&nbsp;vrac칤 nov캩 vznikl칳 HTML prvek `<li>`. V&nbsp;prom캩nn칠 `items` je tedy pole HTML prvk콢. Ty bychom r치di nar치z vlo쬴li do seznamu `ol`, ov코em metoda `append` neum칤 pracovat s&nbsp;polem. Je nicm칠n캩 variadick치, tj. um칤 p콏ijmout libovoln칳 po캜et parametr콢. Pou쬴jeme proto oper치tor `...` (naz칳v치 se *spread operator*), jeho 칰kolem je p콏ev칠st hodnoty pole na jednotliv칠 parametry funkce. Jedn치 se o&nbsp;jak칠si *rozbalen칤* polo쬰k pole tam, kde jsou o캜ek치v치ny polo쬶y odd캩len칠 캜치rkou.

Pou쬴t칤m funkce `map` se k칩d nejen zkr치til a&nbsp;zp콏ehlednil, ale je i&nbsp;v칳konn캩j코칤: nemus칤me volat metodu `append` tolikr치t, kolik vypisujeme v칳sledk콢.

Zat칤m jsme si uk치zali dv캩 metody u쬴te캜n칠 pro funkcion치ln칤 iteraci, `forEach` a&nbsp;`map`. Je to jen drobn치 ochutn치vka z&nbsp;코irok칠ho mno쬽tv칤 metod, kter칠 n치m JavaScriptov치 pole nab칤z칤. Poj캞me si je코t캩 uk치zat jednu dal코칤, kter치 se 캜asto hod칤: `filter`. Jej칤m parametrem je op캩t mal치 funkce (n캩kdy se j칤 콏칤k치 *predik치t*), kter치 bude vykon치na nad ka쬯ou polo쬶ou pole. 칔kolem t칠to funkce je vr치tit pravdivostn칤 hodnotu `true` 캜i `false`. V칳sledkem vol치n칤 `filter` je potom nov칠 pole, kter칠 obsahuje jen ty polo쬶y p콢vodn칤ho pole, pro kter칠 byla predik치tem vr치cena hodnota `true`.

P콏edstavme si, 쬰 backend v&nbsp;r치mci nalezen칳ch v칳sledk콢 vr치t칤 i&nbsp;rok, ve kter칠m p칤se켿 vznikla. Pou쬴je k&nbsp;tomu nov칳 kl칤캜 `year`, jeho hodnotou je 캜칤slo. Jedna polo쬶a odpov캩di tedy vypad치 takto:

```json
{
	"title": "M치m styl 캛endy",
	"text": "Mezi n치mi je <em>mnoho</em> chvil",
	"url": "...",
	"year": 1984
}
```

Kdybychom cht캩li vypsat jen ty *nov칠* p칤sn캩, kter칠 vznikly v&nbsp;roce 1984 a&nbsp;pozd캩ji, napsali bychom si nejprve mal칳 testovac칤 predik치t:

```js
function isNew(song) {
	return (song.year >= 1984);
}
```

Ve v칳pisu bychom pak pou쬴li nav칤c metodu `filter`:

```js
let items = songs.filter(isNew).map(buildSong);
ol.append(...items);
```

Takov칠 콏et캩zov칠 vol치n칤 je ve sv캩t캩 funkcion치ln칤ho programovan칤 docela b캩쬹칠. Z치rove켿 je to m칤sto, kde m콢쬰me s&nbsp;v칳hodou pou쮂셦 zkr치cen칠ho z치pisu anonymn칤ch arrow funkc칤:

```js
let items = songs.filter(song => song.year >= 1984).map(buildSong);
ol.append(...items);
```

Nyn칤 u samostatn칳 predik치t `isNew` nepot콏ebujeme. Koum치ci si po p콏e캜ten칤 t칠to podkapitoly mo쬹치 p콢jdou dohledat, kter칠 dal코칤 metody pro funkcion치ln칤 iteraci existuj칤. Bez detailn캩j코칤ch uk치zek m콢쬰me napov캩d캩t, 쬰 ty nejd콢le쬴t캩j코칤 je코t캩 neprobran칠 jsou:

- `reduce` slou쮂셖칤 k&nbsp;vytvo콏en칤 jedin칠ho vysledku na z치klad캩 v코ech polo쬰k pole (nap콏. sou캜et, pr콢m캩r, nejv캩t코칤 hodnota&hellip;);

- `some` a&nbsp;`every`, kter칠 ov캩콏uj칤, zda n캩kter치 캜i v코echny polo쬶y pole spl켿uj칤 dan칳 predik치t;

- `find`, kter칠 vr치t칤 prvn칤 polo쬶u pole spl켿uj칤c칤 n캩jakou podm칤nku.

U&nbsp;funkcion치ln칤 iterace si ale uk치쬰me je코t캩 jednu v캩c: parametry, kter칠 jsou itera캜n칤m funkc칤m p콏ed치v치ny. Je z콏ejm칠, 쬰 prvn칤 a&nbsp;hlavn칤 parametr je v쬯y ta polo쬶a pole, kterou pr치v캩 zpracov치v치me. Dal코칤 parametry bychom mohli sami p콏ed치vat pou쬴t칤m uz치v캩ry. Abychom si pr치ci u코et콏ili, v캩t코ina itera캜n칤ch metod automaticky p콏ed치v치 i&nbsp;dal코칤 dva 캜asto u쬴te캜n칠 parametry: index (po콏ad칤, od nuly) polo쬶y a&nbsp;cel칠 pole, kter칠 pr치v캩 zpracov치v치me. Kdybychom nepou쮂셨ali pro v칳pis nalezen칳ch v칳sledk콢 캜칤slovan칳 seznam (HTML zna캜ka `<ol>`), mohli bychom snadno ve funkci `buildSong` doplnit k&nbsp;n치zvu i&nbsp;po콏ad칤 a&nbsp;celkov칳 po캜et:

```js
function buildSong(song, index, allSongs) {
	let item = document.createElement("li");
	let number = `${index+1}/${allSongs.length}`;
	item.innerHTML = `
		${number}: <a href="${song.url}">${song.title}</a>
		<br/> ${song.text}
	`;
	return item;
}

let items = songs.map(buildSong);
```

## Prof칤ci: fetch, Promises a&nbsp;async/await

V&nbsp;minul칠 kapitole jsme p콏edstavili objekt `XMLHttpRequest` a&nbsp;z치rove켿 si sl칤bili modern캩j코칤 alternativu, toti funkci `fetch`. Jej칤 rol칤 je takt칠 proveden칤 HTTP po쬬davku, tak쬰 hned do za캜치tku se nab칤z칤 ot치zka, v&nbsp;캜em 쬰 je v콢bec pou쬴t칤 `fetch` lep코칤. Fakticky toti 쮂멳nou funkcionalitu, kterou bychom v&nbsp;`XMLHttpRequest` nem캩li, nenab칤z칤. Hlavn칤 rozd칤l tak nen칤 v&nbsp;tom, **co** pomoc칤 fetch vykon치me, ale **jak**.

Abychom syst칠m pr치ce s&nbsp;funkc칤 `fetch` dob콏e pochopili a&nbsp;docenili, budeme se muset nejprve chv칤li zab칳vat **asynchronn칤mi** funkcemi v&nbsp;JavaScriptu. To jsou takov칠, kter칠 jako jeden ze sv칳ch parametr콢 p콏ij칤maj칤 *dal코칤* funkci, proto, aby ji d콏칤ve 캜i pozd캩ji samy vykonaly. Takov칠mu parametru se zpravidla 콏칤k치 **callback** a&nbsp;v&nbsp;t칠to knize jsme zat칤m potkali dv캩 m칤sta, kde se callbacky pou쮂셨aj칤:

- metodu `addEventListener`, kter치 d치v치me callback k&nbsp;vykon치n칤 v쬯y, kdy nastane po쬬dovan치 ud치lost,

- funkci `setTimeout`, kter칠 d치v치me callback k&nbsp;vykon치n칤 po uplynut칤 dan칠ho 캜asu.

Asynchronn칤ch funkc칤 je mnohem v칤ce a&nbsp;typicky se s&nbsp;nimi setk치v치me u&nbsp;aktivit, kter칠 trvaj칤 -- v치gn캩 콏e캜eno -- **dlouho**. Aby se prohl칤쬰캜 p콏i jejich vykon치v치n칤 nezasekl, nech치me jej vykon치vat pot콏ebnou funkcionalitu *na pozad칤* a&nbsp;pomoc칤 callbacku 콏ekneme, co se m치 st치t, a tato dlouhotrvaj칤c칤 aktivita skon캜칤. Nutnosti p콏ed치v치n칤 callbacku se 콏칤k치 CPS (anglicky *continuation passing style*) a&nbsp;pro nov치캜ky ve sv캩t캩 JavaScriptu to m콢쬰 b칳t matouc칤.

Situaci s&nbsp;CPS d치le komplikuje skute캜nost, 쬰 callback je nutn칠 zkombinovat tak칠 s&nbsp;ostatn칤mi parametry, kter칠 funkce ke sv칠mu chov치n칤 pot콏ebuje. Nap콏칤klad u&nbsp;funkce `setTimeout` m치me parametry dva: jeden callback a&nbsp;jednu 캜asovou hodnotu. Jejich po콏ad칤 si po letech pr치ce st치le pletou i&nbsp;velmi zku코en칤 program치to콏i. D콏칤ve nebo pozd캩ji si za캜nou v코칤mat, 쬰 u&nbsp;vol치n칤 asynchronn칤ch funkc칤 se callback tak n캩jak *nehod칤*; 쬰 jeho p콏칤tomnost je v&nbsp;k칩du ru코iv치 a&nbsp;sni쬿je 캜itelnost. Proto se v&nbsp;JavaScriptu mezi lety 2012 a 2015 objevil alternativn칤 zp콢sob pr치ce s&nbsp;CPS, zvan칳 **Promise** (캜esky *p콏칤slib*). Pou쬴t칤 Promise nep콏in치코칤 do jazyka nic koncep캜n캩 nov칠ho, jedn치 se jen o&nbsp;tzv. *n치vrhov칳 vzor*, tedy doporu캜en칳 zp콢sob, jak 콏e코it 캜asto se opakuj칤c칤 칰lohu.

P콏i pou쬴t칤 Promise se callback nep콏ed치v치 p콏칤mo do asynchronn칤 funkce. Nam칤sto toho n치m asynchronn칤 funkce vr치t칤 speci치ln칤 hodnotu (nazvanou Promise), kter치 vyjad콏uje skute캜nost, 쬰 p콏esto쬰 funkce ji skon캜ila, jej칤 pr치ce je코t캩 nen칤 hotov치. Callback pak p콏ed치me k&nbsp;takto z칤skan칠 Promise jej칤 metodou `then`. M콢쬰me si to prohl칠dnout na hypotetick칠m p콏칤kladu modern캩j코칤 varianty funkce `setTimeout`:

```js
function done() {
	console.log("hotovo!");
}

// star칳 zp콢sob
setTimeout(done, 500);

// nov칳 zp콢sob
let promise = setTimeout2(500);
promise.then(done);
```

Tato uk치zka je jen teoretick치, proto쬰 `setTimeout2` neexistuje -- ale kdyby ji dnes n캩kdo navrhl, jist캩 by fungovala takto. Na prvn칤 pohled to nevypad치, 쬰 bychom pomoc칤 Promise z칤skali n캩jak칳 u쬴tek. Jakmile v코ak n치코 k칩d za캜ne b칳t slo쬴t캩j코칤, uk치쬰 se, 쬰 pr치ce s&nbsp;Promises jej v칳razn캩 zjednodu코uje.

Pro lep코칤 pochopen칤 m콢쬰me na objekt typu Promise nahl칤쬰t jako na jakousi 캜ernou krabi캜ku, kter치 je pr치zdn치, ale jednoho dne se v&nbsp;n칤 objev칤 n캩jak치 hodnota (opravdov칳 v칳sledek t칠 asynchronn칤 funkce, kter치 Promise vr치tila). Nev칤me, kdy to bude, ale m콢쬰me k&nbsp;t칠to krabi캜ce p콏idat callback a&nbsp;ten bude vykon치n, jakmile se hodnota objev칤. T칤m se pomalu vrac칤me zp캩t k&nbsp;funkci `fetch`, kter치 Promise pou쮂셨치, tedy vrac칤. A&nbsp;to hned dvakr치t, proto쬰 zpracov치n칤 odpov캩di od serveru je rozd캩leno na dva kroky: kdy po s칤ti doraz칤 hlavi캜ky HTTP odpov캩di a&nbsp;kdy n치sledn캩 i&nbsp;cel칠 t캩lo:

```js
function onError(e) {
	console.error("Chyba p콏i z칤sk치v치n칤 dat", e);
}

function onBody(data) {
	console.log(data);
}

function onResponse(response) {
	response.json().then(onBody, onError);
}

fetch(url).then(onResponse, onError);
```

Funkce `onResponse` je vykon치na, jakmile doraz칤 hlavi캜ky odpov캩di. Jej칤m parametrem je objekt odpov캩di, jeho metody dovoluj칤 p콏칤stup k&nbsp;z칤skan칳m dat콢m. Metodou `json()` vy쮂멳치me t캩lo ve form치tu JSON, ale proto쬰 ve코ker치 data nemusela zat칤m dorazit, jedn치 se op캩t o&nbsp;asynchronn칤 funkci. Jej칤 vr치cen칠 Promise pak pomoc칤 `then` p콏ed치me callback `onBody`, kter칳 dostane ve코ker치 data vr치cen치 ze serveru.

Za pov코imnut칤 stoj칤, 쬰 metod캩 `then` m콢쬰me p콏edat i&nbsp;druh칳 callback (v&nbsp;na코em p콏칤pad캩 funkci `onError`). Ten bude vykon치n, pokud asynchronn칤 funkce nedok치쬰 splnit sv콢j 칰kol. Plat칤 tedy, 쬰 v&nbsp;p콏칤pad캩 칰sp캩chu bude vykon치n prvn칤 callback a&nbsp;v&nbsp;p콏칤pad캩 ne칰sp캩chu ten druh칳. Zde vid칤me jasnou v칳hodu Promises v&nbsp;porovn치n칤 s&nbsp;p콏ed치v치n칤m jednoho callbacku p콏칤mo asynchronn칤 funkci. U&nbsp;n캩j bychom museli p콏칤padn칳 ne칰sp캩ch rozhodovat na z치klad캩 parametru, se kter칳m bude vykon치n.

V&nbsp;praxi se s&nbsp;takov칳m pou쬴t칤m Promises, resp. metody `then`, ale v캩t코inou nesetk치me. P콏echod od callback콢 k&nbsp;Promises byl dobr칳 evolu캜n칤 krok, ale v&nbsp;roce 2017 se JavaScript do캜kal je코t캩 razantn캩j코칤ho vylep코en칤 pr치ce s&nbsp;CPS: kl칤캜ov칳ch slov `async` a&nbsp;`await`. Jejich pou쬴t칤 je 칰zce spjat칠 s&nbsp;Promises a&nbsp;dovoluje n치m poskl치dat zdrojov칳 k칩d tak, aby na prvn칤 pohled p콢sobil jako synchronn칤. Konkr칠tn캩:

- Kl칤캜ov칠 slovo `await` p콏edstavuje alternativu k&nbsp;vol치n칤 metody `then`. M콢쬰me jej napsat jako oper치tor p콏ed hodnotu, kter치 je Promise. Vyjad콏ujeme t칤m, 쬰 n치sleduj칤c칤 콏치dky k칩du chceme vykonat a pot칠, co tato Promise nabude n캩jak칠 hodnoty -- stejn캩 jako kdybychom je zabalili do mal칠 anonymn칤 funkce a&nbsp;tu p콏edali jako callback metod캩 `then`.

- To ov코em znamen치, 쬰 pr치v캩 definovan치 funkce (ta, ve kter칠 pou쬴jeme `await`) bude asynchronn칤; n캩kter칠 jej칤 콏치dky (ty, co n치sleduj칤 za `await`) se vykonaj칤 a pot칠, co funkce skon캜칤. Proto ji mus칤me ozna캜it kl칤캜ov칳m slovem `async` a&nbsp;d칤ky tomu bude jej칤 hodnota automaticky p콏evedena na Promise.

Nejl칠pe to pochop칤me 칰pravou minul칠 uk치zky na async/await:

```js
async function search(query) {
	try {
		let url = `/search?query=${encodeURIComponent(query)}`;
		let response = await fetch(url);
		let songs = await response.json();
	} catch (e) {
		console.error("Chyba p콏i z칤sk치v치n칤 dat", e);
	}
}
```

M칠n캩 zku코en칳 program치tor by t칠m캩콏 nepoznal, 쬰 se jedn치 o&nbsp;asynchronn칤 k칩d, ve kter칠m se objevuje hned n캩kolik prom캩nn칳ch typu Promise. V칳sledek je snadno 캜iteln칳, u코et콏ili jsme n캩kolik anonymn칤ch funkc칤 a&nbsp;z치rove켿 dok치쬰me dob콏e zpracovat p콏칤padn칠 chyby, nebo콘 sou캜치st칤 implementace kl칤캜ov칠ho slova `await` je i&nbsp;korektn칤 spolupr치ce s&nbsp;konstrukc칤 `try-catch`.

Na z치v캩r podkapitoly si je코t캩 ujasn캩me, jak s&nbsp;touto funkc칤 `search` pracovat. P콏ed jej칤 definic칤 se objevuje kl칤캜ov칠 slovo `async`, co 캜ten치콏i d치v치 garanci, 쬰 funkce vrac칤 Promise. M콢쬰me ji tedy volat t캩mito zp콢soby:

1. 칔pln캩 b캩쬹캩, pokud n치s jej칤 n치vratov치 hodnota nezaj칤m치:

		```js
		function onSubmit(e) {
			e.preventDefault();
			let query = form.querySelector("[name=query]").value;
			search(query);
		}
		```

1. Pomoc칤 metody `then`, pokud chceme vykon치vat n캩jakou aktivitu, a kdy bude hled치n칤 hotovo:

		```js
		function onDone() {
			console.log("Hled치n칤 hotovo");
		}

		function onSubmit(e) {
			e.preventDefault();
			let query = form.querySelector("[name=query]").value;
			search(query).then(onDone);
		}
		```

1. Ekvivalentn캩 pomoc칤 `await`, co s&nbsp;sebou ov코em nese povinnost ozna캜en칤 na코eho poslucha캜e jako `async`:

		```js
		async function onSubmit(e) {
			e.preventDefault();
			let query = form.querySelector("[name=query]").value;
			await search(query);
			console.log("Hled치n칤 hotovo");
		}
		```

Tato posledn칤 varianta si zaslou쮂 speci치ln칤 pozornost. Nen칤 na n칤 nic 코patn칠ho, ale pou쮂셨치n칤m asynchronn칤ch poslucha캜콢 se vystavujeme riziku nepozornosti, kter치 m콢쬰 vy칰stit v&nbsp;z치ke콏nou chybu. Vzpome켿me na 칰lohu z&nbsp;p콏edchoz칤 kapitoly, ve kter칠 jsme ov캩콏ovali dostupnost u쬴vatelsk칠ho jm칠na. 캛ten치콏 by po pro캜ten칤 캜치sti o&nbsp;**async/await** mohl cht칤t zm칤n캩nou kontrolu implementovat v&nbsp;r치mci ud치losti `submit` takto:

```js
async function checkUsername() {
	// ...
}

async function onSubmit(e) {
	let available = await checkUsername();
	if (!available) { e.preventDefault(); }
}

form.addEventListener("submit", onSubmit);
```

Um칤me vysv캩tlit, pro캜 tento nevinn캩 vypadaj칤c칤 k칩d nem콢쬰 fungovat? Pro snaz코칤 pochopen칤 funkci `onSubmit` ekvivalentn캩 p콏ep칤코eme na k칩d bez kl칤캜ov칳ch slov `async` a&nbsp;`await`, tj. pomoc칤 `then`:

```js
function onSubmit(e) {
	checkUsername().then(available => {
		if (!available) { e.preventDefault(); }
	});
}
```

Kdy dojde k&nbsp;vykon치n칤 vnit콏n칤 anonymn칤 arrow funkce? P콏칤li코 pozd캩; a d치vno po skon캜en칤 poslucha캜e `onSubmit`. Tou dobou u je ov코em p콏칤li코 pozd캩 volat `e.preventDefault()`, tuto mo쬹ost jsme m캩li jen b캩hem vykon치v치n칤 poslucha캜e. Plyne z&nbsp;toho pou캜en칤: *Zabr치nit v칳choz칤mu zpracov치n칤 ud치losti (nap콏. odesl치n칤 formul치콏e) m콢쬰me jen v&nbsp;r치mci synchronn칤ho k칩du poslucha캜e. Jakmile je na코e kontrola asynchronn칤, nelze pomoc칤 n칤 odesl치n칤 podm칤n캩n캩 ovliv켿ovat.*
