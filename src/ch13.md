# Když JavaScript nestačí

V&nbsp;předposlední kapitole už nebudeme řešit konkrétní úlohu, ale ukážeme si další směry, kam se v&nbsp;rámci prozkoumávání klientských webových technologií můžeme vydávat. Jakkoliv je totiž JavaScript užitečný, samotný nám nedokáže poskytnout vše, co bychom mohli potřebovat. Podívejme se tedy na několik populárních knihoven a&nbsp;nadstaveb, se kterými se praxi můžeme setkat.


## Zelenáči: React

Pro mnohé frontendové vývojáře je knihovna React stejně důležitá, jako Java&shy;Script samotný. Jedná se o&nbsp;nástroj původně vyvinutý pro interní potřeby projektu Facebook, který se následně rychle rozšířil po celém internetu. React je určen k&nbsp;tvorbě stromu stránky ze vstupních dat. Takovou úlohu jsme v&nbsp;této knize řešili několikrát -- použili jsme k&nbsp;tomu buď vestavěný HTML parser (tj. vlastnost `innerHTML`), nebo individuální metody dostupné v&nbsp;rozhraní DOM (jako např. `document.createElement`). React volí přístup koncepčně někde mezi těmito dvěma variantami: strom stránky vytváříme deklarativně (jako kdybychom rovnou psali HTML), ale atributy a&nbsp;textové uzly můžeme generovat rovnou z&nbsp;JavaScriptových dat (jako kdybychom nastavovali atributy DOM objektům).


React staví zejména na těchto konceptech:

- HTML výstup definujeme pomocí **značkovacího jazyka JSX**, který HTML připomíná. Jedná se o&nbsp;mix HTML a&nbsp;JavaScriptu; podobá se také trochu *template literals* (tyto řetězce jsme viděli v&nbsp;páté kapitole). React lze používat i&nbsp;bez JSX, ale připravujeme se tím o&nbsp;jisté množství funkcionality. Při naší ukázce vyzkoušíme React včetně JSX.

- Jednotlivé části kódu organizujeme do tzv. **komponent**, které zodpovídají za jednotlivé části stromu dokumentu. Úkolem komponent (a&nbsp;úkolem Reactu jako takového) je prezentace dat. Tato jsou komponentám v&nbsp;jazyce JSX předávána pomocí atributů, které mohou -- v&nbsp;porovnání s&nbsp;HTML -- obsahovat libovolné datové typy. V&nbsp;jazyce JSX pak komponenty vypadají jako HTML značky a&nbsp;nápadně připomínají *Custom Elements* (devátá kapitola). Komponenty jsou typicky implementovány jako JavaScriptové funkce.

- Při použití Reactu necháváme knihovnu vygenerovat výstup při libovolné změně ve vstupních datech, což zní jako zbytečná práce. React ale vzniklé HTML prvky negeneruje rovnou ve stránce, ale v&nbsp;rámci tzv. **virtual DOM** -- svého virtuálního dokumentu. Do stránky pak promítne jen ty úpravy, které znamenají změnu v&nbsp;dokumentu opravdovém.

React si můžeme vyzkoušet na úloze z&nbsp;šesté kapitoly, ve které implementujeme zobrazování výsledků hledání. Vystačíme si s&nbsp;minimálním HTML dokumentem:

```html
<!-- index.html -->
<body>
	<main></main>
	<script src="index.js"></script>
</body>
```

Celé HTML plánujeme vytvářet pomocí Reactu. Budeme k&nbsp;tomu používat jazyk JSX, takže výsledný skript `index.js` si na závěr necháme vygenerovat. Místo toho začneme vstupním bodem aplikace v&nbsp;souboru `index.jsx`:

```jsx
// index.jsx
import { createRoot } from "react-dom/client";
import App from "./App.jsx";


let main = document.querySelector("main");
createRoot(main).render(<App />)
```

Většina vstupních bodů reactových aplikací vypadá obdobně: pomocí funkce `createRoot` označíme místo ve stránce, do kterého necháme React generovat obsah prostřednictvím komponent. Zpravidla nepoužíváme celé `<body>`, ale jen nějakou pod-značku (jako zde `<main>`). To proto, aby nám zůstala možnost některé další části dokumentu spravovat bez použití Reactu.

Na druhém řádku pak importujeme hlavní komponentu, která zastřešuje celou aplikaci. V&nbsp;parametru funkce `render` již vidíme jazyk JSX v&nbsp;akci, když tuto komponentu  předáváme jako parametr. Podívejme se na její implementaci:

```jsx
// App.jsx
import { useState } from "react";
import Results from "./Results.jsx";


export default function App() {
  let [results, setResults] = useState({});

  async function onSubmit(e) {
    e.preventDefault();
    let query = encodeURIComponent(e.target.elements.query.value);
    let response = await fetch(`/search?query=${query}`);
    let results = await response.json();
    setResults({results, query});
  }

  return <>
    <h1>Hledání</h1>
    <form onSubmit={onSubmit}>
      <label>
        Hledaný výraz: <input type="text" name="query" />
      </label>
      <label>
        <button>🔎</button>
      </label>
    </form>
    <Results data={results} />
  </>;
}
```

Nenechme se zastrašit větším množstvím nezvyklých konstrukcí a&nbsp;pojďme si je po částech rozebrat. Poslední část funkce `App` definuje výsledné HTML, resp. výsledné JSX. To odpovídá přístupu **komponenty jsou funkce, které transformují vstup na HTML**. Každá komponenta musí vrátit jen jeden prvek, takže pokud chceme vykreslit více HTML (nadpis, formulář, výsledky), musíme je zabalit do společného *bezejmenného* obalu, který se v&nbsp;JSX zapisuje jako `<>...</>`.

Na konci HTML používáme další vlastní komponentu (`<Results>`), ke které se dostaneme za chvíli. Syntaxe se složenými závorkami odpovídá interpolaci hodnot z&nbsp;proměnných; zápis

```jsx
<Results data={results} />
```

tedy znamená, že zde chceme vykreslit zadanou komponentu a&nbsp;předat jí obsah lokální proměnné `results`.

Samotné hledání provede funkce `onSubmit`, kterou pro jednoduchost implementujeme pomocí `fetch`. Je to posluchač události, který v&nbsp;JSX přidáváme atributem `onSubmit`. Uvnitř této funkce potřebujeme přistoupit k&nbsp;hodnotě z&nbsp;vyhledávacího pole. Nemůžeme použít běžné dotazování pomocí `querySelector`, neboť celou tvorbu stromu DOMu za nás řeší React. Využijeme proto klíč `e.target`, který odpovídá odesílanému formuláři. Jeho vlastnost `elements` pak dovoluje přistoupit k&nbsp;jednotlivým formulářovým prvkům pomocí jejich jména (tedy HTML atributu `name`). Výsledný dotaz je zaslán na server a&nbsp;po obdržení odpovědi se zavolá funkce `setResults`, která aktualizuje stav aplikace.

V tuto chvíli je dobré poznamenat, že React nabízí i&nbsp;další způsoby, jak se v rámci posluchače dostat k&nbsp;hodnotě z&nbsp;formulářového pole. Představené řešení je sice funkční, ale v&nbsp;praxi můžeme narazit na odlišné varianty. Zmiňme pro inspiraci dvě z&nbsp;nich:

1. Formulářovému poli `<input>` můžeme přidat posluchač na změnu hodnoty (DOM událost `input`). V&nbsp;rámci posluchače je pak zadaný text dostupný jako `e.target.value` a&nbsp;my si jej můžeme například uložit do lokální proměnné.

1. K&nbsp;jednotlivým Reactem vytvořeným HTML prvkům se můžeme dostat pomocí tzv. *referencí* vytvářených reactovou funkcí `useRef`. Lze si je představit jako samolepky, kterými pomocí atributu `ref` označíme prvky v&nbsp;JSX a&nbsp;díky nim se pak dostaneme k&nbsp;jim odpovídajícím DOM objektům.

Poslední specialita v&nbsp;souboru `App.jsx` je funkce `useState`. Připomeňme, že hlavní úkol Reactu je převést naše data na HTML. Ideálně bychom rádi, aby komponenta tuto operaci provedla automaticky vždy, když její vstupní data změníme. Pouhá změna hodnoty v&nbsp;proměnné (jako např. `results`) k&nbsp;tomu ale nestačí, protože React se o&nbsp;takové změně nedozví. Zde vstupuje do hry funkce `useState`, která vytvoří navzájem provázanou dvojici proměnných: jednu pro hodnotu a&nbsp;jednu pro jí odpovídající funkci určenou ke změně hodnoty. Jakmile funkci zavoláme, hodnota se změní a&nbsp;*React dostane pokyn k&nbsp;překreslení*.

Mimochodem: využíváme zde zkrácený zápis definice objektu, který jsme poprvé potkali v&nbsp;osmé kapitole, konkrétně v&nbsp;její podkapitole pro zelenáče. Do funkce `setResults` tedy předáváme `{results:results, query:query}`.

Pokračujme ke komponentě `<Results>` v&nbsp;souboru `Results.jsx`:

```jsx
// Results.jsx
import Result from "./Result.jsx";


export default function Results(props) {
	const { query, results } = props.data;

	if (!query) { return; }

	if (!results.length) {
		return <p>Tomuto dotazu nevyhovují žádné písně 🙁</p>;
	}

	let items = results.map(item => <Result data={item} />);
	return <>
		<h2>Nalezené písně pro dotaz: {query}</h2>
		<ol>{items}</ol>
	</>;
}
```

Zde žádná velká překvapení nejsou. JSX atributy, které komponentě předáváme, jsou v&nbsp;odpovídající JS funkci dostupné jako vlastnosti objektu předaného v&nbsp;prvním parametru. Bývá obvyklé jej pojmenovat **props** (z&nbsp;anglického *properties*). Pro následné rozdělení dat do lokálních proměnných používáme destructuring (slyšeli jsme o&nbsp;něm v jedenácté kapitole).

Komponenta `<Results>` zastřešuje tři různé stavy (nebylo hledáno, nejsou výsledky, jsou výsledky), čemuž odpovídají jednotlivé podmínky. V&nbsp;případě nalezených výsledků vidíme cyklus realizovaný funkcionální metodou `map`. To znamená, že ve výsledném JSX interpolujeme proměnnou `items`, která je pole komponent typu `<Result>`. Ty jsou definovány v&nbsp;posledním souboru `Result.jsx`:

```jsx
// Result.jsx
export default function Result(props) {
	let html = {__html: props.data.text};
	return <li>
		<a href={props.data.url}>{props.data.title}</a>
		<br/>
		<span dangerouslySetInnerHTML={html} />
	</li>;
}
```

Vzpomeňme si na šestou kapitolu, ve které jsme narazili na koncept `innerHTML` a&nbsp;jeho potenciální důsledky pro bezpečnost aplikace. React se nás snaží od podobného postupu odradit, takže přímé vložení HTML kódu z&nbsp;proměnné je nezvykle složité:

- Nejprve musíme nachystat objekt s&nbsp;klíčem `__html`, jehož hodnota je náš řetězec obsahující (potenciálně rizikové) HTML.

- Poté tento objekt předáme atributu `dangerouslySetInnerHTML`, jehož výmluvné označení varuje, že jde o&nbsp;nebezpečnou operaci.

Co dál? Napsaný kód je docela složitý a&nbsp;prohlížeč mu nerozumí. Jednak nezná syntaxi JSX, jednak neví, jak importovat z `"react-dom/client"` (vzpomeňme na serverové importy z&nbsp;minulé kapitoly). Budeme muset použít nějaký nástroj, který JSX převede na použitelný JavaScript.

Z&nbsp;minulé kapitoly známe program `esbuild` (používali jsme jej k&nbsp;*bundlingu*). Teď se nám hodí, že `esbuild` dokáže mimo jiné zpracovávat soubory JSX a&nbsp;také používat závislosti z&nbsp;adresáře `node_modules`. Použijeme proto `npm` a&nbsp;nainstalujeme několik balíčků:

```sh
npm i -g esbuild       # zpracování JSX, bundling
npm i react react-dom  # součásti reactu
```

Nástroj `esbuild` instalujeme globálně, zatímco React a&nbsp;React-DOM lokálně do `node_modules`. Teď zbývá jen vygenerovat celou aplikaci:

```sh
esbuild --bundle index.jsx --jsx=automatic --outfile=index.js
```

Na závěr poznamenejme, že kompilace z&nbsp;JSX do JS je dnes dostupná prostřednictvím celé řady programů. Kromě zmiňovaného `esbuild` se často používají alternativy jako `babel`, `swc`, `rollup` nebo `tsc`, kterému se budeme věnovat v&nbsp;následující podkapitole.


## Koumáci: TypeScript

Pojďme si nyní prohlédnout další jazyk, který je dnes s&nbsp;JavaScriptem neodmyslitelně spojen. TypeScript vznikl jako nadmnožina JavaScriptu, ve které můžeme k&nbsp;proměnným a&nbsp;funkcím volitelně přidávat informace o&nbsp;jejich datovém typu. Říká se jim **typové anotace** a&nbsp;můžeme je znát i&nbsp;z&nbsp;dalších jazyků, jako např. Python či PHP. V&nbsp;JavaScriptu však typové anotace neexistují, takže kód psaný v&nbsp;TypeScriptu nemůžeme rovnou předhodit prohlížeči. Podobně jako u&nbsp;JSX je nutné nejprve kód převést na JavaScript. Tentokrát je ale převod velmi snadný, protože typicky zahrnuje pouze smazání typových anotací.

A&nbsp;proč to celé vlastně chceme dělat? TypeScript je odpovědí na dynamické typování JavaScriptu, které je pro mnoho vývojářů až příliš flexibilní. Kvůli němu nelze rychlým pohledem na proměnnou či funkci odhadnout, jakých hodnot může nabývat. Snadno se pak vystavujeme riziku, že budeme nějakou hodnotu mylně považovat za jiný datový typ a&nbsp;dopustíme se různých chyb (např. výjimek způsobujících přerušení běhu programu).

S&nbsp;typovými anotacemi se v&nbsp;TypeScriptu setkáváme dvakrát. Když převádíme kód z&nbsp;TypeScriptu do JavaScriptu, kompilátor anotace nejen odstraní, ale také s&nbsp;jejich pomocí zkontroluje, zdali neporušujeme jimi definovaná pravidla -- jestli třeba do proměnné označené jako *string* nevkládáme číslo. Zároveň ale anotace používáme již při samotném psaní kódu, pokud si správně nastavíme editor. Ten může na základě typových informací rovnou označovat bloky problematického kódu, případně napovídat typy a&nbsp;názvy parametrů funkcí a&nbsp;podobně.

Zdrojový kód v&nbsp;TypeScriptu píšeme do souborů s&nbsp;příponou `.ts`. Nejčastěji se typové anotace objevují za dvojtečkou, za názvem proměnné či parametru funkce. Můžeme si to vyzkoušet na příkladu triviální sčítací funkce:

```ts
// test.ts
function add(a: number, b: number): number {
	return a+b;
}
```

Typové anotace jsme přidali jak k&nbsp;oběma parametrům, tak k&nbsp;funkci jako takové -- říkáme tím, že její návratová hodnota je číslo. Na chování kódu anotace nemají žádný vliv, takže pokud bychom funkci předali dva řetězce, dojde k&nbsp;jejich (pravděpodobně chybnému) spojení. Proto bychom rádi, aby nás nějaká komponenta zavčasu (na základě anotací) upozornila, že funkci voláme špatně. Nejprve napíšeme problémový kód:

```ts
let a = "protřepat";
let b = "nemíchat";
let c = add(a, b);
```

Dobře nastavené vývojové prostředí by nás už nyní mělo varovat, že funkci voláme chybně. My nyní ale stojíme o&nbsp;kontrolu spojenou s&nbsp;převodem do prostého JavaScriptu. K&nbsp;tomu použijeme oficiální kompilátor **tsc** (TypeScript Compiler). Nainstalujeme jej pomocí npm:

```sh
npm i -g typescript
```

Pro spuštění kompilace stačí předat jméno souboru s&nbsp;TypeScriptovým kódem:

```sh
tsc test.ts

test.ts:6:13 - error TS2345: Argument of type 'string' is not assignable to parameter of type 'number'.
```

Dostali jsme vynadáno přesně dle očekávání. Zároveň s&nbsp;tím ale vznikl soubor `test.js`, který obsahuje náš chybný kód bez anotací. Kompilátor nám tedy nebrání v&nbsp;psaní pochybného kódu, ale pokud mu k&nbsp;tomu dáme příležitost, upozorní nás na problematická místa.

Mimochodem: v&nbsp;minulých kapitolách a&nbsp;podkapitolách jsme používali nástroj `esbuild`, který mj. provádí *bundling* a&nbsp;transpilaci JSX. Zvídavého čtenáře možná napadne, zdali by pomocí `esbuild` nešel kompilovat i&nbsp;zdrojový kód v&nbsp;TypeScriptu. Odpověď je *ano, ale* -- esbuild sice dovede odstranit typové anotace, ale neprovede při tom typovou kontrolu. Dostáváme tak jen polovinu funkcionality, kterou nám nabízí `tsc`.

Jazyk TypeScript je od počátku zamýšlen pro dobrovolné, pozvolné vylepšování JavaScriptového kódu. Pokud máme hotový projekt a&nbsp;rádi bychom do něj TypeScript zavedli, můžeme tak činit po malých krůčcích bez obav, že něco pokazíme. Program `tsc` lze vykonat i&nbsp;nad kódem, ve kterém typové anotace vůbec nejsou, nebo jsme je doplnili jen občasně. Součástí TypeScriptu je totiž tzv. **typová inference**, což znamená schopnost kompilátoru domyslet si v&nbsp;řadě případů datové typy podle toho, jakým způsobem s&nbsp;proměnnými pracujeme. Pokud například do proměnné při definici rovnou přiřadíme hodnotu, TypeScript odvodí její datový typ a&nbsp;bude s&nbsp;ním pracovat při dalších manipulacích s&nbsp;touto proměnnou:

```js
let a = "ahoj";
a = 42;  // Warning: Type 'number' is not assignable to type 'string'.
```

Stejně jako v&nbsp;minulé podkapitole, i&nbsp;nyní můžeme zkusit upravit vzorový kód z&nbsp;šesté kapitoly. Potřebujeme doplnit typové anotace tak, aby byl jasný datový typ každé proměnné a&nbsp;aby kompilátor nehlásil žádnou chybu. Hlavní data, se kterými pracujeme, jsou výsledky hledání. Na základě dohody s&nbsp;backendovou stranou aplikace víme, že se bude jednat o&nbsp;slovník s&nbsp;konkrétními položkami. Takový datový typ můžeme v&nbsp;TypeScriptu vyjádřit klíčovým slovem `interface`:

```ts
interface Song {
	url: string;
	title: string;
	text: string;
}

function buildSong(song: Song) {
	let item = document.createElement("li");
	item.innerHTML = `
		<a href="${song.url}">${song.title}</a>
		<br/> ${song.text}
	`;
	return item;
}
```

Dále přidáme typové informace do funkce, která je zodpovědná za zpracování a&nbsp;zobrazení výsledků hledání:

```ts
function showResults(xhr: XMLHttpRequest, query: string) {
	let results = document.querySelector("#results");
	if (!results) { return; }

	let songs = xhr.response as Song[];
	if (songs.length == 0) {
		results.replaceChildren("Dotazu nevyhovují žádné písně 🙁");
		return;
	}

	let heading = document.createElement("h2");
	heading.textContent = `Nalezené písně pro dotaz: ${query}`;

	let ol = document.createElement("ol");
	results.replaceChildren(heading, ol);

	for (let i=0; i<songs.length; i++) {
		let song = buildSong(songs[i]);
		ol.append(song);
	}
}
```

TypeScript je obeznámen s&nbsp;vestavěnými objekty rozhraní DOM, takže u&nbsp;prvního parametru můžeme rovnou psát `xhr: XMLHttpRequest`. Další důležitá novinka se objevuje hned na prvním řádku funkce `showResults`, kdy je nutné věnovat více pozornosti metodě `querySelector`. Může se totiž snadno stát, že tato metoda nevrátí použitelnou hodnotu -- když ve stránce takový prvek není nebo třeba když uděláme překlep v&nbsp;zadaném selektoru. Pokud chceme s&nbsp;proměnnou `results` nadále pracovat, musíme mít jistotu, že je neprázdná. Proto přidáme na další řádek podmínku a&nbsp;vykonávání případně ukončíme.

Hodnota `xhr.response` může být jakákoliv, neboť z&nbsp;našeho kódu neumíme ovlivnit data, která server vygeneruje. Nemáme proto žádnou jistotu, že proměnná `songs` je opravdu pole struktur typu `Song`. Zápisem `as Song[]` kompilátoru říkáme, ať pro potřeby kontroly typů předpokládá, že tomu tak opravdu je. Kdybychom chtěli, mohli bychom ještě dodat explicitní kód, který by příchozí data prošel a&nbsp;zkontroloval.

Zbývá vylepšení poslední části kódu, kdy reagujeme na odeslání hledacího formuláře. Jedná se o&nbsp;posluchač události `submit`:

```ts
function onSubmit(e: Event) {
	e.preventDefault();
	let xhr = new XMLHttpRequest();
	let input = form.querySelector<HTMLInputElement>("[name=query]");
	if (!input) { return; }
	let query = input.value;
	let url = `/search?query=${encodeURIComponent(query)}`;
	xhr.responseType = "json";
	xhr.open("GET", url);
	xhr.send();
	xhr.addEventListener("load", e => showResults(xhr, query));
}
```

Kromě kontroly návratové hodnoty `querySelector` zde narážíme na další komplikaci. Různé HTML prvky mají různé JavaScriptové vlastnosti, takže jednou nám funkce `querySelector` může vrátit třeba obrázek (ten má mj. vlastnost `src`), zatímco jindy vrátí prvek `<input>` (který má vlastnost `value`). TypeScriptový kompilátor je v&nbsp;tomto směru bezradný, takže mu napovíme pomocí tzv. **typového parametru**. Zápisem `querySelector<HTMLInputElement>` říkáme, že počítáme s&nbsp;tím, že návratová hodnota bude zadaného typu (a&nbsp;proto je v&nbsp;pořádku u&nbsp;ní následně pracovat s&nbsp;vlastností `value`).

Úplně na konec přidáme posluchač na formulář a&nbsp;při tom si ukážeme ještě jeden syntaktický prvek ze světa TypeScriptu:

```ts
let form = document.querySelector("form")!;
form.addEventListener("submit", onSubmit);
```

Víme, že funkce `querySelector` vrací buď HTML prvek, nebo `null`. Vykřičníkem říkáme, ať TypeScript možnost s&nbsp;`null` neuvažuje. I&nbsp;zde bychom mohli prostě použít podmínku (náš kód by byl robustnější!), ale vytvořili bychom tak komplikaci pro již upravený posluchač `onSubmit`. V&nbsp;něm se totiž, díky uzávěře, s&nbsp;proměnnou `form` taktéž pracuje. Kdyby její hodnota nebyla jistá, museli bychom s&nbsp;ní opatrně pracovat i&nbsp;uvnitř posluchače. My jako programátoři víme, že pokud se posluchač vykoná, proměnná `form` existuje -- TypeScript to ale za nás vymyslet nedokáže.


## Profíci: WebAssembly

Programovacích jazyků je kolem nás velké množství, a&nbsp;přesto je možné v&nbsp;rámci webového prohlížeče psát aplikační kód jen v&nbsp;JavaScriptu. Říkáme si, proč nemáme k&nbsp;dispozici i&nbsp;další možnosti jako například Python, Go nebo třeba Ruby. Jakkoliv by bylo zavedení dalšího jazyka do prohlížeče praktické, jedná se o&nbsp;příliš komplikovaný úkol -- znamenalo by to, že všechny prohlížeče musí přijít s&nbsp;identickou implementací zvoleného jazyka a&nbsp;zároveň pro něj poskytovat všechna rozhraní, se kterými jsme v&nbsp;JavaScriptu navyklí pracovat (DOM, práce se sítí, Canvas, Web Audio, &hellip;).

Namísto integrace nějakého dalšího konkrétního programovacího jazyka je pro nás ovšem dostupná trochu jiná možnost: prohlížeče dokážou zpracovávat kód ve speciálním tvaru **WebAssembly**. Jde o&nbsp;binární formát, který popisuje jednotlivé instrukce virtuálního procesoru, a&nbsp;v&nbsp;porovnání s&nbsp;JavaScriptem je tedy velmi nízkoúrovňový. Jeho výhoda tkví v&nbsp;tom, že do WebAssembly lze kompilovat programy psané v&nbsp;celé řadě jiných jazyků, zejména C, C++ a&nbsp;Rust. V&nbsp;prohlížeči pak nemusí existovat implementace těchto jazyků -- převod do WebAssembly musí provést vývojář bokem před tím, než vzniklý kód ke stránce připojí.

Použitím WebAssembly se nám otevírají dvě hlavní nové možnosti:

- spuštění existujícího kódu, který je psaný v&nbsp;jiném jazyce, v&nbsp;rámci webové stránky;

- vytvoření aplikace či knihovny, kterou vykoná prohlížeč bez nutnosti parsování a&nbsp;vykonávání JavaScriptu (vyšší výkon, předvídatelné chování napříč prohlížeči).

U&nbsp;velkých webových aplikací není neobvyklé, když některé jejich součásti tvoří JavaScript (zejména ty, které pracují s&nbsp;uživatelským rozhraním) a&nbsp;jiné zase Web&shy;Assembly (třeba ty, které provádí komplikované operace nad velkým množstvím dat). Je ovšem dobré poznamenat, že práce s&nbsp;WebAssembly je komplikovaná a&nbsp;vyplatí se jen tam, kde potřebujeme maximální výkon nebo musíme spolupracovat s&nbsp;existujícím ne-JavaScriptovým kódem. Když se chceme touto cestou vydat, čekají nás především tyto kroky:

1. Zvolit vhodný zdrojový programovací jazyk. Musí k&nbsp;němu existovat takový kompilátor, který dokáže vygenerovat výstup v&nbsp;jazyce WebAssembly, tj. soubory s&nbsp;příponou `wasm`.

1. V&nbsp;rámci běžného klientského JavaScriptu načíst vzniklé `wasm` soubory (typicky pomocí `fetch`).

1. Dodat potřebný podpůrný kód (tzv. *glue code*), který poskytne přemostění mezi logikou WebAssembly a&nbsp;světem klientského JavaScriptu. Pokud například ve WebAssembly chceme načítat data (po síti nebo ze souborů), musíme tuto logiku dodat formou běžných JavaScriptových funkcí. Naopak, načtené WebAssembly funkce budeme chtít jistě volat z&nbsp;normálního JavaScriptu a&nbsp;předávat jim data uložená v&nbsp;JS proměnných.

V&nbsp;rámci této knihy se na WebAssembly podíváme jen v&nbsp;tom nejjednodušším příkladu. Vytvoříme funkci v&nbsp;jazyce C, zkompilujeme ji do WebAssembly a&nbsp;následně ji zavoláme z&nbsp;JavaScriptu. Pro jazyk C existuje celá řada překladačů; my použijeme **Emcscripten**, který převádí C/C++ právě do WebAssembly.

Kód naší knihovny bude nabízet jedinou funkci `my_sqrt`, která implementuje celočíselnou odmocninu (a&nbsp;činí tak voláním funkce `sqrt` ze standardní knihovny `math.h`). Může vypada třeba takto:

```c
// my_sqrt.c

#include <math.h>
#include <emscripten.h>

EMSCRIPTEN_KEEPALIVE
int my_sqrt(int x) {
  return sqrt(x);
}
```

Makro `EMSCRIPTEN_KEEPALIVE` pochází z&nbsp;projektu překladače Emscripten, který musíme na svém operačním systému zprovoznit. Jeho účelem je označení těch funkcí, které chceme do výsledného WebAssembly exportovat a&nbsp;zachovat (chytrý překladač by jinak funkci odstranil, neboť v&nbsp;kódu není nikde volána). Jakmile máme Emscripten nainstalovaný, můžeme s&nbsp;ním tento kód zkompilovat:

```
emcc -O3 --no-entry my_sqrt.c -o my_sqrt.wasm
```

V&nbsp;ideálním případě vznikne soubor `my_sqrt.wasm`, který obsahuje danou funkci v&nbsp;binárním formátu WebAssembly. Přesuneme se do známějšího světa běžného JavaScriptu a&nbsp;tento soubor načteme:

```js
let response = await fetch("my_sqrt.wasm");
let ab = await response.arrayBuffer();
```

Dostáváme se k&nbsp;poslednímu kroku celé akce, totiž k&nbsp;propojení WebAssembly a&nbsp;JavaScriptu. Použijeme k&nbsp;tomu metodu `instantiate` z&nbsp;objektu `WebAssembly`:

```js
let wasm = await WebAssembly.instantiate(ab, {});
```

Druhý parametr je prázdný. Pokud by náš kód v&nbsp;C potřeboval přístup k&nbsp;některým JS funkcím, museli bychom mu je poskytnout právě v&nbsp;druhém parametru funkce `instantiate`. Exportovaná funkcionalita je pro nás nyní dostupná v&nbsp;proměnné `wasm`:

```js
let my_sqrt = wasm.instance.exports.my_sqrt;
console.log(42, my_sqrt(42));
```

Protože jsme použili celočíselnou verzi funkce `sqrt`, nepřekvapí nás, že vypsaná hodnota je šest -- výsledek je oříznut na nižší celé číslo. Pro potřeby ukázky se jedná o&nbsp;triviální funkcionalitu, snadno si ale představíme, že místo funkce `my_sqrt` můžeme exportovat složitou logiku, která provede třeba kódování videa, interakci s&nbsp;neuronovou sítí nebo hledání průchodu velkým grafem při plánování cesty na mapě.
