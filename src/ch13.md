# Kdy JavaScript nesta캜칤

V&nbsp;posledn칤 kapitole u nebudeme 콏e코it konkr칠tn칤 칰lohu, ale uk치쬰me si dal코칤 sm캩ry, kam se v&nbsp;r치mci prozkoum치v치n칤 klientsk칳ch webov칳ch technologi칤 m콢쬰me vyd치vat. Jakkoliv je toti JavaScript u쬴te캜n칳, samotn칳 n치m nedok치쬰 poskytnout v코e, co bychom mohli pot콏ebovat. Pod칤vejme se tedy na n캩kolik popul치rn칤ch knihoven a nadstaveb, se kter칳mi se praxi m콢쬰me setkat.


## Zelen치캜i: React

Pro mnoh칠 frontendov칠 v칳voj치콏e je knihovna React stejn캩 d콢le쬴t치, jako JavaScript samotn칳. Jedn치 se o&nbsp;n치stroj p콢vodn캩 vyvinut칳 pro intern칤 pot콏eby projektu Facebook, kter칳 se n치sledn캩 rychle roz코칤콏il po cel칠m internetu. React je ur캜en k&nbsp;tvorb캩 stromu str치nky ze vstupn칤ch dat. Takovou 칰lohu jsme v&nbsp;t칠to knize 콏e코ili n캩kolikr치t -- pou쬴li jsme k&nbsp;tomu bu캞 vestav캩n칳 HTML parser (tj. vlastnost `innerHTML`), nebo individu치ln칤 metody rozhran칤 DOM (jako nap콏. `document.createElement`). React vol칤 p콏칤stup koncep캜n캩 n캩kde mezi t캩mito dv캩ma variantami: strom str치nky vytv치콏칤me deklarativn캩 (jako kdybychom rovnou psali HTML), ale atributy a textov칠 uzly m콢쬰me generovat rovnou z&nbsp;JavaScriptov칳ch dat (jako kdybychom nastavovali atributy DOM objekt콢m).

D콢le쬴t칳m aspektem knihovny React je tzv. *virtual DOM*. P콏i pou쬴t칤 Reactu nech치v치me knihovnu vygenerovat v칳stup p콏i libovoln칠 zm캩n캩 ve vstupn칤ch datech, co zn칤 jako zbyte캜n치 pr치ce. React ale vznikl칠 HTML prvky negeneruje rovnou ve str치nce, ale v&nbsp;r치mci sv칠ho virtu치ln칤ho dokumentu. Do str치nky pak prom칤tne jen ty 칰pravy, kter칠 znamenaj칤 zm캩nu v&nbsp;opravdov칠m dokumentu.

React stav칤 zejm칠na na t캩chto konceptech:

- HTML v칳stup definujeme pomoc칤 **zna캜kovac칤ho jazyka JSX**, kter칳 HTML p콏ipom칤n치. Jedn치 se o&nbsp;mix HTML a JavaScriptu; podob치 se tak칠 trochu *template literals* (tyto 콏et캩zce jsme vid캩li v&nbsp;p치t칠 kapitole). React lze, striktn캩 vzato, pou쮂셨at i bez JSX, ale p콏ipravujeme se t칤m o&nbsp;zna캜n칠 mno쬽tv칤 funkcionality.
- Jednotliv칠 캜치sti k칩du organizujeme do tzv. **komponent**, kter칠 zodpov칤daj칤 za jednotliv칠 캜치sti stromu dokumentu. V&nbsp;jazyce JSX komponenty vypadaj칤 jjako HTML zna캜ky a n치padn캩 p콏ipom칤naj칤 *Custom Elements* (dev치t치 kapitola). Komponenty jsou typicky implementov치ny jako JavaScriptov칠 funkce.
- 칔kolem komponent (a Reactu jako takov칠ho) je prezentace dat. Tato jsou komponent치m v&nbsp;jazyce JSX p콏ed치v치na pomoc칤 atribut콢, kter칠 mohou -- v&nbsp;porovn치n칤 s&nbsp;HTML -- obsahovat libovoln칠 datov칠 typy.

React si m콢쬰me vyzkou코et na 칰loze z&nbsp;코est칠 kapitoly, ve kter칠 implementujeme zobrazov치n칤 v칳sledk콢 hled치n칤. Vysta캜칤me si s&nbsp;minim치ln칤m HTML dokumentem:

```html
<body><script src="index.js"></script></body>
```

Cel칠 HTML pl치nujeme vytv치콏et pomoc칤 Reactu. Budeme k&nbsp;tomu pou쮂셨at jazyk JSX, tak쬰 v칳sledn칳 skript `index.js` si na z치v캩r nech치me vygenerovat. M칤sto toho za캜neme vstupn칤m bodem aplikace v&nbsp;souboru `index.jsx`:

```jsx
// index.jsx
import React from "react";
import { createRoot } from "react-dom/client";
import App from "./App.jsx";


createRoot(document.body).render(<App />)
```

V캩t코ina reactov칳ch aplikac칤 vypad치 obdobn캩: pot콏ebujeme knihovnu React, d치le modul pro jeho p콏evod do HTML DOM a hlavn칤 komponentu, kter치 zast콏e코uje celou aplikaci. V&nbsp;parametru funkce `render` ji vid칤me jazyk JSX v&nbsp;akci, kdy vol치me komponentu `<App>`. Pod칤vejme se na jej칤 implementaci:

```jsx
// App.jsx
import React, { useState, useRef } from "react";
import Results from "./Results.jsx";


export default function App() {
	let [results, setResults] = useState([]);
	let [query, setQuery] = useState("");
	let inputRef = useRef();

	async function onSubmit(e) {
		e.preventDefault();
		let query = inputRef.current.value;
		let response = await fetch(`/search?query=${encodeURIComponent(query)}`);
		let results = await response.json();
		setQuery(query);
		setResults(results);
	}

	return <>
		<h1>Hled치n칤</h1>
		<form onSubmit={onSubmit}>
			<label>
				Hledan칳 v칳raz: <input type="text" ref={inputRef} />
			</label>
			<label>
				<button>游댍</button>
			</label>
		</form>
		<Results data={results} query={query} />
	</>;
}
```

Nenechme se zastra코it v캩t코칤m mno쬽tv칤m nezvykl칳ch konstrukc칤 a poj캞me si je po 캜치stech rozebrat. Posledn칤 캜치st funkce `App` definuje v칳sledn칠 HTML, resp. v칳sledn칠 JSX. To odpov칤d치 p콏칤stupu *komponenty jsou funkce, transformuj칤c칤 vstup na HTML*. Ka쬯치 komponenta mus칤 vr치tit jen jeden prvek, tak쬰 kdy chceme vykreslit v칤ce HTML (nadpis, formul치콏, v칳sledky), mus칤me je zabalit do spole캜n칠ho *bezejmenn칠ho* obalu, kter칳 se v&nbsp;JSX zapisuje jako `<>...</>`.

Na konci HTML pou쮂셨치me dal코칤 vlastn칤 komponentu (`<Results>`), ke kter칠 se dostaneme za chv칤li. Syntaxe se slo쬰n칳mi z치vorkami odpov칤d치 interpolaci hodnot z&nbsp;prom캩nn칳ch; z치pis

```jsx
<Results data={results} query={query} />
```

tedy znamen치, 쬰 zde chceme vykreslit zadanou komponentu a p콏edat j칤 obsah dvou lok치ln칤ch prom캩nn칳ch.

Samotn칠 hled치n칤 provede funkce `onSubmit`, kterou pro jednoduchost implementujeme pomoc칤 `fetch`. Je to poslucha캜 ud치losti, kter칳 v&nbsp;JSX p콏id치v치me atributem `onSubmit`. Uvnit콏 t칠to funkce pot콏ebujeme p콏istoupit k&nbsp;hodnot캩 z&nbsp;vyhled치vac칤ho pole. Nem콢쬰me pou쮂셦 b캩쬹칠 dotazov치n칤 pomoc칤 `querySelector`, nebo콘 celou tvorbu stromu DOMu za n치s 콏e코칤 React. K&nbsp;jednotliv칳m vytvo콏en칳m prvk콢m se ov코em m콢쬰me dostat pomoc칤 tzv. *referenc칤*. Lze si je p콏edstavit jako samolepky, kter칳mi pomoc칤 atributu `ref` ozna캜칤me prvky v&nbsp;JSX a d칤ky nim se pak dostaneme k&nbsp;vygenerovan칳m DOM objekt콢m.

Posledn칤 specialita v&nbsp;souboru `App.jsx` je funkce `useState`. P콏ipome켿me, 쬰 hlavn칤 칰kol Reactu je p콏ev칠st na코e data na HTML. Ide치ln캩 bychom r치di, aby se tato operace provedla v쬯y, kdy vstupn칤 data zm캩n칤me. Pouh치 zm캩na hodnoty v&nbsp;prom캩nn칠 (jako nap콏. `results`) k&nbsp;tomu ale nesta캜칤, proto쬰 React se o&nbsp;takov칠 zm캩n캩 nedozv칤. Zde vstupuje do hry funkce `useState`, kter치 vytvo콏칤 navz치jem prov치zanou dvojici prom캩nn칳ch: jednu pro hodnotu a jednu pro j칤 odpov칤daj칤c칤 funkci, ur캜enou ke zm캩n캩 hodnoty. Jakmile funkci zavol치me, hodnota se zm캩n칤 *a React dostane pokyn k&nbsp;p콏ekreslen칤*.

Pokra캜ujme ke komponent캩 `<Results>` v&nbsp;souboru `Results.jsx`:

```jsx
// Results.jsx
import React from "react";
import Result from "./Result.jsx";


export default function Results(props) {
	if (!props.query) {
		return;
	}

	if (!props.data.length) {
		return <p>Tomuto dotazu nevyhovuj칤 쮂멳n칠 p칤sn캩 游뗴</p>;
	}

	let items = props.data.map(item => <Result data={item} />);
	return <>
		<h2>Nalezen칠 p칤sn캩 pro dotaz: {props.query}</h2>
		<ol>{items}</ol>
	</>;
}
```

Zde 쮂멳n치 velk치 p콏ekvapen칤 nejsou. JSX atributy, kter칠 komponent캩 p콏ed치v치me, jsou v&nbsp;odpov칤daj칤c칤 JS funkci dostupn칠 jako vlastnosti objektu, p콏edan칠ho v&nbsp;prvn칤m parametru. B칳v치 obvykl칠 jej pojmenovat *props* (z&nbsp;anglick칠ho *properties*). Komponenta `<Results>` zast콏e코uje t콏i r콢zn칠 stavy (nebylo hled치no, nejsou v칳sledky, jsou v칳sledky), 캜emu odpov칤daj칤 jednotliv칠 podm칤nky. V&nbsp;p콏칤pad캩 nalezen칳ch v칳sledk콢 vid칤me cyklus realizovan칳 funkcion치ln칤 metodou `map`. To znamen치, 쬰 ve v칳sledn칠m JSX interpolujeme prom캩nnou `items`, kter치 je pole komponent typu `<Result>`. Ty jsou definov치ny v&nbsp;posledn칤m souboru `Result.jsx`:

```jsx
// Result.jsx
import React from "react";


export default function Result(props) {
	let html = {__html: props.data.text};
	return <li>
		<a href={props.data.url}>{props.data.title}</a>
		<br/>
		<span dangerouslySetInnerHTML={html} />
	</li>;
}
```

Vzpome켿me si na 코estou kapitolu, ve kter칠 jsme narazili na koncept `innerHTML` a jeho potenci치ln칤 d콢sledky pro bezpe캜nost aplikace. React se n치s sna쮂 od podobn칠ho postupu odradit, tak쬰 p콏칤m칠 vlo쬰n칤 HTML k칩du z&nbsp;prom캩nn칠 je nezvykle slo쬴t칠:

- Nejprve mus칤me nachystat objekt s&nbsp;kl칤캜em `__html`, jeho hodnota je n치코 콏et캩zec obsahuj칤c칤 (potenci치ln캩 rizikov칠) HTML.
- Pot칠 tento objekt p콏ed치me atributu `dangerouslySetInnerHTML`, jeho v칳mluvn칠 ozna캜en칤 varuje, 쬰 jde o&nbsp;nebezpe캜nou operaci.

Co d치l? Napsan칳 k칩d je docela slo쬴t칳 a prohl칤쬰캜 mu nerozum칤. Jednak nezn치 syntaxi JSX, jednak si neum칤 poradit se z치pisem `import React from "react"`. Budeme muset pou쮂셦 n캩jak칳 n치stroj, kter칳 JSX p콏evede na pou쬴teln칳 JavaScript.

Z&nbsp;minul칠 kapitoly zn치me program `esbuild` (pou쮂셨ali jsme jej k&nbsp;*bundlingu*). Te캞 se n치m hod칤, 쬰 `esbuild` dok치쬰 mimo jin칠 zpracov치vat soubory JSX a tak칠 pou쮂셨at z치vislosti z&nbsp;adres치콏e `node_modules`. Pou쬴jeme proto `npm` a nainstalujeme n캩kolik bal칤캜k콢:

```sh
npm i -g esbuild       # zpracov치n칤 JSX, bundling
npm i react react-dom  # sou캜치sti reactu
```

N치stroj `esbuild` instalujeme glob치ln캩, zat칤mco React a React-DOM do `node_modules`. Te캞 zbyv치 jen vygenerovat celou aplikaci:

```sh
esbuild --bundle index.jsx --outfile=index.js
```

Na z치v캩r poznamenejme, 쬰 kompilace z&nbsp;JSX do JS je dnes dostupn치 prost콏ednictv칤m cel칠 콏ady program콢. Krom캩 zmi켿ovan칠ho `esbuild` se 캜asto pou쮂셨aj칤 alternativy jako `babel`, `swc`, `rollup` nebo `tsc`, kter칠mu se budeme v캩novat v&nbsp;n치sleduj칤c칤 podkapitole.


## Koum치ci: TypeScript

Poj캞me si nyn칤 prohl칠dnout dal코칤 jazyk, kter칳 je dnes s&nbsp;JavaScriptem neodmysliteln캩 spojen. TypeScript vznikl jako nadmno쬴na JavaScriptu, ve kter칠 m콢쬰me k&nbsp;prom캩nn칳m a funkc칤m voliteln캩 p콏id치vat informace o&nbsp;jejich datov칠m typu. 콎칤k치 se jim *typov칠 anotace* a m콢쬰me je zn치t i z&nbsp;dal코칤ch jazyk콢, jako nap콏. Python 캜i PHP. V&nbsp;JavaScriptu v코ak typov칠 anotace neexistuj칤, tak쬰 k칩d psan칳 v&nbsp;TypeScriptu nem콢쬰me rovnou p콏edhodit prohl칤쬰캜i. Podobn캩 jako u&nbsp;JSX je nutn칠 nejprve k칩d p콏ev칠st na JavaScript. Tentokr치t je ale p콏evod velmi snadn칳, proto쬰 zahrnuje pouze smaz치n칤 typov칳ch anotac칤.

A&nbsp;pro캜 to cel칠 vlastn캩 chceme d캩lat? TypeScript je odpov캩d칤 na dynamick칠 typov치n칤 JavaScriptu, kter칠 je pro mnoho v칳voj치콏콢 a p콏칤li코 flexibiln칤. Kv콢li n캩mu nelze rychl칳m pohledem na prom캩nnou 캜i funkci odhadnout, jak칳ch hodnot m콢쬰 nab칳vat. Snadno se pak vystavujeme riziku, 쬰 budeme n캩jakou hodnotu myln캩 pova쬺vat za jin칳 datov칳 typ a dopust칤me se r콢zn칳ch chyb (nap콏. v칳jimek zp콢sobuj칤c칤ch p콏eru코en칤 b캩hu programu).

S&nbsp;typov칳mi anotacemi se v&nbsp;TypeScriptu setk치v치me dvakr치t. Kdy p콏ev치d칤me k칩d z&nbsp;TypeScriptu do JavaScriptu, kompil치tor anotace nejen odstran칤, ale tak칠 s&nbsp;jejich pomoc칤 zkontroluje, zdali neporu코ujeme jimi definovan치 pravidla -- jesti t콏eba do prom캩nn칠 ozna캜en칠 jako *string* nevkl치d치me 캜칤slo. Z치rove켿 ale anotace pou쮂셨치me ji p콏i samotn칠m psan칤 k칩du, pokud si spr치vn캩 nastav칤me editor. Ten m콢쬰 na z치klad캩 typov칳ch informac칤 rovnou ozna캜ovat bloky problematick칠ho k칩du, p콏칤padn캩 napov칤dat typy a n치zvy parametr콢 funkc칤 a podobn캩.

Zdrojov칳 k칩d v&nbsp;TypeScriptu p칤코eme do soubor콢 s&nbsp;p콏칤ponou `.ts`. Nej캜ast캩ji se typov칠 anotace objevuj칤 za dvojte캜kou, za n치zvem prom캩nn칠 캜i parametru funkce. M콢쬰me si to vyzkou코et na p콏칤kladu trivi치ln칤 s캜칤tac칤 funkce:

```ts
// test.ts
function add(a: number, b: number): number {
	return a+b;
}
```

Typov칠 anotace jsme p콏idali jak k&nbsp;ob캩ma parametr콢m, tak k&nbsp;funkci jako takov칠 -- 콏칤k치me t칤m, 쬰 jej칤 n치vratov치 hodnota je 캜칤slo. Na chov치n칤 k칩du anotace nemaj칤 쮂멳n칳 vliv, tak쬰 pokud bychom funkci p콏edali dva 콏et캩zce, dojde k&nbsp;jejich (pravd캩podobn캩 chybn칠mu) spojen칤. Proto bychom r치di, aby n치s n캩jak치 komponenta zav캜asu (na z치klad캩 anotac칤) upozornila, 쬰 funkci vol치me 코patn캩. Nejprve nap칤코eme probl칠mov칳 k칩d:

```ts
let a = "prot콏epat";
let b = "nem칤chat";
let c = add(a, b);
```

Dob콏e nastaven칠 v칳vojov칠 prost콏ed칤 by n치s u nyn칤 m캩lo varovat, 쬰 funkci vol치me chybn캩. My ale stoj칤me o&nbsp;kontrolu spojenou s&nbsp;p콏evodem do prost칠ho JavaScriptu. K&nbsp;tomu pou쬴jeme ofici치ln칤 kompil치tor *tsc* (TypeScript Compiler). Nainstalujeme jej pomoc칤 npm:

```sh
npm i -g typescript
```

Pro spu코t캩n칤 kompilace sta캜칤 p콏edat jm칠no souboru s&nbsp;TypeScriptov칳m k칩dem:

```sh
tsc test.ts

test.ts:6:13 - error TS2345: Argument of type 'string' is not assignable to parameter of type 'number'.
```

Dostali jsme vynad치no p콏esn캩 dle o캜ek치v치n칤. Z치rove켿 s&nbsp;t칤m ale vznikl soubor `test.js`, kter칳 obsahuje n치코 chybn칳 k칩d bez anotac칤. Kompil치tor n치m tedy nebr치n칤 v&nbsp;psan칤 pochybn칠ho k칩du, ale pokud mu k&nbsp;tomu d치me p콏칤le쬴tost, upozorn칤 n치s na problematick치 m칤sta.

Mimochodem: v&nbsp;minul칳ch kapitol치ch a podkapitol치ch jsme pou쮂셨ali n치stroj `esbuild`, kter칳 mj. prov치d칤 *bundling* a transpilaci JSX. Zv칤dav칠ho 캜ten치콏e mo쬹치 napadne, zdali by pomoc칤 `esbuild` ne코el kompilovat i zdrojov칳 k칩d v&nbsp;TypeScriptu. Odpov캩캞 je *ano, ale* -- proto쬰 esbuild sice dovede odstranit typov칠 anotace, ale neprovede p콏i tom typovou kontrolu. Dost치v치me tak jen polovinu funkcionality, kterou n치m nab칤z칤 `tsc`.

Jazyk TypeScript je od po캜치tku zam칳코len pro dobrovoln칠, pozvoln칠 vylep코ov치n칤 JavaScriptov칠ho k칩du. Pokud m치me hotov칳 projekt a r치di bychom do n캩j TypeScript zavedli, m콢쬰me tak 캜init po mal칳ch kr콢캜c칤ch bez obav, 쬰 n캩co pokaz칤me. Program `tsc` lze vykonat i nad k칩dem, ve kter칠m typov칠 anotace v콢bec nejsou, nebo jsme je doplnili jen ob캜asn캩. Sou캜치st칤 TypeScriptu je toti tzv. *typov치 inference*, co znamen치 schopnost kompil치toru domyslet si v&nbsp;콏ad캩 p콏칤pad콢 datov칠 typy podle toho, jak칳m zp콢sobem s&nbsp;prom캩nn칳mi pracujeme. Pokud nap콏칤klad do prom캩nn칠 p콏i definici rovnou p콏i콏ad칤me hodnotu, TypeScript odvod칤 jej칤 datov칳 typ a bude s&nbsp;n칤m pracovat p콏i dal코칤ch manipulac칤ch s&nbsp;touto prom캩nnou:

```js
let a = "ahoj";
a = 42;  // Warning: Type 'number' is not assignable to type 'string'.
```

Stejn캩 jako v&nbsp;minul칠 podkapitole, i nyn칤 m콢쬰me zkusit upravit vzorov칳 k칩d z&nbsp;코est칠 kapitoly. Pot콏ebujeme doplnit typov칠 anotace tak, aby byl jasn칳 datov칳 typ ka쬯칠 prom캩nn칠 a aby kompil치tor nehl치sil 쮂멳nou chybu. Hlavn칤 data, se kter칳mi pracujeme, jsou v칳sledky hled치n칤. Na z치klad캩 dohody s&nbsp;backendovou stranou aplikace v칤me, 쬰 se bude jednat o&nbsp;slovn칤k s&nbsp;konkr칠tn칤mi polo쬶ami. Takov칳 datov칳 typ m콢쬰me v&nbsp;TypeScriptu vyj치d콏it kl칤캜ov칳m slovem `interface`:

```ts
interface Song {
	url: string;
	title: string;
	text: string;
}

function buildSong(song: Song) {
	let item = document.createElement("li");
	item.innerHTML = `<a href="${song.url}">${song.title}</a> <br/> ${song.text}`;
	return item;
}
```

D치le p콏id치me typov칠 informace do funkce, kter치 je zodpov캩dn치 za zpracov치n칤 a zobrazen칤 v칳sledk콢 hled치n칤:

```ts
function showResults(xhr: XMLHttpRequest, query: string) {
	let results = document.querySelector("#results");
	if (!results) { return; }

	let songs = xhr.response as Song[];
	if (songs.length == 0) {
		results.replaceChildren("Tomuto dotazu nevyhovuj칤 쮂멳n칠 p칤sn캩 游뗴");
		return;
	}

	let heading = document.createElement("h2");
	heading.textContent = `Nalezen칠 p칤sn캩 pro dotaz: ${query}`;

	let ol = document.createElement("ol");
	results.replaceChildren(heading, ol);

	for (let i=0; i<songs.length; i++) {
		let song = buildSong(songs[i]);
		ol.append(song);
	}
}
```

TypeScript je obezn치men s&nbsp;vestav캩n칳mi objekty rozhran칤 DOM, tak쬰 u&nbsp;prvn칤ho parametru m콢쬰me rovnou ps치t `xhr: XMLHttpRequest`. Dal코칤 d콢le쬴t치 novinka se objevuje hned na prvn칤m 콏치dku funkce `showResults`, kdy je nutn칠 v캩novat v칤ce pozornosti metod캩 `querySelector`. M콢쬰 se toti snadno st치t, 쬰 tato metoda nevr치t칤 pou쬴telnou hodnotu -- kdy ve str치nce takov칳 prvek nen칤, nebo t콏eba kdy ud캩l치me p콏eklep v&nbsp;zadan칠m selektoru. Pokud chceme s&nbsp;prom캩nnou `results` nad치le pracovat, mus칤me m칤t jistotu, 쬰 je nepr치zdn치. Proto p콏id치me na dal코칤 콏치dek podm칤nku a vykon치v치n칤 p콏칤padn캩 ukon캜칤me.

Hodnota `xhr.response` m콢쬰 b칳t jak치koliv, nebo콘 z&nbsp;na코eho k칩du neum칤me ovlivnit data, kter치 server vygeneruje. Nem치me proto 쮂멳nou jistotu, 쬰 prom캩nn치 `songs` je opravdu pole struktur typu `Song`. Z치pisem `as Song[]` kompil치toru 콏칤k치me, a콘 pro pot콏eby kontroly typ콢 p콏edpokl치d치, 쬰 tomu tak opravdu je. Kdybychom cht캩li, mohli bychom je코t캩 dodat explicitn칤 k칩d, kter칳 by p콏칤choz칤 data pro코el a zkontroloval.

Zb칳v치 vylep코en칤 posledn칤 캜치sti k칩du, kdy reagujeme na odesl치n칤 hledac칤ho formul치콏e. Jedn치 se o&nbsp;poslucha캜 ud치losti `submit`:

```ts
function onSubmit(e: Event) {
	e.preventDefault();
	let xhr = new XMLHttpRequest();
	let input = form.querySelector<HTMLInputElement>("[name=query]");
	if (!input) { return; }
	let query = input.value;
	let url = `/search?query=${encodeURIComponent(query)}`;
	xhr.responseType = "json";
	xhr.open("GET", url);
	xhr.send();
	xhr.addEventListener("load", e => showResults(xhr, query));
}
```

Krom캩 kontroly n치vratov칠 hodnoty `querySelector` zde nar치쮂셠e na dal코칤 komplikaci. R콢zn칠 HTML prvky maj칤 r콢zn칠 JavaScriptov칠 vlastnosti, tak쬰 jednou n치m funkce `querySelector` m콢쬰 vr치tit t콏eba obr치zek (ten m치 mj. vlastnost `src`), zat칤mco jindy vr치t칤 prvek `<input>` (kter칳 m치 vlastnost `.value`). TypeScriptov칳 kompil치tor je v&nbsp;tomto sm캩ru bezradn칳, tak쬰 mu napov칤me pomoc칤 tzv. *typov칠ho parametru*. Z치pisem `querySelector<HTMLInputElement>` 콏칤k치me, 쬰 po캜칤t치me s&nbsp;t칤m, 쬰 n치vratov치 hodnota bude zadan칠ho typu (a proto je v&nbsp;po콏치dku u&nbsp;n칤 n치sledn캩 pracovat s&nbsp;vlastost칤 `.value`).

칔pln캩 na konec p콏id치me poslucha캜 na formul치콏 a p콏i tom si uk치쬰me je코t캩 jeden syntaktick칳 prvek ze sv캩ta TypeScriptu:

```ts
let form = document.querySelector("form")!;
form.addEventListener("submit", onSubmit);
```

V칤me, 쬰 funkce `querySelector` vrac칤 bu캞 HTML prvek, nebo `null`. Vyk콏i캜n칤kem 콏칤k치me, a콘 TypeScript mo쬹ost s&nbsp;`null` neuva쬿je. I&nbsp;zde bychom mohli prost캩 pou쮂셦 podm칤nku (n치코 k칩d by byl robustn캩j코칤!), ale vytvo콏ili bychom tak komplikaci pro ji upraven칳 poslucha캜 `onSubmit`. V&nbsp;n캩m se toti, d칤ky uz치v캩콏e, s&nbsp;prom캩nnou `form` takt칠 pracuje. Kdyby jej칤 hodnota nebyla jist치, museli bychom s&nbsp;n칤 opatrn캩 pracovat i uvnit콏e poslucha캜e. My jako program치to콏i v칤me, 쬰 pokud se poslucha캜 vykon치, prom캩nn치 `form` existuje -- TypeScript to ale za n치s vymyslet nedok치쬰.


## Prof칤ci: WebAssembly

Programovac칤ch jazyk콢 je kolem n치s velk칠 mno쬽tv칤, a p콏esto je mo쬹칠 v&nbsp;r치mci webov칠ho prohl칤쬰캜e ps치t aplika캜n칤 k칩d jen v&nbsp;JavaScriptu. 콎칤k치me si, proc nem치me k&nbsp;dispozici i dal코칤 mo쬹osti, jako nap콏칤klad Python, Go nebo t콏eba Ruby. Jakkoliv by bylo zaveden칤 dal코칤ho jazyka do prohl칤쬰캜e praktick칠, jedn치 se o&nbsp;p콏칤li코 komplikovan칳 칰kol -- znamenalo by to, 쬰 v코echny prohl칤쬰캜e mus칤 p콏ij칤t s&nbsp;identickou implementac칤 zvolen칠ho jazyka a z치rove켿 pro n캩j poskytovat v코echna rozhran칤, se kter칳mi jsme v&nbsp;JavaScriptu navykl칤 pracovat (DOM, pr치ce se s칤t칤, Canvas, Web Audio, &hellip;).

Nam칤sto integrace n캩jak칠ho dal코칤ho konkr칠tn칤ho programovac칤ho jazyka je pro n치s ov코em dostupn치 trochu jin치 mo쬹ost: prohl칤쬰캜e dok치쬺u zpracov치vat k칩d ve speci치ln칤m tvaru *WebAssembly*. Jde o&nbsp;bin치rn칤 form치t, kter칳 popisuje jednotliv칠 instrukce procesoru, a v&nbsp;porovn치n칤 s&nbsp;JavaScriptem je tedy velmi n칤zko칰rov켿ov칳. Jeho v칳hoda tkv칤 v&nbsp;tom, 쬰 do WebAssembly lze kompilovat programy psan칠 v&nbsp;cel칠 콏ad캩 jin칳ch jazyk콢, zejm칠na C, C++ a Rust. V&nbsp;prohl칤쬰캜i pak nemus칤 existovat implementace t캩chto jazyk콢 -- p콏evod do WebAssembly mus칤 prov칠st v칳voj치콏 bokem p콏ed t칤m, ne vznikl칳 k칩d ke str치nce p콏ipoj칤.

Pou쬴t칤m WebAssembly se n치m otev칤raj칤 dv캩 hlavn칤 nov칠 mo쬹osti:

- spu코t캩n칤 existuj칤c칤ho k칩du, psan칠ho v&nbsp;jin칠m jazyce, v&nbsp;r치mci webov칠 str치nky;
- vytvo콏en칤 aplikace 캜i knihovny, kterou vykon치 prohl칤쬰캜 bez nutnosti parsov치n칤 a vykon치v치n칤 JavaScriptu (vy코코칤 v칳kon, p콏edv칤dateln칠 chov치n칤 nap콏칤캜 prohl칤쬰캜i).

U&nbsp;velk칳ch webov칳ch aplikac칤 nen칤 neobvykl칠, kdy n캩kter칠 jejich sou캜치sti tvo콏칤 JavaScript (zejm칠na ty, kter칠 pracuj칤 s&nbsp;u쬴vatelsk칳m rozhran칤m) a jin칠 zase WebAssembly (t콏eba ty, kter칠 prov치d칤 komplikovan칠 operace nad velk칳m mno쬽tv칤m dat). Je ov코em dobr칠 poznamenat, 쬰 pr치ce s&nbsp;WebAssembly je komplikovan치 a vyplat칤 se jen tam, kde pot콏ebujeme maxim치ln칤 v칳kon, nebo mus칤me spolupracovat s&nbsp;existuj칤c칤m ne-JavaScriptov칳m k칩dem. Kdy se chceme touto cestou vydat, 캜ekaj칤 n치s p콏edev코칤m tyto kroky:

1. Zvolit vhodn칳 zdrojov칳 programovac칤 jazyk. Mus칤 k&nbsp;n캩mu existovat takov칳 kompil치tor, kter칳 dok치쬰 vygenerovat v칳stup v&nbsp;jazyce WebAssembly, tj. soubory s&nbsp;p콏칤ponou `wasm`.
1. V&nbsp;r치mci b캩쬹칠ho klientsk칠ho JavaScriptu na캜칤st vznikl칠 `wasm` soubory (typicky pomoc칤 `fetch`).
1. Dodat pot콏ebn칳 podp콢rn칳 k칩d (tzv. *glue code*), kter칳 poskytne p콏emost캩n칤 mezi logikou WebAssembly a sv캩tem klientsk칠ho JavaScriptu. Pokud nap콏칤klad ve WebAssembly chceme na캜칤tat data (po s칤ti nebo ze soubor콢), mus칤me tuto logiku dodat formou b캩쬹칳ch JavaScriptov칳ch funkc칤. Naopak, na캜ten칠 WebAssembly funkce budeme cht칤t jist캩 volat z&nbsp;norm치ln칤ho JavaScriptu a p콏ed치vat jim data ulo쬰n치 v&nbsp;JS prom캩nn칳ch.

V&nbsp;r치mci t칠to knihy se na WebAssembly pod칤v치me jen v&nbsp;tom nejjednodu코코칤m p콏칤kladu. Vytvo콏칤me funkci v&nbsp;jazyce C, zkompilujeme ji do WebAssembly a n치sledn캩 ji zavol치me z&nbsp;JavaScriptu. Pro jazyk C existuje cel치 콏ada p콏eklada캜콢; my pou쬴jeme *Emcscripten*, kter칳 p콏ev치d칤 C/C++ pr치v캩 do WebAssembly.

K칩d na코칤 knihovny bude nab칤zet jedinou funkci `my_sqrt`, kter치 implementuje celo캜칤selnou odmocninu (a 캜in칤 tak vol치n칤m funkce `sqrt` ze standardn칤 knihovny `math.h`). M콢쬰 vypada t콏eba takto:

```c
// my_sqrt.c

#include <math.h>
#include <emscripten.h>

EMSCRIPTEN_KEEPALIVE
int my_sqrt(int x) {
  return sqrt(x);
}
```

Makro `EMSCRIPTEN_KEEPALIVE` poch치z칤 z&nbsp;projektu p콏eklada캜e Emscripten, kter칳 mus칤me na sv칠m opera캜n칤m syst칠mu zprovoznit. Jeho 칰캜elem je ozna캜en칤 t캩ch funkc칤, kter칠 chceme do v칳sledn칠ho WebAssembly exportovat a zachovat (chytr칳 p콏eklada캜 by jinak funkci odstranil, nebo콘 v&nbsp;k칩du nen칤 nikde vol치na). Jakmile m치me Emscripten nainstalovan칳, m콢쬰me s&nbsp;n칤m tento k칩d zkompilovat:

```
emcc -O3 --no-entry my_sqrt.c -o my_sqrt.wasm
```

V&nbsp;ide치ln칤m p콏칤pad캩 vznikne soubor `my_sqrt.wasm`, kter칳 obsahuje danou funkci v&nbsp;bin치rn칤m form치tu WebAssembly. P콏esuneme se do zn치m캩j코칤ho sv캩ta b캩쬹칠ho JavaScriptu a tento soubor na캜teme:

```js
let response = await fetch("my_sqrt.wasm");
let ab = await response.arrayBuffer();
```

Dost치v치me se k&nbsp;posledn칤mu kroku cel칠 akce, toti k&nbsp;propojen칤 WebAssembly a JavaScriptu. Pou쬴jeme k&nbsp;tomu metodu `instantiate` z&nbsp;objektu `WebAssembly`:

```js
let wasm = await WebAssembly.instantiate(ab, {});
```

Druh칳 parametr je pr치zdn칳. Pokud by n치코 k칩d v&nbsp;C pot콏eboval p콏칤stup k&nbsp;n캩kter칳m JS funkc칤m, poskytli bychom mu je pr치v캩 v&nbsp;druh칠m parametru funkce `instantiate`. Exportovan치 funkcionalita je pro n치s nyn칤 dostupn치 v&nbsp;prom캩nn칠 `wasm`:

```js
let my_sqrt = wasm.instance.exports.my_sqrt;
console.log(42, my_sqrt(42));
```

Proto쬰 jsme pou쬴li celo캜칤selnou verzi funkce `sqrt`, nep콏ekvap칤 n치s, 쬰 vypsan치 hodnota je 코est -- v칳sledek je o콏칤znut na ni쮄뫆 cel칠 캜칤slo. Pro pot콏eby uk치zky se jedn치 o&nbsp;trivi치ln칤 funkcionalitu, snadno si ale p콏edstav칤me, 쬰 m칤sto funkce `my_sqrt` m콢쬰me exportovat slo쬴tou logiku, kter치 provede t콏eba k칩dov치n칤 videa, interakci s&nbsp;neuronovou s칤t칤 nebo proch치zen칤 velk칳m grafem p콏i pl치nov치n칤 cesty na map캩.
