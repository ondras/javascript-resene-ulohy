# KdyÅ¾ JavaScript nestaÄÃ­

V&nbsp;pÅ™edposlednÃ­ kapitole uÅ¾ nebudeme Å™eÅ¡it konkrÃ©tnÃ­ Ãºlohu, ale ukÃ¡Å¾eme si dalÅ¡Ã­ smÄ›ry, kam se v&nbsp;rÃ¡mci prozkoumÃ¡vÃ¡nÃ­ klientskÃ½ch webovÃ½ch technologiÃ­ mÅ¯Å¾eme vydÃ¡vat. Jakkoliv je totiÅ¾ JavaScript uÅ¾iteÄnÃ½, samotnÃ½ nÃ¡m nedokÃ¡Å¾e poskytnout vÅ¡e, co bychom mohli potÅ™ebovat. PodÃ­vejme se tedy na nÄ›kolik populÃ¡rnÃ­ch knihoven a&nbsp;nadstaveb, se kterÃ½mi se praxi mÅ¯Å¾eme setkat.


## ZelenÃ¡Äi: React

Pro mnohÃ© frontendovÃ© vÃ½vojÃ¡Å™e je knihovna React stejnÄ› dÅ¯leÅ¾itÃ¡, jako JavaScript samotnÃ½. JednÃ¡ se o&nbsp;nÃ¡stroj pÅ¯vodnÄ› vyvinutÃ½ pro internÃ­ potÅ™eby projektu Facebook, kterÃ½ se nÃ¡slednÄ› rychle rozÅ¡Ã­Å™il po celÃ©m internetu. React je urÄen k&nbsp;tvorbÄ› stromu strÃ¡nky ze vstupnÃ­ch dat. Takovou Ãºlohu jsme v&nbsp;tÃ©to knize Å™eÅ¡ili nÄ›kolikrÃ¡t -- pouÅ¾ili jsme k&nbsp;tomu buÄ vestavÄ›nÃ½ HTML parser (tj. vlastnost `innerHTML`), nebo individuÃ¡lnÃ­ metody dostupnÃ© v&nbsp;rozhranÃ­ DOM (jako napÅ™. `document.createElement`). React volÃ­ pÅ™Ã­stup koncepÄnÄ› nÄ›kde mezi tÄ›mito dvÄ›ma variantami: strom strÃ¡nky vytvÃ¡Å™Ã­me deklarativnÄ› (jako kdybychom rovnou psali HTML), ale atributy a&nbsp;textovÃ© uzly mÅ¯Å¾eme generovat rovnou z&nbsp;JavaScriptovÃ½ch dat (jako kdybychom nastavovali atributy DOM objektÅ¯m).

DÅ¯leÅ¾itÃ½m aspektem knihovny React je tzv. **virtual DOM**. PÅ™i pouÅ¾itÃ­ Reactu nechÃ¡vÃ¡me knihovnu vygenerovat vÃ½stup pÅ™i libovolnÃ© zmÄ›nÄ› ve vstupnÃ­ch datech, coÅ¾ znÃ­ jako zbyteÄnÃ¡ prÃ¡ce. React ale vzniklÃ© HTML prvky negeneruje rovnou ve strÃ¡nce, ale v&nbsp;rÃ¡mci svÃ©ho virtuÃ¡lnÃ­ho dokumentu. Do strÃ¡nky pak promÃ­tne jen ty Ãºpravy, kterÃ© znamenajÃ­ zmÄ›nu v&nbsp;opravdovÃ©m dokumentu.

React stavÃ­ zejmÃ©na na tÄ›chto konceptech:

- HTML vÃ½stup definujeme pomocÃ­ **znaÄkovacÃ­ho jazyka JSX**, kterÃ½ HTML pÅ™ipomÃ­nÃ¡. JednÃ¡ se o&nbsp;mix HTML a&nbsp;JavaScriptu; podobÃ¡ se takÃ© trochu *template literals* (tyto Å™etÄ›zce jsme vidÄ›li v&nbsp;pÃ¡tÃ© kapitole). React lze, striktnÄ› vzato, pouÅ¾Ã­vat i&nbsp;bez JSX, ale pÅ™ipravujeme se tÃ­m o&nbsp;znaÄnÃ© mnoÅ¾stvÃ­ funkcionality.

- JednotlivÃ© ÄÃ¡sti kÃ³du organizujeme do tzv. **komponent**, kterÃ© zodpovÃ­dajÃ­ za jednotlivÃ© ÄÃ¡sti stromu dokumentu. V&nbsp;jazyce JSX komponenty vypadajÃ­ jako HTML znaÄky a&nbsp;nÃ¡padnÄ› pÅ™ipomÃ­najÃ­ *Custom Elements* (devÃ¡tÃ¡ kapitola). Komponenty jsou typicky implementovÃ¡ny jako JavaScriptovÃ© funkce.

- Ãškolem komponent (a&nbsp;Reactu jako takovÃ©ho) je prezentace dat. Tato jsou komponentÃ¡m v&nbsp;jazyce JSX pÅ™edÃ¡vÃ¡na pomocÃ­ atributÅ¯, kterÃ© mohou -- v&nbsp;porovnÃ¡nÃ­ s&nbsp;HTML -- obsahovat libovolnÃ© datovÃ© typy.

React si mÅ¯Å¾eme vyzkouÅ¡et na Ãºloze z&nbsp;Å¡estÃ© kapitoly, ve kterÃ© implementujeme zobrazovÃ¡nÃ­ vÃ½sledkÅ¯ hledÃ¡nÃ­. VystaÄÃ­me si s&nbsp;minimÃ¡lnÃ­m HTML dokumentem:

```html
<body><script src="index.js"></script></body>
```

CelÃ© HTML plÃ¡nujeme vytvÃ¡Å™et pomocÃ­ Reactu. Budeme k&nbsp;tomu pouÅ¾Ã­vat jazyk JSX, takÅ¾e vÃ½slednÃ½ skript `index.js` si na zÃ¡vÄ›r nechÃ¡me vygenerovat. MÃ­sto toho zaÄneme vstupnÃ­m bodem aplikace v&nbsp;souboru `index.jsx`:

```jsx
// index.jsx
import React from "react";
import { createRoot } from "react-dom/client";
import App from "./App.jsx";


createRoot(document.body).render(<App />);
```

VÄ›tÅ¡ina reactovÃ½ch aplikacÃ­ vypadÃ¡ obdobnÄ›: potÅ™ebujeme knihovnu React, dÃ¡le modul pro jeho pÅ™evod do HTML DOM a&nbsp;hlavnÃ­ komponentu, kterÃ¡ zastÅ™eÅ¡uje celou aplikaci. V&nbsp;parametru funkce `render` jiÅ¾ vidÃ­me jazyk JSX v&nbsp;akci, kdyÅ¾ volÃ¡me komponentu `<App>`. PodÃ­vejme se na jejÃ­ implementaci:

```jsx
// App.jsx
import React, { useState, useRef } from "react";
import Results from "./Results.jsx";


export default function App() {
	let [results, setResults] = useState([]);
	let [query, setQuery] = useState("");
	let inputRef = useRef();

	async function onSubmit(e) {
		e.preventDefault();
		let query = encodeURIComponent(inputRef.current.value);
		let response = await fetch(`/search?query=${query}`);
		let results = await response.json();
		setQuery(query);
		setResults(results);
	}

	return <>
		<h1>HledÃ¡nÃ­</h1>
		<form onSubmit={onSubmit}>
			<label>
				HledanÃ½ vÃ½raz: <input type="text" ref={inputRef} />
			</label>
			<label>
				<button>ğŸ”</button>
			</label>
		</form>
		<Results data={results} query={query} />
	</>;
}
```

Nenechme se zastraÅ¡it vÄ›tÅ¡Ã­m mnoÅ¾stvÃ­m nezvyklÃ½ch konstrukcÃ­ a&nbsp;pojÄme si je po ÄÃ¡stech rozebrat. PoslednÃ­ ÄÃ¡st funkce `App` definuje vÃ½slednÃ© HTML, resp. vÃ½slednÃ© JSX. To odpovÃ­dÃ¡ pÅ™Ã­stupu **komponenty jsou funkce, kterÃ© transformujÃ­ vstup na HTML**. KaÅ¾dÃ¡ komponenta musÃ­ vrÃ¡tit jen jeden prvek, takÅ¾e kdyÅ¾ chceme vykreslit vÃ­ce HTML (nadpis, formulÃ¡Å™, vÃ½sledky), musÃ­me je zabalit do spoleÄnÃ©ho *bezejmennÃ©ho* obalu, kterÃ½ se v&nbsp;JSX zapisuje jako `<>...</>`.

Na konci HTML pouÅ¾Ã­vÃ¡me dalÅ¡Ã­ vlastnÃ­ komponentu (`<Results>`), ke kterÃ© se dostaneme za chvÃ­li. Syntaxe se sloÅ¾enÃ½mi zÃ¡vorkami odpovÃ­dÃ¡ interpolaci hodnot z&nbsp;promÄ›nnÃ½ch; zÃ¡pis

```jsx
<Results data={results} query={query} />
```

tedy znamenÃ¡, Å¾e zde chceme vykreslit zadanou komponentu a&nbsp;pÅ™edat jÃ­ obsah dvou lokÃ¡lnÃ­ch promÄ›nnÃ½ch.

SamotnÃ© hledÃ¡nÃ­ provede funkce `onSubmit`, kterou pro jednoduchost implementujeme pomocÃ­ `fetch`. Je to posluchaÄ udÃ¡losti, kterÃ½ v&nbsp;JSX pÅ™idÃ¡vÃ¡me atributem `onSubmit`. UvnitÅ™ tÃ©to funkce potÅ™ebujeme pÅ™istoupit k&nbsp;hodnotÄ› z&nbsp;vyhledÃ¡vacÃ­ho pole. NemÅ¯Å¾eme pouÅ¾Ã­t bÄ›Å¾nÃ© dotazovÃ¡nÃ­ pomocÃ­ `querySelector`, neboÅ¥ celou tvorbu stromu DOMu za nÃ¡s Å™eÅ¡Ã­ React. K&nbsp;jednotlivÃ½m vytvoÅ™enÃ½m prvkÅ¯m se ovÅ¡em mÅ¯Å¾eme dostat pomocÃ­ tzv. *referencÃ­*. Lze si je pÅ™edstavit jako samolepky, kterÃ½mi pomocÃ­ atributu `ref` oznaÄÃ­me prvky v&nbsp;JSX a&nbsp;dÃ­ky nim se pak dostaneme k&nbsp;vygenerovanÃ½m DOM objektÅ¯m.

PoslednÃ­ specialita v&nbsp;souboru `App.jsx` je funkce `useState`. PÅ™ipomeÅˆme, Å¾e hlavnÃ­ Ãºkol Reactu je pÅ™evÃ©st naÅ¡e data na HTML. IdeÃ¡lnÄ› bychom rÃ¡di, aby se tato operace provedla vÅ¾dy, kdyÅ¾ vstupnÃ­ data zmÄ›nÃ­me. PouhÃ¡ zmÄ›na hodnoty v&nbsp;promÄ›nnÃ© (jako napÅ™. `results`) k&nbsp;tomu ale nestaÄÃ­, protoÅ¾e React se o&nbsp;takovÃ© zmÄ›nÄ› nedozvÃ­. Zde vstupuje do hry funkce `useState`, kterÃ¡ vytvoÅ™Ã­ navzÃ¡jem provÃ¡zanou dvojici promÄ›nnÃ½ch: jednu pro hodnotu a&nbsp;jednu pro jÃ­ odpovÃ­dajÃ­cÃ­ funkci, urÄenou ke zmÄ›nÄ› hodnoty. Jakmile funkci zavolÃ¡me, hodnota se zmÄ›nÃ­ *a React dostane pokyn k&nbsp;pÅ™ekreslenÃ­*.

PokraÄujme ke komponentÄ› `<Results>` v&nbsp;souboru `Results.jsx`:

```jsx
// Results.jsx
import React from "react";
import Result from "./Result.jsx";


export default function Results(props) {
	if (!props.query) {
		return;
	}

	if (!props.data.length) {
		return <p>Tomuto dotazu nevyhovujÃ­ Å¾Ã¡dnÃ© pÃ­snÄ› ğŸ™</p>;
	}

	let items = props.data.map(item => <Result data={item} />);
	return <>
		<h2>NalezenÃ© pÃ­snÄ› pro dotaz: {props.query}</h2>
		<ol>{items}</ol>
	</>;
}
```

Zde Å¾Ã¡dnÃ¡ velkÃ¡ pÅ™ekvapenÃ­ nejsou. JSX atributy, kterÃ© komponentÄ› pÅ™edÃ¡vÃ¡me, jsou v&nbsp;odpovÃ­dajÃ­cÃ­ JS funkci dostupnÃ© jako vlastnosti objektu, pÅ™edanÃ©ho v&nbsp;prvnÃ­m parametru. BÃ½vÃ¡ obvyklÃ© jej pojmenovat *props* (z&nbsp;anglickÃ©ho *properties*). Komponenta `<Results>` zastÅ™eÅ¡uje tÅ™i rÅ¯znÃ© stavy (nebylo hledÃ¡no, nejsou vÃ½sledky, jsou vÃ½sledky), ÄemuÅ¾ odpovÃ­dajÃ­ jednotlivÃ© podmÃ­nky. V&nbsp;pÅ™Ã­padÄ› nalezenÃ½ch vÃ½sledkÅ¯ vidÃ­me cyklus realizovanÃ½ funkcionÃ¡lnÃ­ metodou `map`. To znamenÃ¡, Å¾e ve vÃ½slednÃ©m JSX interpolujeme promÄ›nnou `items`, kterÃ¡ je pole komponent typu `<Result>`. Ty jsou definovÃ¡ny v&nbsp;poslednÃ­m souboru `Result.jsx`:

```jsx
// Result.jsx
import React from "react";


export default function Result(props) {
	let html = {__html: props.data.text};
	return <li>
		<a href={props.data.url}>{props.data.title}</a>
		<br/>
		<span dangerouslySetInnerHTML={html} />
	</li>;
}
```

VzpomeÅˆme si na Å¡estou kapitolu, ve kterÃ© jsme narazili na koncept `innerHTML` a&nbsp;jeho potenciÃ¡lnÃ­ dÅ¯sledky pro bezpeÄnost aplikace. React se nÃ¡s snaÅ¾Ã­ od podobnÃ©ho postupu odradit, takÅ¾e pÅ™Ã­mÃ© vloÅ¾enÃ­ HTML kÃ³du z&nbsp;promÄ›nnÃ© je nezvykle sloÅ¾itÃ©:

- Nejprve musÃ­me nachystat objekt s&nbsp;klÃ­Äem `__html`, jehoÅ¾ hodnota je nÃ¡Å¡ Å™etÄ›zec obsahujÃ­cÃ­ (potenciÃ¡lnÄ› rizikovÃ©) HTML.

- PotÃ© tento objekt pÅ™edÃ¡me atributu `dangerouslySetInnerHTML`, jehoÅ¾ vÃ½mluvnÃ© oznaÄenÃ­ varuje, Å¾e jde o&nbsp;nebezpeÄnou operaci.

Co dÃ¡l? NapsanÃ½ kÃ³d je docela sloÅ¾itÃ½ a&nbsp;prohlÃ­Å¾eÄ mu nerozumÃ­. Jednak neznÃ¡ syntaxi JSX, jednak si neumÃ­ poradit se zÃ¡pisem `import React from "react"`. Budeme muset pouÅ¾Ã­t nÄ›jakÃ½ nÃ¡stroj, kterÃ½ JSX pÅ™evede na pouÅ¾itelnÃ½ JavaScript.

Z&nbsp;minulÃ© kapitoly znÃ¡me program `esbuild` (pouÅ¾Ã­vali jsme jej k&nbsp;*bundlingu*). TeÄ se nÃ¡m hodÃ­, Å¾e `esbuild` dokÃ¡Å¾e mimo jinÃ© zpracovÃ¡vat soubory JSX a&nbsp;takÃ© pouÅ¾Ã­vat zÃ¡vislosti z&nbsp;adresÃ¡Å™e `node_modules`. PouÅ¾ijeme proto `npm` a&nbsp;nainstalujeme nÄ›kolik balÃ­ÄkÅ¯:

```sh
npm i -g esbuild       # zpracovÃ¡nÃ­ JSX, bundling
npm i react react-dom  # souÄÃ¡sti reactu
```

NÃ¡stroj `esbuild` instalujeme globÃ¡lnÄ›, zatÃ­mco React a&nbsp;React-DOM do `node_modules`. TeÄ zbÃ½vÃ¡ jen vygenerovat celou aplikaci:

```sh
esbuild --bundle index.jsx --outfile=index.js
```

Na zÃ¡vÄ›r poznamenejme, Å¾e kompilace z&nbsp;JSX do JS je dnes dostupnÃ¡ prostÅ™ednictvÃ­m celÃ© Å™ady programÅ¯. KromÄ› zmiÅˆovanÃ©ho `esbuild` se Äasto pouÅ¾Ã­vajÃ­ alternativy jako `babel`, `swc`, `rollup` nebo `tsc`, kterÃ©mu se budeme vÄ›novat v&nbsp;nÃ¡sledujÃ­cÃ­ podkapitole.


## KoumÃ¡ci: TypeScript

PojÄme si nynÃ­ prohlÃ©dnout dalÅ¡Ã­ jazyk, kterÃ½ je dnes s&nbsp;JavaScriptem neodmyslitelnÄ› spojen. TypeScript vznikl jako nadmnoÅ¾ina JavaScriptu, ve kterÃ© mÅ¯Å¾eme k&nbsp;promÄ›nnÃ½m a&nbsp;funkcÃ­m volitelnÄ› pÅ™idÃ¡vat informace o&nbsp;jejich datovÃ©m typu. Å˜Ã­kÃ¡ se jim **typovÃ© anotace** a&nbsp;mÅ¯Å¾eme je znÃ¡t i&nbsp;z&nbsp;dalÅ¡Ã­ch jazykÅ¯, jako napÅ™. Python Äi PHP. V&nbsp;JavaScriptu vÅ¡ak typovÃ© anotace neexistujÃ­, takÅ¾e kÃ³d psanÃ½ v&nbsp;TypeScriptu nemÅ¯Å¾eme rovnou pÅ™edhodit prohlÃ­Å¾eÄi. PodobnÄ› jako u&nbsp;JSX je nutnÃ© nejprve kÃ³d pÅ™evÃ©st na JavaScript. TentokrÃ¡t je ale pÅ™evod velmi snadnÃ½, protoÅ¾e typicky zahrnuje pouze smazÃ¡nÃ­ typovÃ½ch anotacÃ­.

A&nbsp;proÄ to celÃ© vlastnÄ› chceme dÄ›lat? TypeScript je odpovÄ›dÃ­ na dynamickÃ© typovÃ¡nÃ­ JavaScriptu, kterÃ© je pro mnoho vÃ½vojÃ¡Å™Å¯ aÅ¾ pÅ™Ã­liÅ¡ flexibilnÃ­. KvÅ¯li nÄ›mu nelze rychlÃ½m pohledem na promÄ›nnou Äi funkci odhadnout, jakÃ½ch hodnot mÅ¯Å¾e nabÃ½vat. Snadno se pak vystavujeme riziku, Å¾e budeme nÄ›jakou hodnotu mylnÄ› povaÅ¾ovat za jinÃ½ datovÃ½ typ a&nbsp;dopustÃ­me se rÅ¯znÃ½ch chyb (napÅ™. vÃ½jimek zpÅ¯sobujÃ­cÃ­ch pÅ™eruÅ¡enÃ­ bÄ›hu programu).

S&nbsp;typovÃ½mi anotacemi se v&nbsp;TypeScriptu setkÃ¡vÃ¡me dvakrÃ¡t. KdyÅ¾ pÅ™evÃ¡dÃ­me kÃ³d z&nbsp;TypeScriptu do JavaScriptu, kompilÃ¡tor anotace nejen odstranÃ­, ale takÃ© s&nbsp;jejich pomocÃ­ zkontroluje, zdali neporuÅ¡ujeme jimi definovanÃ¡ pravidla -- jestli tÅ™eba do promÄ›nnÃ© oznaÄenÃ© jako *string* nevklÃ¡dÃ¡me ÄÃ­slo. ZÃ¡roveÅˆ ale anotace pouÅ¾Ã­vÃ¡me jiÅ¾ pÅ™i samotnÃ©m psanÃ­ kÃ³du, pokud si sprÃ¡vnÄ› nastavÃ­me editor. Ten mÅ¯Å¾e na zÃ¡kladÄ› typovÃ½ch informacÃ­ rovnou oznaÄovat bloky problematickÃ©ho kÃ³du, pÅ™Ã­padnÄ› napovÃ­dat typy a&nbsp;nÃ¡zvy parametrÅ¯ funkcÃ­ a&nbsp;podobnÄ›.

ZdrojovÃ½ kÃ³d v&nbsp;TypeScriptu pÃ­Å¡eme do souborÅ¯ s&nbsp;pÅ™Ã­ponou `.ts`. NejÄastÄ›ji se typovÃ© anotace objevujÃ­ za dvojteÄkou, za nÃ¡zvem promÄ›nnÃ© Äi parametru funkce. MÅ¯Å¾eme si to vyzkouÅ¡et na pÅ™Ã­kladu triviÃ¡lnÃ­ sÄÃ­tacÃ­ funkce:

```ts
// test.ts
function add(a: number, b: number): number {
	return a+b;
}
```

TypovÃ© anotace jsme pÅ™idali jak k&nbsp;obÄ›ma parametrÅ¯m, tak k&nbsp;funkci jako takovÃ© -- Å™Ã­kÃ¡me tÃ­m, Å¾e jejÃ­ nÃ¡vratovÃ¡ hodnota je ÄÃ­slo. Na chovÃ¡nÃ­ kÃ³du anotace nemajÃ­ Å¾Ã¡dnÃ½ vliv, takÅ¾e pokud bychom funkci pÅ™edali dva Å™etÄ›zce, dojde k&nbsp;jejich (pravdÄ›podobnÄ› chybnÃ©mu) spojenÃ­. Proto bychom rÃ¡di, aby nÃ¡s nÄ›jakÃ¡ komponenta zavÄasu (na zÃ¡kladÄ› anotacÃ­) upozornila, Å¾e funkci volÃ¡me Å¡patnÄ›. Nejprve napÃ­Å¡eme problÃ©movÃ½ kÃ³d:

```ts
let a = "protÅ™epat";
let b = "nemÃ­chat";
let c = add(a, b);
```

DobÅ™e nastavenÃ© vÃ½vojovÃ© prostÅ™edÃ­ by nÃ¡s uÅ¾ nynÃ­ mÄ›lo varovat, Å¾e funkci volÃ¡me chybnÄ›. My nynÃ­ ale stojÃ­me o&nbsp;kontrolu spojenou s&nbsp;pÅ™evodem do prostÃ©ho JavaScriptu. K&nbsp;tomu pouÅ¾ijeme oficiÃ¡lnÃ­ kompilÃ¡tor **tsc** (TypeScript Compiler). Nainstalujeme jej pomocÃ­ npm:

```sh
npm i -g typescript
```

Pro spuÅ¡tÄ›nÃ­ kompilace staÄÃ­ pÅ™edat jmÃ©no souboru s&nbsp;TypeScriptovÃ½m kÃ³dem:

```sh
tsc test.ts

test.ts:6:13 - error TS2345: Argument of type 'string' is not assignable to parameter of type 'number'.
```

Dostali jsme vynadÃ¡no pÅ™esnÄ› dle oÄekÃ¡vÃ¡nÃ­. ZÃ¡roveÅˆ s&nbsp;tÃ­m ale vznikl soubor `test.js`, kterÃ½ obsahuje nÃ¡Å¡ chybnÃ½ kÃ³d bez anotacÃ­. KompilÃ¡tor nÃ¡m tedy nebrÃ¡nÃ­ v&nbsp;psanÃ­ pochybnÃ©ho kÃ³du, ale pokud mu k&nbsp;tomu dÃ¡me pÅ™Ã­leÅ¾itost, upozornÃ­ nÃ¡s na problematickÃ¡ mÃ­sta.

Mimochodem: v&nbsp;minulÃ½ch kapitolÃ¡ch a&nbsp;podkapitolÃ¡ch jsme pouÅ¾Ã­vali nÃ¡stroj `esbuild`, kterÃ½ mj. provÃ¡dÃ­ *bundling* a&nbsp;transpilaci JSX. ZvÃ­davÃ©ho ÄtenÃ¡Å™e moÅ¾nÃ¡ napadne, zdali by pomocÃ­ `esbuild` neÅ¡el kompilovat i&nbsp;zdrojovÃ½ kÃ³d v&nbsp;TypeScriptu. OdpovÄ›Ä je *ano, ale* -- protoÅ¾e esbuild sice dovede odstranit typovÃ© anotace, ale neprovede pÅ™i tom typovou kontrolu. DostÃ¡vÃ¡me tak jen polovinu funkcionality, kterou nÃ¡m nabÃ­zÃ­ `tsc`.

Jazyk TypeScript je od poÄÃ¡tku zamÃ½Å¡len pro dobrovolnÃ©, pozvolnÃ© vylepÅ¡ovÃ¡nÃ­ JavaScriptovÃ©ho kÃ³du. Pokud mÃ¡me hotovÃ½ projekt a&nbsp;rÃ¡di bychom do nÄ›j TypeScript zavedli, mÅ¯Å¾eme tak Äinit po malÃ½ch krÅ¯ÄcÃ­ch bez obav, Å¾e nÄ›co pokazÃ­me. Program `tsc` lze vykonat i&nbsp;nad kÃ³dem, ve kterÃ©m typovÃ© anotace vÅ¯bec nejsou, nebo jsme je doplnili jen obÄasnÄ›. SouÄÃ¡stÃ­ TypeScriptu je totiÅ¾ tzv. **typovÃ¡ inference**, coÅ¾ znamenÃ¡ schopnost kompilÃ¡toru domyslet si v&nbsp;Å™adÄ› pÅ™Ã­padÅ¯ datovÃ© typy podle toho, jakÃ½m zpÅ¯sobem s&nbsp;promÄ›nnÃ½mi pracujeme. Pokud napÅ™Ã­klad do promÄ›nnÃ© pÅ™i definici rovnou pÅ™iÅ™adÃ­me hodnotu, TypeScript odvodÃ­ jejÃ­ datovÃ½ typ a&nbsp;bude s&nbsp;nÃ­m pracovat pÅ™i dalÅ¡Ã­ch manipulacÃ­ch s&nbsp;touto promÄ›nnou:

```js
let a = "ahoj";
a = 42;  // Warning: Type 'number' is not assignable to type 'string'.
```

StejnÄ› jako v&nbsp;minulÃ© podkapitole, i&nbsp;nynÃ­ mÅ¯Å¾eme zkusit upravit vzorovÃ½ kÃ³d z&nbsp;Å¡estÃ© kapitoly. PotÅ™ebujeme doplnit typovÃ© anotace tak, aby byl jasnÃ½ datovÃ½ typ kaÅ¾dÃ© promÄ›nnÃ© a&nbsp;aby kompilÃ¡tor nehlÃ¡sil Å¾Ã¡dnou chybu. HlavnÃ­ data, se kterÃ½mi pracujeme, jsou vÃ½sledky hledÃ¡nÃ­. Na zÃ¡kladÄ› dohody s&nbsp;backendovou stranou aplikace vÃ­me, Å¾e se bude jednat o&nbsp;slovnÃ­k s&nbsp;konkrÃ©tnÃ­mi poloÅ¾kami. TakovÃ½ datovÃ½ typ mÅ¯Å¾eme v&nbsp;TypeScriptu vyjÃ¡dÅ™it klÃ­ÄovÃ½m slovem `interface`:

```ts
interface Song {
	url: string;
	title: string;
	text: string;
}

function buildSong(song: Song) {
	let item = document.createElement("li");
	item.innerHTML = `
		<a href="${song.url}">${song.title}</a>
		<br/> ${song.text}
	`;
	return item;
}
```

DÃ¡le pÅ™idÃ¡me typovÃ© informace do funkce, kterÃ¡ je zodpovÄ›dnÃ¡ za zpracovÃ¡nÃ­ a&nbsp;zobrazenÃ­ vÃ½sledkÅ¯ hledÃ¡nÃ­:

```ts
function showResults(xhr: XMLHttpRequest, query: string) {
	let results = document.querySelector("#results");
	if (!results) { return; }

	let songs = xhr.response as Song[];
	if (songs.length == 0) {
		results.replaceChildren("Dotazu nevyhovujÃ­ Å¾Ã¡dnÃ© pÃ­snÄ› ğŸ™");
		return;
	}

	let heading = document.createElement("h2");
	heading.textContent = `NalezenÃ© pÃ­snÄ› pro dotaz: ${query}`;

	let ol = document.createElement("ol");
	results.replaceChildren(heading, ol);

	for (let i=0; i<songs.length; i++) {
		let song = buildSong(songs[i]);
		ol.append(song);
	}
}
```

TypeScript je obeznÃ¡men s&nbsp;vestavÄ›nÃ½mi objekty rozhranÃ­ DOM, takÅ¾e u&nbsp;prvnÃ­ho parametru mÅ¯Å¾eme rovnou psÃ¡t `xhr: XMLHttpRequest`. DalÅ¡Ã­ dÅ¯leÅ¾itÃ¡ novinka se objevuje hned na prvnÃ­m Å™Ã¡dku funkce `showResults`, kdy je nutnÃ© vÄ›novat vÃ­ce pozornosti metodÄ› `querySelector`. MÅ¯Å¾e se totiÅ¾ snadno stÃ¡t, Å¾e tato metoda nevrÃ¡tÃ­ pouÅ¾itelnou hodnotu -- kdyÅ¾ ve strÃ¡nce takovÃ½ prvek nenÃ­, nebo tÅ™eba kdyÅ¾ udÄ›lÃ¡me pÅ™eklep v&nbsp;zadanÃ©m selektoru. Pokud chceme s&nbsp;promÄ›nnou `results` nadÃ¡le pracovat, musÃ­me mÃ­t jistotu, Å¾e je neprÃ¡zdnÃ¡. Proto pÅ™idÃ¡me na dalÅ¡Ã­ Å™Ã¡dek podmÃ­nku a&nbsp;vykonÃ¡vÃ¡nÃ­ pÅ™Ã­padnÄ› ukonÄÃ­me.

Hodnota `xhr.response` mÅ¯Å¾e bÃ½t jakÃ¡koliv, neboÅ¥ z&nbsp;naÅ¡eho kÃ³du neumÃ­me ovlivnit data, kterÃ¡ server vygeneruje. NemÃ¡me proto Å¾Ã¡dnou jistotu, Å¾e promÄ›nnÃ¡ `songs` je opravdu pole struktur typu `Song`. ZÃ¡pisem `as Song[]` kompilÃ¡toru Å™Ã­kÃ¡me, aÅ¥ pro potÅ™eby kontroly typÅ¯ pÅ™edpoklÃ¡dÃ¡, Å¾e tomu tak opravdu je. Kdybychom chtÄ›li, mohli bychom jeÅ¡tÄ› dodat explicitnÃ­ kÃ³d, kterÃ½ by pÅ™Ã­chozÃ­ data proÅ¡el a&nbsp;zkontroloval.

ZbÃ½vÃ¡ vylepÅ¡enÃ­ poslednÃ­ ÄÃ¡sti kÃ³du, kdy reagujeme na odeslÃ¡nÃ­ hledacÃ­ho formulÃ¡Å™e. JednÃ¡ se o&nbsp;posluchaÄ udÃ¡losti `submit`:

```ts
function onSubmit(e: Event) {
	e.preventDefault();
	let xhr = new XMLHttpRequest();
	let input = form.querySelector<HTMLInputElement>("[name=query]");
	if (!input) { return; }
	let query = input.value;
	let url = `/search?query=${encodeURIComponent(query)}`;
	xhr.responseType = "json";
	xhr.open("GET", url);
	xhr.send();
	xhr.addEventListener("load", e => showResults(xhr, query));
}
```

KromÄ› kontroly nÃ¡vratovÃ© hodnoty `querySelector` zde narÃ¡Å¾Ã­me na dalÅ¡Ã­ komplikaci. RÅ¯znÃ© HTML prvky majÃ­ rÅ¯znÃ© JavaScriptovÃ© vlastnosti, takÅ¾e jednou nÃ¡m funkce `querySelector` mÅ¯Å¾e vrÃ¡tit tÅ™eba obrÃ¡zek (ten mÃ¡ mj. vlastnost `src`), zatÃ­mco jindy vrÃ¡tÃ­ prvek `<input>` (kterÃ½ mÃ¡ vlastnost `value`). TypeScriptovÃ½ kompilÃ¡tor je v&nbsp;tomto smÄ›ru bezradnÃ½, takÅ¾e mu napovÃ­me pomocÃ­ tzv. **typovÃ©ho parametru**. ZÃ¡pisem `querySelector<HTMLInputElement>` Å™Ã­kÃ¡me, Å¾e poÄÃ­tÃ¡me s&nbsp;tÃ­m, Å¾e nÃ¡vratovÃ¡ hodnota bude zadanÃ©ho typu (a&nbsp;proto je v&nbsp;poÅ™Ã¡dku u&nbsp;nÃ­ nÃ¡slednÄ› pracovat s&nbsp;vlastnostÃ­ `value`).

ÃšplnÄ› na konec pÅ™idÃ¡me posluchaÄ na formulÃ¡Å™ a&nbsp;pÅ™i tom si ukÃ¡Å¾eme jeÅ¡tÄ› jeden syntaktickÃ½ prvek ze svÄ›ta TypeScriptu:

```ts
let form = document.querySelector("form")!;
form.addEventListener("submit", onSubmit);
```

VÃ­me, Å¾e funkce `querySelector` vracÃ­ buÄ HTML prvek, nebo `null`. VykÅ™iÄnÃ­kem Å™Ã­kÃ¡me, aÅ¥ TypeScript moÅ¾nost s&nbsp;`null` neuvaÅ¾uje. I&nbsp;zde bychom mohli prostÄ› pouÅ¾Ã­t podmÃ­nku (nÃ¡Å¡ kÃ³d by byl robustnÄ›jÅ¡Ã­!), ale vytvoÅ™ili bychom tak komplikaci pro jiÅ¾ upravenÃ½ posluchaÄ `onSubmit`. V&nbsp;nÄ›m se totiÅ¾, dÃ­ky uzÃ¡vÄ›Å™e, s&nbsp;promÄ›nnou `form` taktÃ©Å¾ pracuje. Kdyby jejÃ­ hodnota nebyla jistÃ¡, museli bychom s&nbsp;nÃ­ opatrnÄ› pracovat i&nbsp;uvnitÅ™ posluchaÄe. My jako programÃ¡toÅ™i vÃ­me, Å¾e pokud se posluchaÄ vykonÃ¡, promÄ›nnÃ¡ `form` existuje -- TypeScript to ale za nÃ¡s vymyslet nedokÃ¡Å¾e.


## ProfÃ­ci: WebAssembly

ProgramovacÃ­ch jazykÅ¯ je kolem nÃ¡s velkÃ© mnoÅ¾stvÃ­, a&nbsp;pÅ™esto je moÅ¾nÃ© v&nbsp;rÃ¡mci webovÃ©ho prohlÃ­Å¾eÄe psÃ¡t aplikaÄnÃ­ kÃ³d jen v&nbsp;JavaScriptu. Å˜Ã­kÃ¡me si, proc nemÃ¡me k&nbsp;dispozici i&nbsp;dalÅ¡Ã­ moÅ¾nosti, jako napÅ™Ã­klad Python, Go nebo tÅ™eba Ruby. Jakkoliv by bylo zavedenÃ­ dalÅ¡Ã­ho jazyka do prohlÃ­Å¾eÄe praktickÃ©, jednÃ¡ se o&nbsp;pÅ™Ã­liÅ¡ komplikovanÃ½ Ãºkol -- znamenalo by to, Å¾e vÅ¡echny prohlÃ­Å¾eÄe musÃ­ pÅ™ijÃ­t s&nbsp;identickou implementacÃ­ zvolenÃ©ho jazyka a&nbsp;zÃ¡roveÅˆ pro nÄ›j poskytovat vÅ¡echna rozhranÃ­, se kterÃ½mi jsme v&nbsp;JavaScriptu navyklÃ­ pracovat (DOM, prÃ¡ce se sÃ­tÃ­, Canvas, Web Audio, &hellip;).

NamÃ­sto integrace nÄ›jakÃ©ho dalÅ¡Ã­ho konkrÃ©tnÃ­ho programovacÃ­ho jazyka je pro nÃ¡s ovÅ¡em dostupnÃ¡ trochu jinÃ¡ moÅ¾nost: prohlÃ­Å¾eÄe dokÃ¡Å¾ou zpracovÃ¡vat kÃ³d ve speciÃ¡lnÃ­m tvaru **WebAssembly**. Jde o&nbsp;binÃ¡rnÃ­ formÃ¡t, kterÃ½ popisuje jednotlivÃ© instrukce virtuÃ¡lnÃ­ho procesoru, a&nbsp;v&nbsp;porovnÃ¡nÃ­ s&nbsp;JavaScriptem je tedy velmi nÃ­zkoÃºrovÅˆovÃ½. Jeho vÃ½hoda tkvÃ­ v&nbsp;tom, Å¾e do WebAssembly lze kompilovat programy psanÃ© v&nbsp;celÃ© Å™adÄ› jinÃ½ch jazykÅ¯, zejmÃ©na C, C++ a&nbsp;Rust. V&nbsp;prohlÃ­Å¾eÄi pak nemusÃ­ existovat implementace tÄ›chto jazykÅ¯ -- pÅ™evod do WebAssembly musÃ­ provÃ©st vÃ½vojÃ¡Å™ bokem pÅ™ed tÃ­m, neÅ¾ vzniklÃ½ kÃ³d ke strÃ¡nce pÅ™ipojÃ­.

PouÅ¾itÃ­m WebAssembly se nÃ¡m otevÃ­rajÃ­ dvÄ› hlavnÃ­ novÃ© moÅ¾nosti:

- spuÅ¡tÄ›nÃ­ existujÃ­cÃ­ho kÃ³du, psanÃ©ho v&nbsp;jinÃ©m jazyce, v&nbsp;rÃ¡mci webovÃ© strÃ¡nky;

- vytvoÅ™enÃ­ aplikace Äi knihovny, kterou vykonÃ¡ prohlÃ­Å¾eÄ bez nutnosti parsovÃ¡nÃ­ a&nbsp;vykonÃ¡vÃ¡nÃ­ JavaScriptu (vyÅ¡Å¡Ã­ vÃ½kon, pÅ™edvÃ­datelnÃ© chovÃ¡nÃ­ napÅ™Ã­Ä prohlÃ­Å¾eÄi).

U&nbsp;velkÃ½ch webovÃ½ch aplikacÃ­ nenÃ­ neobvyklÃ©, kdyÅ¾ nÄ›kterÃ© jejich souÄÃ¡sti tvoÅ™Ã­ JavaScript (zejmÃ©na ty, kterÃ© pracujÃ­ s&nbsp;uÅ¾ivatelskÃ½m rozhranÃ­m) a&nbsp;jinÃ© zase Web&shy;Assembly (tÅ™eba ty, kterÃ© provÃ¡dÃ­ komplikovanÃ© operace nad velkÃ½m mnoÅ¾stvÃ­m dat). Je ovÅ¡em dobrÃ© poznamenat, Å¾e prÃ¡ce s&nbsp;WebAssembly je komplikovanÃ¡ a&nbsp;vyplatÃ­ se jen tam, kde potÅ™ebujeme maximÃ¡lnÃ­ vÃ½kon, nebo musÃ­me spolupracovat s&nbsp;existujÃ­cÃ­m ne-JavaScriptovÃ½m kÃ³dem. KdyÅ¾ se chceme touto cestou vydat, ÄekajÃ­ nÃ¡s pÅ™edevÅ¡Ã­m tyto kroky:

1. Zvolit vhodnÃ½ zdrojovÃ½ programovacÃ­ jazyk. MusÃ­ k&nbsp;nÄ›mu existovat takovÃ½ kompilÃ¡tor, kterÃ½ dokÃ¡Å¾e vygenerovat vÃ½stup v&nbsp;jazyce WebAssembly, tj. soubory s&nbsp;pÅ™Ã­ponou `wasm`.

1. V&nbsp;rÃ¡mci bÄ›Å¾nÃ©ho klientskÃ©ho JavaScriptu naÄÃ­st vzniklÃ© `wasm` soubory (typicky pomocÃ­ `fetch`).

1. Dodat potÅ™ebnÃ½ podpÅ¯rnÃ½ kÃ³d (tzv. *glue code*), kterÃ½ poskytne pÅ™emostÄ›nÃ­ mezi logikou WebAssembly a&nbsp;svÄ›tem klientskÃ©ho JavaScriptu. Pokud napÅ™Ã­klad ve WebAssembly chceme naÄÃ­tat data (po sÃ­ti nebo ze souborÅ¯), musÃ­me tuto logiku dodat formou bÄ›Å¾nÃ½ch JavaScriptovÃ½ch funkcÃ­. Naopak, naÄtenÃ© WebAssembly funkce budeme chtÃ­t jistÄ› volat z&nbsp;normÃ¡lnÃ­ho JavaScriptu a&nbsp;pÅ™edÃ¡vat jim data uloÅ¾enÃ¡ v&nbsp;JS promÄ›nnÃ½ch.

V&nbsp;rÃ¡mci tÃ©to knihy se na WebAssembly podÃ­vÃ¡me jen v&nbsp;tom nejjednoduÅ¡Å¡Ã­m pÅ™Ã­kladu. VytvoÅ™Ã­me funkci v&nbsp;jazyce C, zkompilujeme ji do WebAssembly a&nbsp;nÃ¡slednÄ› ji zavolÃ¡me z&nbsp;JavaScriptu. Pro jazyk C existuje celÃ¡ Å™ada pÅ™ekladaÄÅ¯; my pouÅ¾ijeme **Emcscripten**, kterÃ½ pÅ™evÃ¡dÃ­ C/C++ prÃ¡vÄ› do WebAssembly.

KÃ³d naÅ¡Ã­ knihovny bude nabÃ­zet jedinou funkci `my_sqrt`, kterÃ¡ implementuje celoÄÃ­selnou odmocninu (a&nbsp;ÄinÃ­ tak volÃ¡nÃ­m funkce `sqrt` ze standardnÃ­ knihovny `math.h`). MÅ¯Å¾e vypada tÅ™eba takto:

```c
// my_sqrt.c

#include <math.h>
#include <emscripten.h>

EMSCRIPTEN_KEEPALIVE
int my_sqrt(int x) {
  return sqrt(x);
}
```

Makro `EMSCRIPTEN_KEEPALIVE` pochÃ¡zÃ­ z&nbsp;projektu pÅ™ekladaÄe Emscripten, kterÃ½ musÃ­me na svÃ©m operaÄnÃ­m systÃ©mu zprovoznit. Jeho ÃºÄelem je oznaÄenÃ­ tÄ›ch funkcÃ­, kterÃ© chceme do vÃ½slednÃ©ho WebAssembly exportovat a&nbsp;zachovat (chytrÃ½ pÅ™ekladaÄ by jinak funkci odstranil, neboÅ¥ v&nbsp;kÃ³du nenÃ­ nikde volÃ¡na). Jakmile mÃ¡me Emscripten nainstalovanÃ½, mÅ¯Å¾eme s&nbsp;nÃ­m tento kÃ³d zkompilovat:

```
emcc -O3 --no-entry my_sqrt.c -o my_sqrt.wasm
```

V&nbsp;ideÃ¡lnÃ­m pÅ™Ã­padÄ› vznikne soubor `my_sqrt.wasm`, kterÃ½ obsahuje danou funkci v&nbsp;binÃ¡rnÃ­m formÃ¡tu WebAssembly. PÅ™esuneme se do znÃ¡mÄ›jÅ¡Ã­ho svÄ›ta bÄ›Å¾nÃ©ho JavaScriptu a&nbsp;tento soubor naÄteme:

```js
let response = await fetch("my_sqrt.wasm");
let ab = await response.arrayBuffer();
```

DostÃ¡vÃ¡me se k&nbsp;poslednÃ­mu kroku celÃ© akce, totiÅ¾ k&nbsp;propojenÃ­ WebAssembly a&nbsp;JavaScriptu. PouÅ¾ijeme k&nbsp;tomu metodu `instantiate` z&nbsp;objektu `WebAssembly`:

```js
let wasm = await WebAssembly.instantiate(ab, {});
```

DruhÃ½ parametr je prÃ¡zdnÃ½. Pokud by nÃ¡Å¡ kÃ³d v&nbsp;C potÅ™eboval pÅ™Ã­stup k&nbsp;nÄ›kterÃ½m JS funkcÃ­m, museli bychom mu je poskytnout prÃ¡vÄ› v&nbsp;druhÃ©m parametru funkce `instantiate`. ExportovanÃ¡ funkcionalita je pro nÃ¡s nynÃ­ dostupnÃ¡ v&nbsp;promÄ›nnÃ© `wasm`:

```js
let my_sqrt = wasm.instance.exports.my_sqrt;
console.log(42, my_sqrt(42));
```

ProtoÅ¾e jsme pouÅ¾ili celoÄÃ­selnou verzi funkce `sqrt`, nepÅ™ekvapÃ­ nÃ¡s, Å¾e vypsanÃ¡ hodnota je Å¡est -- vÃ½sledek je oÅ™Ã­znut na niÅ¾Å¡Ã­ celÃ© ÄÃ­slo. Pro potÅ™eby ukÃ¡zky se jednÃ¡ o&nbsp;triviÃ¡lnÃ­ funkcionalitu, snadno si ale pÅ™edstavÃ­me, Å¾e mÃ­sto funkce `my_sqrt` mÅ¯Å¾eme exportovat sloÅ¾itou logiku, kterÃ¡ provede tÅ™eba kÃ³dovÃ¡nÃ­ videa, interakci s&nbsp;neuronovou sÃ­tÃ­ nebo hledÃ¡nÃ­ prÅ¯chodu velkÃ½m grafem pÅ™i plÃ¡novÃ¡nÃ­ cesty na mapÄ›.
