# HTML Canvas

## Úloha

Rádi bychom uživatelům, kteří se na našem webu zaregistrují, dovolili nahrát profilový obrázek. Tento se bude zobrazovat vedle jejich jména u&nbsp;diskuzních příspěvků a&nbsp;dalších aktivit. Protože se bude zobrazovat malý, není vhodné, aby nám uživatelé nahrávali své portréty ve velkém rozlišení. Proto obrázek před nahráním zmenšete tak, aby jeho delší strana nepřesahovala zadaný limit (např. 1000 pixelů).

### Řešení

```html
<!-- kapitola-11.html -->
<input type="file" accept="image/*" />
<script src="kapitola-11.js"></script>
```

```js
// kapitola-11.js
const MAX = 1000;

async function loadImage(file) {
	let img = new Image();
	img.src = URL.createObjectURL(file);
	await img.decode();
	return img;
}

function resizeImage(img) {
	let scale = Math.max(img.naturalWidth/MAX, img.naturalHeight/MAX, 1);
	let canvas = document.createElement("canvas");
	canvas.width = Math.round(img.width / scale);
	canvas.height = Math.round(img.height / scale);
	let ctx = canvas.getContext("2d");
	ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
	return canvas.toDataURL("image/jpeg");
}

async function onChange(e) {
	let file = e.target.files[0];
	if (!file) return;

	let sourceImage = await loadImage(file);
	let targetImage = resizeImage(sourceImage);

	fetch("/upload", {
		method: "POST",
		body: targetImage
	});
}

let input = document.querySelector("[type=file]");
input.addEventListener("change", onChange);
```

Přestože vzorové řešení má jen kolem třiceti řádků, obsahuje řadu novinek. Pro snazší pochopení si úlohu rozdělíme na tři menší části: získání obrazových dat z&nbsp;disku uživatele, zmenšení a&nbsp;následné nahrání na server.

### Načtení obrázku

V&nbsp;klientském JavaScriptu nelze přistupovat k&nbsp;libovolným souborům na disku uživatele. Představovalo by to značné bezpečnostní riziko, neboť při návštěvě webové stránky by cizí skript mohl snadno číst naše citlivá data a&nbsp;následně je například posílat na server útočníka. Panuje proto pravidlo, že prohlížeč zpřístupní obsah jen takových souborů, které za tímto účelem uživatel explicitně označil. Možnosti jsou dvě: buď takový soubor uživatel myší přetáhl z&nbsp;plochy do okna prohlížeče, nebo nějaký soubor vybral prostřednictvím formulářového prvku `<input type=file>`.

Druhá možnost je o&nbsp;něco přímočařejší a&nbsp;také častější, takže ji využijeme pro vzorové řešení. Atributem `accept` omezíme typ použitelných souborů, takže následně nemusíme uvažovat variantu, kdy by uživatel vybral nějaký soubor, který vůbec není obrázek. Po vybrání souboru vznikne událost `change` a&nbsp;tím dojde ke spuštění posluchače `onChange`. Vlastnost `files` HTML prvku `<input>` v&nbsp;takové chvíli obsahuje pole vybraných souborů (víc by jich mohlo být, pokud bychom použili atribut `multiple`). Jedná se o&nbsp;proměnné typu `File` -- s&nbsp;takovým objektem jsem se zatím nesetkali.

Objekt `File` slouží k&nbsp;přístupu k&nbsp;souboru, ale nedovoluje nám přímo získat jeho obsah. S&nbsp;proměnnou tohoto typu můžeme provádět tyto hlavní operace:

1. Můžeme ji předat funkci `fetch` a&nbsp;tím obsah souboru nahrát. To dělat nechceme, protože bychom nahrávali originální obrázek, který může být příliš velký.

1. Můžeme použít objekt `FileReader`, prostřednictvím kterého bychom se dostali k&nbsp;obsahu souboru (jednotlivým bajtům). To vypadá užitečně, ale jedná se o&nbsp;příliš nízkoúrovňový přístup. Museli bychom v&nbsp;JavaScriptu implementovat dekódování obrazového formátu (JPEG, PNG, GIF, &hellip;), což je zbytečně složité a&nbsp;pracné.

1. Protože víme, že vybraný soubor odpovídá obrázku, můžeme jej využít k&nbsp;vytvoření HTML prvku `<img>`. Ten je vhodný pro následné zmenšování.

HTML značka `<img>` ovšem vyžaduje URL, které nemáme. Naštěstí existuje šikovná a&nbsp;nepříliš známá funkce `URL.createObjectURL`, která slouží právě k&nbsp;tomuto účelu. Pro předaný objekt typu `File` vytvoří *falešné* dočasné URL, které můžeme až do zavření stránky používat tam, kde je URL očekáváno. V&nbsp;našem případě ho předáme do atributu `src` nově vytvořeného obrázku.

Ještě než začneme tento obrázek zpracovávat, musíme počkat, než jej prohlížeč načte (teprve potom budou například známy jeho rozměry). Načtení obrázku je asynchronní proces a&nbsp;máme dva způsoby, jak s&nbsp;ním pracovat:

1. Počkáme na událost `load`. To by znamenalo přidání posluchače a&nbsp;zabalení následného kódu do vlastní funkce. Bude to fungovat, ale existuje snazší řešení.

1. Použijeme relativně moderní metodu `decode()`, která taktéž čeká na načtení a&nbsp;vrací Promise. To je pro náš případ ideální.


### Změna rozměrů

Uživatelem vybraný soubor máme nyní načtený v&nbsp;HTML obrázku. Jeho rozměry jsou k&nbsp;dispozici ve vlastnostech `naturalWidth` a&nbsp;`naturalHeight` (mohli bychom se také zajímat o&nbsp;vlastnosti `width` a&nbsp;`height`, ale ty mohou být ovlivněny například pomocí CSS). Můžeme tedy vypočítat správnou cílovou velikost.

K&nbsp;výpočtu si nejprve nachystáme *měřítko*: číselnou hodnotu, která říká, kolikrát je nutné obrázek zmenšit. Protože chceme zachovat původní poměr stran, budeme oba rozměry zmenšovat stejně. Měřítko definujeme tímto vzorcem:

```js
let scale = Math.max(img.naturalWidth/MAX, img.naturalHeight/MAX, 1);
```

První parametr funkce `max` říká, *kolikrát je šířka obrázku větší, než požadovaný limit*. Druhý parametr funguje shodně, jen pro výšku. Z&nbsp;těchto hodnot bereme maximum, neboť v&nbsp;zadání je požadováno takové zmenšení, po kterém budou obě strany menší nebo rovny limitu.

Jednička na konci je malý trik: mohlo by se stát, že by nám uživatel nahrál obrázek, jehož oba rozměry jsou menší než limit. Měřítko by pak bylo menší než jedna a&nbsp;při následné transformaci bychom proto obrázek *zvětšili*. To je zbytečné a&nbsp;nežádoucí, takže pro malé obrázky zvolíme měřítko rovno jedné a&nbsp;tím pádem zůstane jejich původní velikost.

Nové rozměry pak vypočítáme jako ty původní vydělené měřítkem. V&nbsp;tuto chvíli nám již ovšem nestačí HTML obrázky. I&nbsp;kdybychom jim nastavovali menší rozměry, prohlížeč provede zmenšení jen pro potřeby zobrazení. Nahraná obrazová data budou stále v&nbsp;původním rozlišení. Proto musíme začít pracovat s&nbsp;HTML značkou `<canvas>`, která představuje univerzální nástroj pro tvorbu a&nbsp;manipulaci s&nbsp;rastrovými obrazovými daty.

Prvek `<canvas>` (anglické označení pro malířské plátno) sice patří do jazyka HTML, ale pracujeme s&nbsp;ním výhradně pomocí JavaScriptových funkcí a&nbsp;vlastností. A&nbsp;že jich je! Zatím si ukážeme jen úplný základ práce s&nbsp;canvasem, ale v&nbsp;následujících podkapitolách prozkoumáme i&nbsp;další jeho možnosti.

Naše plátno potřebuje především nastavit rozměry. K&nbsp;tomu použijeme výše zmíněný výpočet:

```js
let canvas = document.createElement("canvas");
canvas.width = Math.round(img.width / scale);
canvas.height = Math.round(img.height / scale);
```

Canvas odpovídá obdélníku pixelů, proto je potřeba jeho rozměry nastavovat v&nbsp;celých čísel. Měřítko i&nbsp;výsledek dělení mohou být čísla desetinná, proto je na celé pixely musíme zaokrouhlit.

Funkce, které canvas nabízí, jsou v&nbsp;rámci jeho JS API seskupeny do tzv. *kontextů* -- JavaScriptových objektů, specializovaných pro různé vykreslovací operace. Pro naši úlohu je vhodný kontext nazvaný prostě `"2d"`. Ten dovoluje takové operace, které známe například z&nbsp;programu Malování: tah štětcem, vyplňování plochy, vkládání obrázků a&nbsp;podobně. Čistě teoretickým příkladem dalšího kontextu může být `"webgl"`, což je vysoce specializované rozhraní určené pro vykreslování pomocí akcelerované grafiky prostřednictvím jazyka OpenGL. S&nbsp;takto pokročilými technikami se ovšem v&nbsp;této knize nesetkáme.

Metoda `drawImage` patří dvourozměrnému kontextu a&nbsp;má řadu různých signatur. Prvním parametrem je zdrojový obrázek, další dva parametry definují cílové souřadnice (místo, na kterém v&nbsp;canvasu vykreslíme levý horní roh obrázku) a&nbsp;nejdůležitější jsou poslední dva parametry -- cílové rozměry. Právě díky nim prohlížeč vykreslí původní obrázek do canvasu zmenšený.

Celá tato zmenšovací operace nás stojí jen dva řádky kódu:

```js
let ctx = canvas.getContext("2d");
ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
```


### Nahrání obrázku

Máme skoro hotovo! Zmenšili jsme portrét, jen ho teď nemáme v&nbsp;HTML obrázku, ale v&nbsp;HTML canvasu. A&nbsp;ten nelze sám o&nbsp;sobě vzít a&nbsp;nahrát na server. Mimo jiné proto, že canvas představuje dvourozměrné pole pixelů, ale soubory obsahují obrazová data v&nbsp;nějakém formátu. Musíme proto prohlížeč nejprve požádat, aby obrazová data z&nbsp;canvasu vhodně zakódoval.

Canvas pro tyto účely disponuje dvěma metodami, které dělají v&nbsp;podstatě to samé: `toDataURL` a&nbsp;`toBlob`. Liší se takto:

- Metoda `toBlob` je asynchronní (přijímá callback) a&nbsp;produkuje objekt typu `Blob`, který zastřešuje výsledná binární data. Můžeme jej předat funkci `fetch` a&nbsp;odeslat na server. Tato metoda představuje výkonnější řešení: je úsporná a&nbsp;díky asynchronnosti neblokuje hlavní vlákno.

- Metoda `toDataURL` je synchronní a&nbsp;její návratová hodnota je tzv. *data URI*: řetězec ve tvaru podobném URL, obsahující zakódovaná obrazová data. Můžeme jej použít všude, kde je očekáváno URL (podobně jako výsledek volání `URL.createObjectURL`). Takový řetězec můžeme samozřejmě taktéž nahrát na server. Kromě blokování hlavního vlákna je další nevýhoda metody `toDataURL` v&nbsp;tom, že výsledný řetězec obsahuje jednotlivé bajty zapsané pomocí *kódování Base64*, kdy se používají pouze tištitelné znaky, ale datový objem tím naroste zhruba o&nbsp;třetinu.

Pro jednoduchost ve vzorovém řešení použijeme `toDataURL`. Jejím parametrem je identifikace obrazového formátu, do kterého chceme obrázek zakódovat:

```js
function resizeImage(img) {
	// tvorba canvasu viz výše
	return canvas.toDataURL("image/jpeg");
}

let targetImage = resizeImage(sourceImage);
```

V&nbsp;porovnání s&nbsp;minulými kapitolami potřebujeme na server odeslat značné množství dat. Musíme proto použít HTTP metodu `POST` a&nbsp;data umístit do těla požadavku. V&nbsp;případě funkce `fetch` je to jen otázka konfiguračních parametrů `method` a&nbsp;`body`:

```js
fetch("/upload", {
	method: "POST",
	body: targetImage
});
```

Tím jsme na server poslali data zmenšeného zakódovaného obrázku.


### Co jsme se naučili

Po vyřešení desáté úlohy by měl čtenář chápat a&nbsp;ovládat:

- možnosti přístupu k&nbsp;datům uživatelem vybraného souboru

- využití HTML canvasu pro zmenšení obrázku

- získání obrazových dat z&nbsp;canvasu ve formátu vhodném k&nbsp;odeslání po síti

## Zelenáči: další dovednosti canvasu

HTML značka `<canvas>` je univerzální kreslicí plocha. Ukázali jsme, jak do ní přenést obrázek ze značky `<img>`; nyní přišel čas vyzkoušet další metody, které 2d-kontext nabízí. Abychom nemalovali jen tak nahodile, vyřešíme skutečnou úlohu, ke které lze canvas použít -- ukazatel načítání.

Předpokládejme, že provádíme operaci, která trvá delší dobu. Může jít třeba o&nbsp;nahrávání profilového obrázku, nebo čekání na nějaká data ze serveru. Když se jedná o&nbsp;aktivitu na pozadí, uživatel nemá žádné informace o&nbsp;její existenci, případně průběhu. Bývá proto obvyklé, že síťovou komunikaci nějakým nenápadným způsobem vizualizujeme. Sestavme animaci, která představuje postupně se zvětšující kruhovou výseč (zelené barvy). Abychom nemuseli vymýšlet, kam takový obrázek umístit, zobrazíme ho v&nbsp;záhlaví záložky prohlížeče vedle titulku stránky -- uděláme z&nbsp;tohoto obrázku tzv. *favikonku*.

Favikonky jsou malé obrázky, které k&nbsp;HTML dokumentu připojujeme pomocí značky `<meta>` v&nbsp;hlavičce stránky. Typicky to vypadá takto:

```html
<meta rel="icon" href="ikonka.png" />
```

Nic nám ale nebrání takovou favikonku vyrobit pomocí JavaScriptu. Jakmile pro ni dokážeme sestavit URL, můžeme jej použít pro změnu atributu `href` u&nbsp;značky `<link>`.

Začneme tím, že si nachystáme malý čtvercový canvas. Pro rozměry vytvoříme konstantu:

```js
const SIZE = 32;
let canvas = document.createElement("canvas");
canvas.width = canvas.height = SIZE;
let ctx = canvas.getContext("2d");
```

Malování obstará funkce, která pomocí metod kontextu `ctx` vytvoří požadovaný útvar. Ta bude muset znát úhel (velikost výseče). Proto si nachystáme kód, který bude v&nbsp;čase úhel měnit a&nbsp;periodicky kreslicí funkci vykonávat:

```js
let angle = 0;
setInterval(() => {
	angle = (angle + 0.1) % (2 * Math.PI);
	draw(angle);
}, 100);
```

V&nbsp;počítačové grafice bývají úhly zpravidla specifikovány pomocí radiánů. V&nbsp;tomto kódu každých 100 milisekund zvětšíme úhel o&nbsp;0,1 radiánu. Hodnotu ještě upravíme operátorem procenta (zbytek po dělení) tak, aby nikdy nepřesáhla 2π, tj. celý kruh. To znamená, že jakmile vykreslíme kruh, začneme znovu od začátku úzkou výsečí od nuly.

Zbývá naimplementovat kreslení ve funkci `draw`. HTML canvas je zajímavý tím, že jakmile do něj nějaká data vykreslíme, už je zpětně nemůžeme měnit. Animaci tedy realizujeme tak, že canvas nejprve zcela vyprázdníme a&nbsp;pak do něj vykreslíme nový snímek dle aktuálního stavu. Pro vymazání existuje metoda `clearRect`, které předáme souřadnice (a&nbsp;rozměry) obdélníkové oblasti, kterou chceme vymazat. V&nbsp;našem případě je to celý canvas:

```js
function draw(angle) {
	ctx.clearRect(0, 0, SIZE, SIZE);
}
```

Kruhovou výseč vytvoříme pomocí operace, která odpovídá tažení virtuálním štětcem po plátně. Sestává z&nbsp;těchto kroků:

1. posun štětce doprostřed plátna
1. čára doprava
1. kruhový oblouk o&nbsp;délce úměrné požadovanému úhlu
1. čára zpět do středu
1. vyplnění vzniklé oblasti barvou

Náš kontext nabízí metody přesně pro tyto kroky:

```js
ctx.beginPath();
ctx.moveTo(SIZE/2, SIZE/2);
ctx.lineTo(SIZE, SIZE/2);
ctx.arc(SIZE/2, SIZE/2, SIZE/2, 0, angle);
ctx.closePath();
ctx.fillStyle = "green";
ctx.fill();
```

Jediné komplikované místo je metoda `arc`, která vytváří kruhový oblouk. Ten vyžaduje mnoho parametrů: dvě souřadnice středu kruhu, poloměr, počáteční úhel (nula odpovídá bodu na kružnici nejvíc vpravo) a&nbsp;cílový úhel.

Za zmínku ještě stojí nastavení barvy výplně. Stejně jako v&nbsp;programu Malování, i&nbsp;zde provádíme nastavení barvy (vlastnost `fillStyle`) nezávisle na kreslení (metoda `fill`). Ve chvíli vykreslení se pak použije aktuálně nastavená barva. Znamená to, že změnu barvy můžeme provést kdykoliv před vykreslením, ale nikdy až poté.

V&nbsp;tuto chvíli máme v&nbsp;canvasu hotový obrázek. Zbývá z&nbsp;něj vytvořit URL (to umíme z&nbsp;první části této kapitoly) a&nbsp;nastavit jej prvku `<meta>`:

```js
let link = document.head.querySelector("[rel=icon]");
link.href = canvas.toDataURL("image/png");
```

Výsledný kód pak celý vypadá například takto:

```html
<!-- kapitola-11-zelenaci.html -->
<!doctype html>
<html>
	<head><link rel="icon" /></head>
	<script>

let canvas = document.createElement("canvas");
const SIZE = 32;
canvas.width = canvas.height = SIZE;
let ctx = canvas.getContext("2d");


function draw(angle) {
	ctx.clearRect(0, 0, SIZE, SIZE);
	ctx.beginPath();
	ctx.moveTo(SIZE/2, SIZE/2);
	ctx.lineTo(SIZE, SIZE/2);
	ctx.arc(SIZE/2, SIZE/2, SIZE/2, 0, angle);
	ctx.closePath();
	ctx.fillStyle = "green";
	ctx.fill();

	let link = document.head.querySelector("[rel=icon]");
	link.href = canvas.toDataURL("image/png");
}

let angle = 0;
setInterval(() => {
	angle = (angle + 0.1) % (2 * Math.PI);
	draw(angle);
}, 100);

	</script>
</html>
```


## Koumáci: obrazová data z&nbsp;kamery a&nbsp;videa

Zatím jsme ukázali, jak v&nbsp;canvasu vytvářet nový obsah a&nbsp;jak ho z&nbsp;canvasu získat v&nbsp;podobě URL. Prohlížeče nabízí ještě další způsoby, jak do canvasu dostat obrazová data -- ovšem stále prostřednictvím metody `drawImage`, kterou jsme si představili ve vzorovém řešení.

Její první parametr specifikuje zdroj dat. Nemusí jít jen o&nbsp;obrázek; může to být také jiný canvas nebo HTML značka `<video>`. Pokud bychom tedy měli soubor s&nbsp;videem, můžeme jej přehrávat prostřednictvím značky `<video>`, její obsah pravidelně přenášet do canvasu a&nbsp;tam jej dle potřeby zpracovávat. Je to docela snadné:

```html
<video src="video.mp4"></video>
<canvas></canvas>
```

```js
function drawToCanvas() {
	let video = document.querySelector("video");
	let canvas = document.querySelector("canvas");
	canvas.width = video.videoWidth;
	canvas.height = video.videoHeight;

	let ctx = canvas.getContext("2d");
	ctx.drawImage(video, 0, 0);

	requestAnimationFrame(drawToCanvas);
}

drawToCanvas();
```

Pro periodické vykonávání kódu jsme tentokrát zvolili jiný přístup, než `setInterval`. Pokud chceme opakovaně provádět operaci, která něco vykresluje do stránky, je lepší použít funkci `requestAnimationFrame`. U&nbsp;ní neříkáme časový krok (tj. *za jak dlouho má prohlížeč zadaný kód vykonat*) a&nbsp;namísto toho necháváme prohlížeč, aby volil časový krok sám -- s&nbsp;ohledem na aktuální vytížení počítače, snímkovou frekvenci monitoru a&nbsp;další faktory (pokud je například záložka s&nbsp;naším kódem neaktivní, uživatel nic nevidí a&nbsp;prohlížeč může snížit frekvenci vykreslování).

Funkce `requestAnimationFrame` je, podobně jako `setTimeout`, jednorázová. Musíme ji proto zavolat po každém vykreslení (a&nbsp;naplánovat tak zase další krok). Vytváříme tím nepřímo smyčku, kterou můžeme přerušit prostě tím, že přeskočíme další volání `requestAnimationFrame`.

Vykreslování a&nbsp;zpracování jednotlivých snímků z&nbsp;HTML značky `<video>` je zároveň základem pro přístup k&nbsp;datům z&nbsp;kamery. Funguje to v&nbsp;několika fázích:

1. požádáme prohlížeč o&nbsp;tzv. *stream* (datový proud) z&nbsp;kamery
1. prohlížeč požádá uživatele o&nbsp;svolení -- jedná se o&nbsp;vysoce citlivá data, takže uživatel musí vyjádřit souhlas
1. získaný stream použijeme jako zdroj dat pro značku `<video>`
1. obrazová data jednotlivých snímků získáme do canvasu stejně, jako v&nbsp;minulé ukázce

Přestože se dohromady jedná o&nbsp;spoustu práce, většinu z&nbsp;ní udělá prohlížeč. My musíme v&nbsp;JavaScriptu nově jen vyvolat žádost o&nbsp;přístup ke streamu. K&nbsp;tomu slouží funkce `navigator.mediaDevices.getUserMedia` a&nbsp;její jediný parametr upřesňuje, která všechna audio-vizuální data z&nbsp;kterých vstupů nás zajímají. Můžeme zde poměrně detailně určit, jestli stojíme jen o&nbsp;obraz, nebo i&nbsp;o&nbsp;zvuk; u&nbsp;obrazu definovat požadované rozlišení a&nbsp;dále třeba prohlížeči naznačit, jestli má v&nbsp;případě mobilního telefonu použít hlavní zadní kameru, nebo selfie-kameru z&nbsp;přední strany. V&nbsp;nejjednodušším případě si prostě vyžádáme libovolný zdroj obrazu:

```js
try {
	let stream = await navigator.mediaDevices.getUserMedia({video: true});
} catch (e) {
	// není žádná kamera, případně uživatel nepovolil přístup
}
```

Funkce je asynchronní a&nbsp;je pravděpodobné, že na její dokončení si počkáme. Prohlížeč v&nbsp;tuto chvíli musí uživateli ukázat dialog, ve kterém dojde nejen k&nbsp;odsouhlasení přístupu webové stránky ke kameře, ale také k&nbsp;výběru konkrétní kamery, pokud jich je v&nbsp;zařízení dostupných více. Proměnná `stream` pak bude obsahovat objekt typu `MediaStream`, který použijeme jako zdroj dat pro `<video>`:

```js
let video = document.querySelector("video");
video.srcObject = stream;
video.play();
```

Značku `<video>` v&nbsp;tomto případě vůbec nemusíme ukazovat -- je pro nás jen nezbytný spojovací článek mezi streamem z&nbsp;kamery a&nbsp;canvasem, ve kterém výsledná data zobrazujeme a&nbsp;upravujeme.


## Profíci: kdy s&nbsp;canvasem narazíme a&nbsp;jak z&nbsp;toho ven

V&nbsp;této podkapitole si ukážeme některé zapeklité situace, na které můžeme při práci s&nbsp;canvasem narazit. Jejich řešení je často snadné, ale ne vždy na první pohled zřejmé.


### Tainting

V&nbsp;páté kapitole jsme se dozvěděli, že v&nbsp;JavaScriptu není obecně možné přistoupit k&nbsp;datům získaným z&nbsp;jiné domény, než je doména aktuální stránky. Jedná se o&nbsp;mechanismus *Same Origin Policy* a&nbsp;jeho hlavním účelem je ochrana proti útokům CSRF, tj. situacím, kdy vstoupíme na stránku útočníka a&nbsp;náš prohlížeč jí poskytne citlivé údaje. Na ochranu SOP můžeme narazit i&nbsp;při práci s&nbsp;canvasem, aniž bychom přímo vykonávali HTTP požadavky prostřednictvím `XHR` nebo `fetch`.

Začněme obyčejným HTML obrázkem (značkou `<img>`), kterému nastavíme zdrojovou adresu s&nbsp;jiným originem (tento důležitý termín je definován rovněž v&nbsp;páté kapitole), než je origin současné stránky. Prohlížeč jej stáhne a&nbsp;zobrazí, ale protože se jedná o&nbsp;potenciálně citlivá data, nesmí je (bez souhlasu vzdáleného serveru) dát k&nbsp;dispozici JavaScriptu. Můžeme se o&nbsp;to pokusit použitím již známé metody `drawImage` -- a&nbsp;v&nbsp;takovou chvíli se obrázek v&nbsp;canvasu sice vykreslí, ale canvas se tím označí jako *tainted* (něco jako *otrávený*). To znamená, že přestanou fungovat veškeré mechanismy, kterými bychom se mohli pomocí JavaScriptu dívat na obrazová data v&nbsp;canvasu obsažená. Zahrnuje to jak zmíněné metody `toDataURL` a&nbsp;`toBlob`, tak i&nbsp;možnost čtení jednotlivých pixelů pomocí `getImageData`. Dokud canvas, který je *tainted*, zcela nevyprázdníme, nebudeme jej moci plnohodnotně používat.

Za toto bezpečnostní omezení jsme rádi, ale v&nbsp;některých situacích je zbytečně striktní. Víme, že SOP lze obejít, pokud vzdálený server vydá explicitní souhlas s&nbsp;tím, aby jeho data byla přístupná JavaScriptu. U&nbsp;HTML obrázků musíme nejprve přidat `crossOrigin`, ať už pomocí atributu, nebo vlastnosti:

```html
<img src="https://..." crossOrigin="anonymous" />
```

```js
let image = new Image();
image.crossOrigin = "anonymous";
```

Povolené hodnoty jsou dvě: `anonymous` (do požadavku nejsou přidány cookies) a&nbsp;`use-credentials` (cookies jsou přítomny). Tím prohlížeč v&nbsp;požadavku na obrázek pošle také hlavičku `Origin`. Pokud následně server do HTTP odpovědi přidá potřebné CORS hlavičky (stejně jako na konci páté kapitoly), canvas s&nbsp;tímto obrázkem nebude *tainted* a&nbsp;můžeme s&nbsp;ním pracovat plnohodnotně.


### Antialiasing

V&nbsp;podkapitole pro zelenáče jsme viděli, jak do canvasu kreslit různé geometrické útvary a&nbsp;křivky. V&nbsp;rámci tahu štětcem (posloupnost příkazů začínající metodou `beginPath`) musí prohlížeč danou křivku převést na jednotlivé pixely v&nbsp;canvasu -- této operaci se říká *rasterizace*. Pixely jsou umístěny v&nbsp;pravidelné mřížce a&nbsp;během rasterizace se rozhoduje, který z&nbsp;nich bude mít jakou barvu. Tato činnost je docela složitá a&nbsp;u&nbsp;složitějších křivek ji vlastně ani nelze vykonat zcela přesně. Můžeme si to představit na jednoduché diagonální čáře; při její rasterizaci na čtverečkovaném papíře vidíme, že vzniklý útvar je *zubatý*.

V&nbsp;HTML canvasu prohlížeče automaticky během rasterizace provádí tzv. *antialiasing*. Při této operaci se snaží vyhnout zmiňovaným zubatým hranám tak, že pixely poblíž hranic vykreslované oblasti zobrazí barvou, která je někde mezi barvou výplně a&nbsp;barvou pozadí. Pokud do bílého canvasu kreslíme černý útvar, jeho hrany budou při bližším zkoumání šedé. Tato nepřesnost pak pro lidské oko zvýší iluzi toho, že hrana je hladká a&nbsp;přesná.

V&nbsp;naprosté většině případů je antialiasing užitečný a&nbsp;chtěný. Existuje však jeden scénář, kdy nám vadí -- a&nbsp;přitom jej nelze vypnout. Jedná se o&nbsp;kresbu čáry, která je zcela svislá či vodorovná, má celočíselné souřadnice a&nbsp;lichou tloušťku. Jeden obrázek je v&nbsp;tomto případě lepší, než tisíc slov: pokusme se vykreslit krátkou svislou čáru, tlustou jeden pixel, spojující body (3; 1) a&nbsp;(3; 5).

![Cílová tenká čára](img/canvas1.svg)

Každý pixel si můžeme představit jako malý čtverec, který má v&nbsp;levém horním rohu *své* souřadnice. Pixel (3; 1) je druhý shora a&nbsp;čtvrtý zleva. Jeho pravý dolní roh má souřadnice o&nbsp;jedničku vyšší -- je to zároveň levý horní roh sousedního pixelu.

Podívejme se nyní na problémovou svislou čáru z&nbsp;bodu (3; 1) dolů. Její tloušťka je jeden pixel, což znamená, že od svého matematického středu zabírá půl pixelu doleva a&nbsp;půl pixelu doprava. Do šířky by tedy měla pokrývat rozpětí od 2,5 do 3,5 pixelu. To ale nedává smysl, protože není možné zapnout na obrazovce (ani v&nbsp;canvasu) jen polovinu pixelu. Prohlížeč tento problém řeší antialiasingem, takže obarví oba dva pixely takto zasažené čarou, ale nastaví jim jen poloviční barvu. Namísto jednopixelové černé čáry pak vidíme čáru dvoupixelovou šedou.

![Jednopixelová čára zabírá dva půlpixely](img/canvas2.svg)

Víme, že antialiasing v&nbsp;canvasu nejde vypnout. Při pohledu na zvětšené pixely nás ale může napadnout snadný trik. Naším cílem je obarvit pixel (3; 1) a&nbsp;následně ty pod ním. Horizontálně to tedy znamená, že chceme obarvit rozpětí od 3. do 4. pixelu. To odpovídá jednopixelové čáře, jejíž první souřadnice je 3,5! A&nbsp;canvas nám dovoluje používání neceločíselných souřadnic. Správně tedy ostrou svislou čáru (s&nbsp;lichou šířkou) vykreslíme tak, že ji posuneme o&nbsp;polovinu pixelu:

```js
ctx.lineWidth = 1;
ctx.beginPath();
ctx.moveTo(3.5, 1);
ctx.lineTo(3.5, 5);
ctx.stroke();
```

![Posun o&nbsp;polovinu pixelu doprava](img/canvas3.svg)



### Vysoká hustota pixelů

V&nbsp;posledních letech se často setkáváme se zobrazovacími zařízeními, které disponují vysokou hustotou pixelů (známe je např. pod obchodním názvem Retina). Tyto displeje mají extrémně malé pixely, takže se jich -- v&nbsp;porovnání s&nbsp;běžnými dipleji -- na stejnou plochu vejde třeba čtyřnásobek. Díky tomu je možné dosáhnout perfektní ostrosti. Takto malé pixely ale neznamenají, že pracujeme s&nbsp;násobným rozlišením. Můžeme si to představit na písmu běžné výšky 16 pixelů, zobrazovaném na displeji s&nbsp;dvojnásobnou hustotou pixelů. Pokud bychom u&nbsp;takového displeje vykreslovali písmo vždy na 16 pixelů výšky, bude ve skutečnosti (v&nbsp;milimetrech) dvakrát menší a&nbsp;tím pádem nečitelné.

Zařízení s&nbsp;vysokou hustotou proto používají trik: vykreslované objekty před rasterizací úměrně zvětší (typicky na dvojnásobek), takže písmo s&nbsp;nastavenou velikostí 16 pixelů jich zabere 32, a&nbsp;přitom je (v&nbsp;milimetrech) stejně velké, jako kdyby na běžném displeji zabralo pixelů 16.

Pro vývojáře to představuje jistou komplikaci, neboť nyní pracujeme se dvěma druhy pixelů:

1. *CSS pixely* neboli *logické pixely*, které odpovídají původnímu rozlišení. Když si koupíme displej Retina, počet logických pixelů zůstane stejný. Logické pixely používáme téměř všude: při specifikaci délkových jednotek v&nbsp;CSS, při nastavování rozměrů obrázků, v&nbsp;media queries.

1. *Hardwarové* neboli *fyzické pixely*, které odpovídají skutečným diodám v&nbsp;hardware displeje. S&nbsp;nimi pracuje až prohlížeč a&nbsp;operační systém, když obsah webové stránky rasterizují před vykreslením.

V&nbsp;JavaScriptu máme k&nbsp;dispozici informaci jen o&nbsp;logických pixelech, ale zároveň se ve vlastnosti `window.devicePixelRatio` dozvíme, kolikrát je počet fyzických pixelů větší, než počet těch logických. Jinými slovy, displeje s&nbsp;vysokou hustotou pixelů mají `devicePixelRatio` větší než jedna.

Koncept logických a&nbsp;fyzických pixelů je navržen tak, abychom se o&nbsp;něj v&nbsp;naprosté většině případů nemuseli starat. Bohužel, práce s&nbsp;canvasem je jedno z&nbsp;těch míst, kdy nás hardwarové pixely zajímají. Představme si stránku s&nbsp;HTML obsahem šířky 640 pixelů (logických), ve které máme canvas (aby do stránky dobře pasoval, jeho šířka je též 640). Do canvasu jsme nakreslili obrázek a&nbsp;nyní jej chceme zobrazit na monitoru s&nbsp;`devicePixelRatio = 2`. Znamená to, že prohlížeč musí canvas nejprve roztáhnout na šířku 1280 pixelů (hardwarových) a&nbsp;pak teprve vykreslit. Během roztažení dojde k&nbsp;nepěknému rozmazání, způsobenému jednoduše tím, že si prohlížeč musí čtyřnásobný počet pixelů domyslet.

Tomuto nežádoucímu rozmazání můžeme předejít tím, že si canvas nachystáme v&nbsp;takové velikosti, která odpovídá počtu hardwarových pixelů. Zahrnuje to tři kroky:

1. Canvasu nastavíme rozměry (atributy `width` a&nbsp;`height`) dle fyzických pixelů.
1. Canvasu nastavíme velikost (CSS vlastnosti `width` a&nbsp;`height`) dle logických pixelů -- chceme, aby dobře pasoval do stránky široké 640 logických pixelů.
1. Vše, co do canvasu kreslíme, musíme vytvářet dvakrát větší (neboť i&nbsp;počet pixelů v&nbsp;canvasu je větší).

Náš kód by měl ale stejně dobře fungovat jak pro zařízení s&nbsp;vysokou hustotou pixelů, tak pro ta běžná. Podívejme se, jak můžeme canvas pro takové vykreslování připravit zcela univerzálně, jen na základě znalosti `devicePixelRatio`:

```js
// CSS pixely
let width = 640;
let height = 480;

let canvas = document.createElement("canvas");
canvas.style.width = `${width}px`;
canvas.style.height = `${height}px`;

// hardwarové pixely
canvas.width = width * devicePixelRatio;
canvas.height = height * devicePixelRatio;

canvas.scale(devicePixelRatio, devicePixelRatio);
```

Poslední řádek říká, že všechny následující vykreslovací operace mají být *zvětšeny* dle zadaného měřítka (resp. dle dvou -- jednoho v&nbsp;ose X, jednoho v&nbsp;ose Y). Pokud pracujeme s&nbsp;běžným displejem, je `devicePixelRatio` rovno jedné, žádné zvětšování se neodehrává a&nbsp;CSS rozměry se shodují s&nbsp;fyzickými. U&nbsp;displejů s&nbsp;vysokým rozlišením vytvoříme canvas veliký, vykreslujeme jej do menšího prostoru a&nbsp;tím se naše canvasové pixely přesně trefí do těch hardwarových.

Pozor -- některé displeje mají hodnotu `devicePixelRatio` neceločíselnou. Musíme pak dát pozor na to, abychom po násobení zůstali u&nbsp;celých čísel, neboť canvas musí mít celočíselné rozměry.
