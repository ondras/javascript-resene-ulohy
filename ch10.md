# Kapitola 10: Intl, Storage, polyfilly a další API

## Úloha

V rámci webu věnovaného písním Karla Gotta připravujeme část s e-shopem. Na prodej budou originály textů jeho písní s podpisem textaře. Vypište tyto položky; každá bude obsahovat název písně, datum jejího vzniku a cenu v korunách.

### Řešení

Soupis písní bude opět pocházet z backendu, jehož rozhraní není pro tuto úlohu podstatné. Zajímá nás jen tvar dat jednotlivých položek, které budeme vykreslovat.

Název (řetězec) a cena (číslo) nejsou příliš zajímavé. Datum již představuje jistou výzvu, neboť jeho reprezentace napříč různými informačními systémy bývá různorodá. Zejména v případě formátu JSON (pracujeme s ním pravidelně od páté kapitoly) je nutné formát data s autory backendové komponenty dobře domluvit, protože JSON žádný datový typ pro datum neobsahuje. Možností je celá řada; nejčastěji se v praxi setkáváme se dvěma:

1. Datum zapsané ve formátu řetězce s pevnou strukturou. Standardní zápis bývá sestupně dle velikosti jednotky, tj. např. `1960-05-24`. Tímto způsobem může řetězec obsáhnout několik hodnot naráz (rok, měsíc, den) a pokud by to bylo nutné, můžeme přidat i časovou informaci v rámce dne (hodiny, minuty, &hellip;).
1. Datum zapsané jedním číslem, které vyjadřuje počet časových jednotek uplynulých od vhodně zvoleného počátku. Této formě se říká *timestamp* (časové razítko) a pro správné fungování je nutná dohoda na jednotkách (častá volba jsou sekundy či milisekundy) a počátku (v naprosté většině případů se používá datum 1. 1. 1970). S jediným číslem se pracuje snadno a elegantně, ovšem pro reprezentaci dne v roce to není nejlepší volba, mimo jiné proto, že pro jedno datum (jeden den) existuje spousta různých hodnot pro timestamp.

Pojďme naši implementaci postavit tak, že vstupní data budou v poli struktur s těmito klíči:

- `id` je unikátní identifikátor písně v databázi (string),
- `name` je název písně (string),
- `price` je cena (číslo),
- `date` je datum ve formátu `rok-měsíc-den` (řetězec), nebo timestamp ve vteřinách (číslo).


```html
<!-- kapitola-10.html -->
<h1>Písně k zakoupení</h1>
<ul></ul>

<script src="kapitola-10.js"></script>
```

```js
// kapitola-10.js
let DATA = [
	{name: "FIXME", date: 0, price: 123},
	{name: "FIXME", date: 0, price: 123},
	{name: "FIXME", date: 0, price: 123}
];

let dateFormat = new Intl.DateTimeFormat(undefined, {dateStyle:"long"});
let priceFormat = new Intl.NumberFormat(undefined, {style:"currency", currency:"CZK"});

function buildItem(item) {
	let li = document.createElement("li");

	let dateIsNumber = (typeof(item.date) == "number");
	let date = (dateIsNumber ? new Date(item.date*1000) : new Date(item.date));

	li.innerHTML = `
		<h3></h3>
		<span>Datum: ${dateFormat.format(date)}</span>
		<span>Cena: ${priceFormat.format(item.price)} Kč</span>
	`;
	li.children[0].textContent = item.name;  // textContent kvůli XSS
	return li;
}

let items  = DATA.map(buildItem);
document.querySelector("ul").replaceChildren(...items);
```

Při přečtení zadání této úlohy nás možná napadne, že bychom k jejímu řešení mohli prostě použít to, co jsme se naučili v minulých kapitolách. Ale pro potřeby výpisu ceny a data by to bylo zbytečně pracné. Je praktičtější se nejprve podívat, jestli nám JavaScript nebo prohlížeč nenabízí nějakou vestavěnou funkcionalitu, díky které bychom mohli ušetřit čas a práci. V tomto případě se jedná o rozhraní `Intl`, jehož název je zkratkou z anglického *internationalization* -- funkce související se zobrazováním a zpracováním dat s ohledem na místní zvyklosti. Skutečně, cena i datum jsou příkladem veličin, které se v různých kulturách a jazycích zobrazují různě (a často docela komplikovaně). I kdybychom své stránky cílili výhradně na české uživatele, oceníme, když za nás naše regionální speciality vyřeší někdo jiný.

Globální proměnná `Intl` obsahuje několik tříd, určených pro zpracovávánní a formátování různých druhů dat, vždy s ohledem na pravidla zadaného jazyka. Ty nejdůležitější jsou:

- `Intl.Collator` pro (abecední) porovnávání řetězců
- `Intl.DateTimeFormat` pro formátování datumů a časů
- `Intl.DisplayNames` pro zobrazování názvů zemí, jazyků a měn
- `Intl.ListFormat` pro formátování posloupností hodnot
- `Intl.NumberFormat` pro zobrazování různých číselných hodnot
- `Intl.PluralRules` pro správnou volbu názvu v závislosti na počtu

V naší úloze používáme dva tyto objekty.

### NumberFormat

Pro zobrazení ceny si nejprve nachystáme *formátovací objekt*, tj. instanci `new Intl.NumberFormat()`. Jejím prvním parametrem je identifikátor jazyka, ve kterém chceme čísla zobrazovat. My předáváme hodnotu `undefined`, která znamená, že prohlížeč má použít svůj výchozí jazyk. To je praktické, neboť uživatelé v různých zemích uvidí naše data vždy dle svých regionálních preferencí.

V druhém parametru (konfiguračním objektu) uvádíme, jakou číselnou hodnotu zobrazujeme (a v jaké měně). Třída `NumberFormat` dovoluje formátování cen, fyzikálních veličin, procent a obecných čísel. Vzniklý formátovací objekt pak metodou `format` aplikujeme na konkrétní číselná data a zpět dostáváme řetězce určené k zobrazení.

Pro úplnost uveďme několik příkladů tohoto rozhraní:

```js
new Intl.NumberFormat("cs", {style:"currency", currency:"CZK"}).format(1234.56);
// "1 234,65 Kč"

new Intl.NumberFormat("en", {style:"currency", currency:"CZK"}).format(1234.65);
// "CZK 1,234.65"

new Intl.NumberFormat("cs", {style:"currency", currency:"USD"}).format(123);
// "123,00 US$"

new Intl.NumberFormat("en", {style:"currency", currency:"USD"}).format(123);
// "$123.00"
```

Všimněme si například různých oddělovačů tisíců, nebo desetinné tečky (v Angličtině) vs. desetinné čárky (v Češtině). Implementovat tyto rozdíly ručně by bylo velmi pracné.


### DateTimeFormat

S formátovacím objektem typu `DateTimeFormat` se pracuje stejně, jen mu hodnotu musíme předat jako instanci JavaScriptové třídy `Date`. JavaScript totiž má, na rozdíl od JSONu, vestavěný datový typ pro datum a čas. Objekty `Date` reprezentují bod v čase a fakticky tak nabízí podobnou funkcionalitu, jako zmiňovaný timestamp. V porovnání s číslem ovšem nabízí užitečné metody na čtení a změnu jednotlivých součástí (rok, měsíc, den, hodina, minuta, &hellip;).

Formátování data tím pádem provedeme ve dvou krocích: nejprve ze získané hodnoty (JSON) vytvoříme `Date`, poté provedeme formátování pomocí `Intl.DateTimeFormat`. Víme, že v datech ze serveru může přijít buď řetězec, nebo číslo. Funkce `Date` dokáže přijmout obě tyto hodnoty, ovšem u čísla předpokládá, že timestamp je v milisekundách. Proto příchozí číslo nejprve vynásobíme tisícem.

První parametr pro `DateTimeFormat` je opět identifikátor jazyka, který opět neuvedeme, aby se použil ten, který je v prohlížeči výchozí. V konfiguračním objektu pak můžeme řadou vlastností upřesnit, které všechny komponenty z data a času chceme vypsat (a s jakou mírou podrobnosti). Nás zajímá jen datum, proto uvádíme klíč `dateStyle` (pro čas bychom přidali ještě `timeStyle`). Ze zvědavosti se podíváme, jaké hodnoty připadají v úvahu:

```js
let date = new Date("1982-10-19");

new Intl.DateTimeFormat("cs", {dateStyle:"full"}).format(date);
// "úterý 19. října 1982"

new Intl.DateTimeFormat("cs", {dateStyle:"long"}).format(date);
// "19. října 1982"

new Intl.DateTimeFormat("cs", {dateStyle:"medium"}).format(date);
// "19. 10. 1982"

new Intl.DateTimeFormat("cs", {dateStyle:"short"}).format(date);
// "19.10.82"
```

### Co jsme se naučili

Po vyřešení deváté úlohy by měl čtenář chápat a ovládat:

- reprezentaci data v JavaScriptu a JSONu
- smysl rozhraní `Intl`
- práci s objekty `Intl.NumberFormat` a `Intl.DateTimeFormat`


## Zelenáči: Web Storage

Protože úloha v této kapitole je motivována e-shopem, mohli bychom si vyzkoušet implementaci jednoduchého nákupního košíku. Do něj smí uživatel vložit položky, o které má zájem, a při jejich výpisu bude tato skutečnost zmíněna. Klíčovým atributem nákupního košíku je, že jeho obsah je dostupný i po znovunačtení stránky. Typicky je toho docíleno ukládáním obsahu košíku na serveru, ale v této knize se soustředíme na klientský JavaScript a zároveň je to skvělý způsob, jak si vyzkoušet další užitečné a přitom velmi snadné rozhraní -- *Web Storage*.

Prohlížeč nám prostřednictvím Web Storage nabízí možnost uložit data tak, abychom se k nim dostali při všech dalších návštěvách dané stránky. Přesněji, tato data jsou dostupná *všem stránkám na té doméně, ve které byla uložena*. Máme tak zaručeno, že se k takto uloženým datům nedostanou skripty z cizích stránek.

S rozhraním Web Storage pracujeme prostřednictvím globální proměnné `localStorage`, která nabízí dvě hlavní metody:

```js
// zápis
localStorage.setItem(key, value);

// čtení
let value = localStorage.getItem(key);
```

Vidíme, že do Web Storage ukládáme dvojice klíč-hodnota. Jak klíče, tak hodnoty musí být obyčejné řetězce. Pokud tedy chceme uložit složitější data (jako například nákupní košík), budeme je muset pro potřeby uložení převést na řetězec.

Nákupní košík můžeme reprezentovat různými způsoby, nejjednodušeji jako pole identifikátorů těch položek, které jsou v košíku. Abychom toto pole mohli vložit do `localStorage`, můžeme jej převést na řetězec například metodou `JSON.stringify` (dostaneme řetězec ve formátu JSON). Při načtení stránky pak košík z minula, pokud nějaký je, získáme zpět z `localStorage` a převedeme na pole metodou `JSON.parse`:

```js
let storedData = localStorage.getItem("shopping-cart");
let shoppingCart = storedData ? JSON.parse(storedData) : [];

function addToCart(id) {
	shoppingCart.push(id);
	localStorage.setItem("shopping-cart", JSON.stringify(shoppingCart));
}

function removeFromCart(id) {
	let index = shoppingCart.indexOf(id);
	if (index != -1) {
		shoppingCart.splice(index, 1);
		localStorage.setItem("shopping-cart", JSON.stringify(shoppingCart));
	}
}
```

Odebírání položky z pole je komplikovanější. Nejprve musíme zjistit její *index* (tj. na kolikátém místě se nachází) a pak z pole odstranit prvek dle indexu. Používáme k tomu metodu `indexOf`; ta pro neexistující prvek vrací speciální hodnotu `-1`.

Jistou alternativou by bylo ukládání položek v množině (objekt `Set`), u které je -- na rozdíl od pole -- zaručena jedinečnost a proto je možné prvek odebrat bez znalosti indexu. Množinu ale neumíme přímočaře reprezentovat ve formátu JSON, takže se budeme držet obyčejného pole. Pak už jen stačí ke každé položce přidat ještě tlačítko:

```js
function buildCartButton(item) {
	let button = document.createElement("button");

	if (shoppingCart.includes(item.id)) {
		button.textContent = "Odebrat z košíku";
	} else {
		button.textContent = "Přidat do košíku";
	}

	button.addEventListener("click", () => {
		if (shoppingCart.includes(item.id)) {
			removeFromCart(item.id);
		} else {
			addToCart(item.id);
		}

		let newButton = buildCartButton(item);
		button.replaceWith(newButton);
	});

	return button;
}
```

Jakmile dojde ke změně obsahu košíku, musíme tuto skutečnost zohlednit v uživatelském rozhraní. Jednou z možností by byla změna textu na existujícím tlačítku. Tím bychom ale měli kód s nastavováním textu dvakrát. Proto je snazší vyrobit nové tlačítko (se správným novým textem) a nahradit jím to původní.


## Koumáci: Polyfill
## Profíci: další API
